[{"content":"豆包MarsCode 是豆包旗下的AI编程助手，支持主流的编程语言和IDE，提供单行代码或整个函数的编写建议。\n我之前体验过vscode的插件，Baidu Comate，基本能实现豆包MarsCode的功能。\n一、相比之下，豆包 MarsCode - 文档增加了，MarsCode IDE。\n这是一个云端 AI IDE 平台，提供 C、C++、C#、Go、JavaScript、Java、Node.js、Rust、TypeScript 等语言的开发环境和模板。\n这就非常方便了。\n二、开发文档写的很全面，而且依靠豆包的名声，使用友好程度和使用人数我觉得远大于Baidu Comate。\n番茄时钟开发 体验了豆包MarsCode，就发现AI对话框内能实时渲染出界面，类似于claude的Artifacts，体验不错。\n优点：一键插入代码，不需要再复制粘贴了。\n缺点：但是生成代码速度比较慢\nDatawhale-AI活动\n在给的prompt的中\n请你基于html、tailwind css和javascript，帮我设计一个“番茄时钟”。要求UI简洁美观大方，同时具有呼吸感，点击开始计时、点击暂停计时和重置计时的功能能够完美实现\r请你基于html、tailwind css和javascript，帮我设计一个“井字棋游戏”。要求UI简洁美观大方，同时具有呼吸感，人类玩家以及电脑玩家放置棋子，游戏胜负平局判定条件能够完美实现 都提到了一个词呼吸感，引出了第二天的学习内容有关关键词唤醒。\n呼吸感这个词真是一个好词。\n在摄影领域是要有生命力，电影领域是：就是好萊塢業界所稱的手搖鏡頭(hand-held camera)或晃動鏡頭(shaky camera)。最早源自於紀錄片拍攝與1960年興起的法國真實電影(Cinéma vérité)流派。\n设计领域又是一个复杂的词语。\n我觉得我理解不了这种感觉， 不过大模型学习这类东西倒是很擅长，学习这类不确定的事物的特征然后再表述出来，很难用语言表述出来的这种感觉，大模型反而做的很好。 这个词真是大模型的优势。\n","date":"2024-12-23T17:36:00Z","image":"http://localhost:1313/post/cover/datawhale-cover.png","permalink":"http://localhost:1313/post/marscode/","title":"Datawhale冬令营第二期-动手学AI辅助编程"},{"content":"Mysql安装 检验是否安装 命令行提示 cmd中验证 mysql -u root -p navicat17连接远程的数据库 输入地址及密码，使用navicat17\ntomcat安装 我的tomcat目录\nD:\\tomcat\\apache-tomcat-8.5.57\n如何创建表 一、了解表和表之间的关系 四种关系： 没有关系 一对一 1对多或多对1 多对多 关联字段可以设置在任意的一张表中\n这里的多表指的是：多对一的关系。\nSQL语句 新建数据库 全选、运行、刷新 DROP TABLE IF EXISTS `class`; CREATE TABLE `class` ( `id` int(11) NOT NULL AUTO_INCREMENT, `class_num` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT \u0026#39;班级号\u0026#39;, `class_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT \u0026#39;班级名称\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Compact; -- ---------------------------- -- Records of class -- ---------------------------- INSERT INTO `class` VALUES (1, \u0026#39;20201001\u0026#39;, \u0026#39;软件工程\u0026#39;); INSERT INTO `class` VALUES (2, \u0026#39;20201002\u0026#39;, \u0026#39;计算机科学\u0026#39;); INSERT INTO `class` VALUES (3, \u0026#39;20201003\u0026#39;, \u0026#39;网络工程\u0026#39;); INSERT INTO `class` VALUES (4, \u0026#39;20201005\u0026#39;, \u0026#39;数学\u0026#39;); -- ---------------------------- -- Table structure for course -- ---------------------------- DROP TABLE IF EXISTS `course`; CREATE TABLE `course` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \u0026#39;选课表\u0026#39;, `cno` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT \u0026#39;课程号\u0026#39;, `gradeName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT \u0026#39;课程名称\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Compact; -- ---------------------------- -- Records of course -- ---------------------------- INSERT INTO `course` VALUES (1, \u0026#39;1001\u0026#39;, \u0026#39;数学\u0026#39;); INSERT INTO `course` VALUES (2, \u0026#39;1002\u0026#39;, \u0026#39;语文\u0026#39;); INSERT INTO `course` VALUES (3, \u0026#39;1003\u0026#39;, \u0026#39;英语\u0026#39;); -- ---------------------------- -- Table structure for relationship -- ---------------------------- DROP TABLE IF EXISTS `relationship`; CREATE TABLE `relationship` ( `id` int(11) NOT NULL AUTO_INCREMENT, `sno` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT \u0026#39;学号\u0026#39;, `cno` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT \u0026#39;课程号\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Compact; -- ---------------------------- -- Records of relationship -- ---------------------------- INSERT INTO `relationship` VALUES (1, \u0026#39;202001\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (2, \u0026#39;202001\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (3, \u0026#39;202001\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (4, \u0026#39;202002\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (5, \u0026#39;202002\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (6, \u0026#39;202003\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (7, \u0026#39;202004\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (8, \u0026#39;202004\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (9, \u0026#39;202004\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (10, \u0026#39;202005\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (11, \u0026#39;202005\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (12, \u0026#39;202006\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (13, \u0026#39;202006\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (14, \u0026#39;202006\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (15, \u0026#39;202007\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (16, \u0026#39;202009\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (17, \u0026#39;202009\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (18, \u0026#39;202009\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (19, \u0026#39;202010\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (20, \u0026#39;202010\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (21, \u0026#39;202010\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (22, \u0026#39;202011\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (23, \u0026#39;202012\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (24, \u0026#39;202012\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (25, \u0026#39;202013\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (26, \u0026#39;202013\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (27, \u0026#39;202014\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (28, \u0026#39;202014\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (29, \u0026#39;202014\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (30, \u0026#39;202015\u0026#39;, \u0026#39;1003\u0026#39;); INSERT INTO `relationship` VALUES (31, \u0026#39;202015\u0026#39;, \u0026#39;1001\u0026#39;); INSERT INTO `relationship` VALUES (32, \u0026#39;202016\u0026#39;, \u0026#39;1002\u0026#39;); INSERT INTO `relationship` VALUES (33, \u0026#39;202016\u0026#39;, \u0026#39;1003\u0026#39;); -- ---------------------------- -- Table structure for student -- ---------------------------- DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL, `sex` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL, `age` int(11) NOT NULL, `sno` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT \u0026#39;学号\u0026#39;, `class_num` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT \u0026#39;班级号\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Compact; -- ---------------------------- -- Records of student -- ---------------------------- INSERT INTO `student` VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;男\u0026#39;, 20, \u0026#39;202001\u0026#39;, \u0026#39;20201001\u0026#39;); INSERT INTO `student` VALUES (2, \u0026#39;李四\u0026#39;, \u0026#39;男\u0026#39;, 21, \u0026#39;202002\u0026#39;, \u0026#39;20201001\u0026#39;); INSERT INTO `student` VALUES (3, \u0026#39;王五\u0026#39;, \u0026#39;男\u0026#39;, 20, \u0026#39;202003\u0026#39;, \u0026#39;20201001\u0026#39;); INSERT INTO `student` VALUES (4, \u0026#39;张安\u0026#39;, \u0026#39;女\u0026#39;, 23, \u0026#39;202004\u0026#39;, \u0026#39;20201001\u0026#39;); INSERT INTO `student` VALUES (5, \u0026#39;萨达\u0026#39;, \u0026#39;女\u0026#39;, 21, \u0026#39;202005\u0026#39;, \u0026#39;20201001\u0026#39;); INSERT INTO `student` VALUES (6, \u0026#39;阿斯蒂芬\u0026#39;, \u0026#39;女\u0026#39;, 22, \u0026#39;202006\u0026#39;, \u0026#39;20201002\u0026#39;); INSERT INTO `student` VALUES (7, \u0026#39;广大儒风\u0026#39;, \u0026#39;男\u0026#39;, 20, \u0026#39;202007\u0026#39;, \u0026#39;20201002\u0026#39;); INSERT INTO `student` VALUES (8, \u0026#39;安顺\u0026#39;, \u0026#39;男\u0026#39;, 20, \u0026#39;202008\u0026#39;, \u0026#39;20201002\u0026#39;); INSERT INTO `student` VALUES (9, \u0026#39;东方\u0026#39;, \u0026#39;女\u0026#39;, 20, \u0026#39;202009\u0026#39;, \u0026#39;20201002\u0026#39;); INSERT INTO `student` VALUES (10, \u0026#39;咖啡\u0026#39;, \u0026#39;男\u0026#39;, 20, \u0026#39;202010\u0026#39;, \u0026#39;20201002\u0026#39;); INSERT INTO `student` VALUES (11, \u0026#39;回顾\u0026#39;, \u0026#39;女\u0026#39;, 20, \u0026#39;202011\u0026#39;, \u0026#39;20201003\u0026#39;); INSERT INTO `student` VALUES (12, \u0026#39;同意\u0026#39;, \u0026#39;男\u0026#39;, 20, \u0026#39;202012\u0026#39;, \u0026#39;20201003\u0026#39;); INSERT INTO `student` VALUES (13, \u0026#39;规划局\u0026#39;, \u0026#39;女\u0026#39;, 20, \u0026#39;202013\u0026#39;, \u0026#39;20201003\u0026#39;); INSERT INTO `student` VALUES (14, \u0026#39;各环节\u0026#39;, \u0026#39;男\u0026#39;, 20, \u0026#39;202014\u0026#39;, \u0026#39;20201003\u0026#39;); INSERT INTO `student` VALUES (15, \u0026#39;空格\u0026#39;, \u0026#39;女\u0026#39;, 20, \u0026#39;202015\u0026#39;, \u0026#39;20201003\u0026#39;); INSERT INTO `student` VALUES (16, \u0026#39;发送到\u0026#39;, \u0026#39;男\u0026#39;, 22, \u0026#39;202016\u0026#39;, \u0026#39;20201004\u0026#39;); SET FOREIGN_KEY_CHECKS = 1; sql语句中不区分大小写\nsql语句关键字必须写在最前面\n一、查询语句\u0026mdash;select select关键字 select 查询字段 from 查询的表 #查询 select id from student select id,name from stdent select id,name,sex from student #查询所有字段 select * from student (1)条件查询\u0026mdash;\u0026gt;where 关键字：where\n运算符 说明 = 等于 \u0026lt;\u0026gt;或！= 不等于 \u0026lt; 小于 \u0026lt;= 小于等于 \u0026gt; 大于 \u0026gt;= 大于等于 between..and\u0026hellip; 两个值之间 is null 为null and 并且 or 或者 in 包含 not not可以取非，主要用在is或in like like为模糊查询，支持%或_匹配 #查询 select * from student where class_num = \u0026#39;20201001\u0026#39; #查询id为1 select * from student where id = 1 #查询出年龄不是20岁的学生 select * from student where age \u0026lt;\u0026gt;20 select * from student where age != 20 #查询出年龄大于20岁的学生 #查询出年龄小于20岁的学生 select name from student where age \u0026lt; 20 #查询出年龄小于20岁的学生---》字符串类型没法比较 #查询年龄20-25岁的学生---》between...and... #都是闭区间 select age from student where age between 21 and 23 #查询班级号为空的学生---》null select * from student where class_num is null #查询出班级号为20201001班的男同学---》and select * from student where class_num = \u0026#39;20201001\u0026#39; and sex = \u0026#39;男\u0026#39; #查询出班级号20201001班的同学和其他班的男同学 select * from student where class_num =\u0026#39;20201001\u0026#39; or sex = \u0026#39;男\u0026#39; 操作符IN、between\u0026hellip;and 允许我们在 WHERE 子句中规定多个值\n#IN操作符运行在WHere子句中规定多个值 #查询出用户id为1和3的用户记录 select * from student where id in (1,3,5,8) 模糊查询\u0026mdash;\u0026gt;like和_、% 匹配字符 #_（一次匹配一个字符）%（一次匹配多个字符）\n#查询出名字中带有王字的同学---》like select * from student where name like \u0026#39;%王%\u0026#39; #查询出名字中带有王字开头且两个字的同学 select * from student where name like \u0026#39;王_\u0026#39; 分组函数/聚合函数 sum 求和 avg 取平均 max 取最大值 min 取最小值 count 取得记录数 #求学生年龄的总和 select sum(age) sum_age from student #查询出所有学生的平均年龄 select avg(age) avg_age from student #查询出年龄最大的同学 select max(age) from student; select min(age) from student; #查询所有学生的数量 select count(*) from student; select count(class_num) from student; #列别名 select count(class_num) class_result from student; 注意：count(*)表示去取得查询表的所有记录，count(字段名)，不会统计为null的记录。\n(2)分组查询group by 作用：通过那个或那些字段进行分组\n用法：group by 字段名称 #求各个班级的平均年龄--\u0026gt;按照班级分组 select class_num,avg(age) from student GROUP BY class_num 结果列指定了一个别名\n#求各个班级的平均年龄 select class_num,avg(age) avg_result from student GROUP BY class_num (3)排序order by 和倒序desc select查询的结果默认的是按照从小到大排序的，而且是以id为主列进行从大到小排序的。也就是根据主键排序。\n要根据其他条件排序如何做？\n查询排序的关键字：order by\n#按照年龄正序排列 SELECT * from student ORDER BY age; desc表示“倒序”\n#按照年龄倒序排列 select * from student ORDER BY age DESC 年龄降序且学号升序 如果要按照年龄降序，并且按照学号升序怎么做？\n也就是说\n首先按照 age 从大到小排序（23, 22, 22, 20, 20）。\n然后在相同 age 的情况下，按照 sno 从小到大排序（例如，202006 在 `202016 之前，因为 006 \u0026lt; 016）。\n#简化写法 SELECT * FROM student ORDER BY age DESC, sno; #完整写法 多了ASC SELECT * FROM student ORDER BY age DESC, sno ASC; #易于读的写法 SELECT * FROM student ORDER BY age DESC, sno ASC; (4)分页查询/限制查询 使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。\n要实现分页功能，实际上就是从结果集中显示第1100条记录作为第1页，显示第101200条记录作为第2页，以此类推。\n因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT OFFSET 子句实现。\nlimit限制查询 首先，先查询结果中的前三条数据。\nLIMIT OFFSET分页 然后，把结果集分页，每页三条记录，那么获取第一条记录：\n#LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。** SELECT * from student LIMIT 3 offset 0; 如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：\n#对结果集从第3号记录开始，最多取3条。 SELECT * from student LIMIT 3 offset 3; 关键点 可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：\nLIMIT总是设定为pageSize OFFSET计算公式为pageSize * (pageIndex - 1) 很好理解\n简化写法 SELECT * from student LIMIT 0,3; #对结果集从3号记录开始，最多取3条 SELECT * from student LIMIT 3,3; #对结果集从3号记录开始，最多取6条 SELECT * from student LIMIT 3,6; 小结 使用LIMIT OFFSET 可以对结果集进行分页，每次查询返回结果集的一部分；\n分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。\n(5)连表查询/跨表查询 在实际开发中，数据往往不是存放一张表中，而是同时存储在多张表中，这些表与表存在着关系，我们在检索数据的时候往往需要多张表联合起来检索，这种多表联合检索被称为连表查询或跨表查询。\n笛卡尔积现象\n含义：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录的成绩，该现象称为笛卡尔积现象。\n1.左/右外连接 首先，student表\nclass表\n要查询每个学生的班级名称？ 可以看到学生表中，只有班级编号，没有班级名称。而班级表中有班级编号和班级名称。共同点是班级编号。 这就是班级名称的数据在student表中找不到，需要用到class表，那么不是存放一张表中，而是同时存储在2张表中，那么需要联合起来搜索。\n1.SQL92语法 select xxx from A 表名,B表名 where 表连接条件 and 数据查询条件;（读者可以跳过不看） SELECT s.name,c.class_name from student s,class c where s.class_num = c.class_num 缺点：表连接条件与查询条件放在一起，没有分离 2.SQL99语法\nselect xxx from A 表名 join B 表名 on 表的连接条件\n#查询每个学生的班级名称---\u0026gt;左连接 SELECT student.*,class.class_num from student left JOIN class ON student.class_num = class.class_num 优点：表连接独立，结构清晰，如果结果数据不满足要求，可再追加where条件进行过滤；\n从查询结果可以看到，绿色部分全都是student表，class_num(1)是class表中的class_num自动生成的列。（也可以设置别名）\n同理右连接：\n结果分析（重点）： 查询每个学生的班级名称，即使某些学生没有对应的班级（不保留班级）。 左连接：class有class_num为20021001-03和05的班级，student的class_num只有01-04的学生。左表student的全部记录，与右表class不匹配的部分为Null。\n查询每个班级的学生，即使某些班级没有对应的学生(不保留学生) 右连接：student的class_num有01-04的学生，class的class_num有01-03和05的班级。保留右表课程表的全部记录，与左表不匹配的部分为Null。\n设置别名\n总结： 左连接（LEFT JOIN）：以左表为基准，保留左表的所有记录，右表中匹配的记录显示，不匹配的部分为 NULL。\n右连接（RIGHT JOIN）：以右表为基准，保留右表的所有记录，左表中匹配的记录显示，不匹配的部分为 NULL。\n小总结：连接其实就是将两个表放在一起成为一个表，然后进行select进行查询 SELECT 你想要结果中出现的字段(不一定结果中都需要出现两个表的字段) from student 连接方式 class ON 两张表中的相同或相关的字段（如主键和外键）\n肯定有个疑问，on后的关系是什么？两张表是否必须有相同的字段才能使用连接？ 不一定。虽然在大多数情况下，连接条件基于两张表中的相同或相关的字段（如主键和外键），但两张表不需要有完全相同的字段才能进行连接。关键在于找到能够建立逻辑关联的字段。\non后的关系是什么呢？ 首先要了解一下一个表可以包含哪些字段：\n关系型数据库的字段分类 关系型数据库中，一个表可以包含以下几类字段：\n主键：用于唯一标识表中的每一条记录，每个表必须有一个主键。\n用于唯一标识表中的每一条记录。\n每个表通常有一个主键，可以是单一字段（如 id）或由多个字段组成的复合主键。\n主键的值必须唯一且不能为空（NOT NULL）。\n外键：用于建立与其他表的关联关系，确保数据的参照完整性，一个表可以有多个外键，也可以没有外键。\n用于在一个表中引用另一个表的主键，从而建立两个表之间的关系。\n外键可以帮助维护数据的参照完整性，确保引用的数据在被引用的表中存在。\n其他\n非键字段：用于存储与实体相关的其他信息，不参与表之间的关联。\n这些字段既不是主键也不是外键，用于存储与实体相关的其他信息。\n例如，在学生表中，name、age、address 等字段就是非键字段。\n区分on后的关系和外键： on后一定是外键吗？\n外键必须是引用主键建立两个表之间建立关系的键，****\non后是两个表之间建立关系的字段，在两表连接的时候，on后的字段有可能是外键，也就是使用了一个表中的主键。\n所以on后的关系可以是： 两个表之间相同的字段、可能是主键也可能是非键字段\n两个表之间不同的字段，可以完全不同。\n例如：\n一、完全不相同的字段 course表\nstudent表\n完全没有相同的字段。\n这里使用student.class_num = course.gradeName作为on后的条件，显然两者完全不相同。\n#连表查询--\u0026gt;on后的字段完全不同 SELECT student.*,course.gradeName from student left JOIN course ON student.class_num = course.gradeName 左连接后，以student为主表，查询出gradeName，一个都没有与主表student匹配。\n左连接后，以student为主表，查询出gradeName，一个都没有与主表course匹配。\n结果总结： 以主表为主，如果任何字段都不相同，只显示主表。\n二、主键 如果id为主键，以id为on后的条件，可以实现两表合并。 on后的条件决定了表结果的长度 2.内连接 join或inner join inner join是以两个表的交集，class_num有交集的就查的到\n我们想要查询每个学生的班级名称，结果只包括那些实际有班级的学生。\n举例：\n学生表（student）\nsno name class_num S001 Alice C001 S002 Bob C002 S003 Charlie C001 S004 David C003 S005 Eva NULL 班级表（class）\nclass_num class_name C001 一班 C002 二班 C003 三班 C004 四班 SELECT student.sno, student.name, class.class_name FROM student INNER JOIN class ON student.class_num = class.class_num; sno name class_name S001 Alice 一班 S002 Bob 二班 S003 Charlie 一班 S004 David 三班 二、插入语句\u0026ndash;insert 在设计表的时候id表要设置自动递增\nid为自动递增的时候，不用设置递增。\n#插入 insert into student(name,sex,age,sno,class_num) VALUE(\u0026#39;asd\u0026#39;,\u0026#39;男\u0026#39;,\u0026#39;18\u0026#39;,\u0026#39;202017\u0026#39;,\u0026#39;20201004\u0026#39;); SELECT * from student #插入多行 insert into student(列表1,列表2,列表3) VLAUE(值1,值2,值3),(值1,值2,值3),(值1,值2,值3),(值1,值2,值3); 一次插入多条数据\ninsert into student(name,sex,age,sno,class_num) VALUE(\u0026#39;asd\u0026#39;,\u0026#39;男\u0026#39;,\u0026#39;18\u0026#39;,\u0026#39;202017\u0026#39;,\u0026#39;20201004\u0026#39;),(\u0026#39;asdf\u0026#39;,\u0026#39;男\u0026#39;,\u0026#39;19\u0026#39;,\u0026#39;202018\u0026#39;,\u0026#39;20201004\u0026#39;),(\u0026#39;d\u0026#39;,\u0026#39;男\u0026#39;,\u0026#39;20\u0026#39;,\u0026#39;202019\u0026#39;,\u0026#39;20201003\u0026#39;); SELECT * from student 四、update修改操作 一定要记得要添加上条件列，一般是id\n# update 表名 set 列名 update student set name = \u0026#34;张三安\u0026#34;,age = 20,sno=\u0026#39;123456\u0026#39; where id =1 update student set name = \u0026#34;张三安\u0026#34;,age = 20,sno=\u0026#39;123456\u0026#39; 如果不加id，那么整个表对应的字段都被修改。\n五、删除delete操作 delete from student 会逐行删除记录，并且每一行的删除都会被记录在事务日志中。 delete from 表名 where id = 1 # 一行行删除 delete from student #会删除 student 表中的每一条记录，但不会删除表结构本身。本质是一行行删除。 删除所有行：该语句会删除 student 表中的每一条记录，但不会删除表结构本身。\n保留表结构：表的定义、列、约束（如主键、外键）以及索引等都会保留不变。\nTRUNCATE 快速删除 TRUNCATE table 表名\n# TRUNCATE table 表名 删除这张表，但是还是会创建一个和原始表结构一样的新表。相当于只删除表中的数据，保留表结构。 TRUNCATE TABLE student; 区别：\n性能： TRUNCATE 通常比 DELETE 更快，因为它不逐行删除，而是直接释放数据页。 日志记录： DELETE 会为每一行删除操作记录日志，占用更多的事务日志空间。 TRUNCATE 记录的是页级别的操作，日志占用较少。 触发器： DELETE 会触发与删除操作相关的触发器（DELETE 触发器）。 TRUNCATE 通常不会触发 DELETE 触发器，因为它不是逐行删除。 条件删除： DELETE 可以使用 WHERE 子句指定条件删除部分记录。 TRUNCATE 无法使用 WHERE 子句，只能删除所有记录。 drop\u0026mdash;\u0026gt;彻底删除这张表 DROP TABLE 会删除整个表，包括表结构、数据和相关的约束。\n","date":"2024-12-23T16:24:00Z","image":"http://localhost:1313/post/cover/mysql-cover.jpg","permalink":"http://localhost:1313/post/mysql01/","title":"Mysql、tomcat、sql语句"},{"content":"JDK17和JDK1.8区别 1.8版本之前，jdk和jre是分开的，例如：1.6版本\n17和21的版本是企业在用的\n一、jdk目录文件解释 C:\\Program Files\\Java\\\n这是一般默认安装JDK的路径。\nbin目录下都是可执行文件 D:\\Javaweb\\java8\\jdk1.8\\bin\nbin下有java.exe和javac.exe\njdk/bin目录下有java.exe和javac.exe\n配置环境变量的目的：任意目录下执行java程序 什么是接口 只定义行为，不做实现。\n由具体的东西取实现\njdk中的jre是java运行环境\nlib：java开发工具包\n开发这个程序的时候，第三方其他人开发的东西。\nsrc.zip是jdk的源码 例如：String字符串是一个类，是java提供的，这个String就是在src.zip/java/lang包下。 这个里面的String的所有的类的源码在这里。\n这里indexOf方法的源码就再这里。\nTHIRDPARTYLICENSEREADME.txt 用于记录和展示项目中所有第三方组件及其许可证信息的重要文档。\nTHIRDPARTYLICENSEREADME-JAVAFX.txt 包含 JavaFX 所依赖的第三方组件及其许可证信息的文档。它确保了在分发、使用或修改 JavaFX 时，遵守所有相关的开源许可证要求。\n二、环境变量配置 path是系统环境变量（windows电脑都有）\n这个是系统变量中的Path 第一步：设置%javahome%/bin\n这个是系统变量中的JAVA_HOME 为什么先配path中要配%javahome%/bin，再配javahome？ 第一：方便后续修改jdk目录 如果更改jdk的路径，那么直接更改%JAVA_HOME%变量的路径即可\n第二：方便后续软件安装不报错 有些软件在安装的时候会先找%javahome%再找系统path中的/bin。\n导致一些软件在安装的时候会失败。\n执行过程？ 交给jvm，让计执行class文件，让计算机系统读懂这个程序。\n环境变量配置—报错 错误：\nC:\\Users\\anymore\u0026gt;java -version Error: could not open `E:\\java-jre\\lib\\amd64\\jvm.cfg'\nerror:could not open \u0026hellip;jvm.cfg解决方法 - aspirant - 博客园\n移动到最前面即可\n运行成功\n","date":"2024-12-22T15:15:30Z","permalink":"http://localhost:1313/post/jdk/","title":"JDK安装"},{"content":"vue3基础 Vue3 (vue3js.cn)\n官网：[简介 | Vue.js (vuejs.org)](https://cn. vuejs.org/guide/introduction.html)\n可以使用CDN\n可以用源码\n使用html界面，vscode导入vue插件，简单学习vue语法\nhello word ## v-html及v-text ## v-if及v-else、v-show ​```HTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- CDN --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- v-if 是 Vue.js 中用于条件性地渲染一块内容，内容只会在指令的表达返回true值的时候被渲染。 v-else 可用于提供条件为flase时的替代内容。 功能：当 age 的值大于 18 时，页面会显示“成年人”； 否则，显示“未成年人”。初始值设定为 18，因此会显示“未成年人” --\u0026gt; \u0026lt;!-- v-if --\u0026gt; \u0026lt;h1 v-if=\u0026#34;age \u0026gt; 18\u0026#34;\u0026gt;成年人\u0026lt;/h1\u0026gt; \u0026lt;h1 v-else\u0026gt;未成年人\u0026lt;/h1\u0026gt; \u0026lt;h1 v-show=\u0026#34;ok\u0026#34;\u0026gt;hello!\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app= { data() { return{ age:19, } } } Vue.createApp(app).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-for 基于数组来渲染一个列表，需要 使用 it em in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- CDN --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in list\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app = { data(){ return{ list:[\u0026#39;张三\u0026#39;,\u0026#39;关于\u0026#39;,\u0026#39;刘备\u0026#39;] } } } Vue.createApp(app).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;!-- vue应用app1 --\u0026gt; \u0026lt;div id=\u0026#34;app1\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 不加index，直接使用数组的索引作为key，但是如果元素顺序改变，那么会丢失渲染效果或者状态 key可以为每个渲染的元素提供一个唯一表示，[动态更新列表]的时候可以使用--\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app1 = { data(){ return{ // 数组多个元素 items:[\u0026#39;张三\u0026#39;,\u0026#39;关于\u0026#39;,\u0026#39;刘备\u0026#39;] } } } Vue.createApp(app1).mount(\u0026#39;#app1\u0026#39;); // 挂载app1 \u0026lt;/script\u0026gt; \u0026lt;!-- key的功能：为每一个渲染元素提供唯一标识，动态更新列表 购物车案例--\u0026gt; \u0026lt;!-- 当商品被删除或添加时，Vue 可以通过 id 快速识别哪些商品发生了变化， [从而只更新这些特定的元素，而不是重新渲染整个列表。] 这提高了性能并减少了潜在的错误（例如，状态丢失）。 --\u0026gt; \u0026lt;ul id=\u0026#34;app2\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in cart\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt;{{ item.name }}\u0026lt;/li\u0026gt; \u0026lt;!-- 可以.属性获取对象的不同属性 --\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; const app2 ={ data() { return { // 数组包含对象[{\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;}]【js语法称对象】 cart: [ { id: 1, name: \u0026#39;苹果\u0026#39; }, { id: 2, name: \u0026#39;香蕉\u0026#39; }, { id: 3, name: \u0026#39;橙子\u0026#39; } ] } } } Vue.createApp(app2).mount(\u0026#39;#app2\u0026#39;); // vue的应用app2，用mount挂载app2 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 维护状态 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更 新”的策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素 来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每 个索引位置正确渲染。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和 重新排序现有元素，你需要为每项提供一个唯一的 key attribute： 也就是购物车的例子。\n事件处理 v-on、内联处理器(事件传递参数) v-on监听事件 v-on 指令 (通常缩写为 @ 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为 v-on:click=\u0026quot;methodName\u0026quot; 或 使用快捷方式 @click=\u0026quot;methodName\n事件处理方法 然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写 在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法。 内联处理器中的方法(事件传递参数) 这是官方的翻译称呼，其实我们可以直接叫他 \u0026ldquo;事件传递参数\u0026rdquo; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .status { width: 100px; height: 100px; line-height: 100px; text-align: center; background-color: orange; color: #fff; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- v-on监听dom事件，并在触发事件的时候执行一些js --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;status\u0026#34; v-on:click=\u0026#34;methodName\u0026#34;\u0026gt;点我\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;status\u0026#34; @click=\u0026#34;methodName1\u0026#34;\u0026gt;点我缩写的1\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;counter += 1\u0026#34;\u0026gt;加1\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;当前计数: {{ counter }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;---内联处理器（事件传递参数）\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;say(\u0026#39;hi\u0026#39;)\u0026#34;\u0026gt;say hiokok\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = { methods: { // 记住为methods methodName() { console.log(\u0026#39;我被点了一下\u0026#39;); }, methodName1() { console.log(\u0026#39;我被点了一下\u0026#39;); }, say(message){ alert(message) } }, data() { return { counter: 0 } } } Vue.createApp(app).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表单输入绑定 v-model 用 v-model 指令在表单、 及 元素上创 建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 用起来非常神奇 但 v-model 本质上不过是语法糖。它负责监听用 户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理。 语法糖：\nv-model 被称为“语法糖”，这意味着它为你简化了代码的写法。实际上，v-model 处理了事件监听和数据更新，背后使用了相应的方法（如 input 事件）来同步数据。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- CDN --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- v-model 在input textarea select元素上进行数据绑定，--\u0026gt; \u0026lt;div id = \u0026#39;app\u0026#39;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model = \u0026#34;account\u0026#34; @keyup = \u0026#34;change\u0026#34;\u0026gt; \u0026lt;p\u0026gt;当前账户: {{ account }}\u0026lt;/p\u0026gt; \u0026lt;!-- 每次在输入框中输入内容时，account 的值会更新 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app = { data(){ return { account:\u0026#39;zs\u0026#39; } }, methods:{ change(){ console.log(this.account) } } } Vue.createApp(app).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-bind v-bind能动态绑定html标签中的属性，在这个例子中，当vue实例中的值变化的时候，html标签中的id值也会随着动态变化？\nChatGPT\n是的，正如你所描述的，当 Vue 实例中的 dynamicId 值发生变化时，使用 v-bind 绑定的 HTML 标签中的 id 属性值也会自动更新。这是 Vue 的响应式特性之一。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- CDN --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 插值表达式 --\u0026gt; \u0026lt;p\u0026gt; {{msg}} - {{title}} - {{price}} 123\u0026lt;/p\u0026gt; \u0026lt;!-- 指令v-html，v-text --\u0026gt; \u0026lt;!-- 指令v-html和v-text是将标签中的内容进行覆盖 功能：为了输出原始的html，需要使用v-html指令 --\u0026gt; \u0026lt;p v-html=\u0026#34;msg\u0026#34;\u0026gt;我被覆盖了\u0026lt;/p\u0026gt; \u0026lt;p v-text=\u0026#34;title\u0026#34;\u0026gt;我也被覆盖了\u0026lt;/p\u0026gt; \u0026lt;!-- v-bind v-bind 将 Vue 实例中的数据动态绑定到 HTML 元素的属性，而不是使用 Mustache 语法。 --\u0026gt; \u0026lt;!-- 此处将id属性绑定为“动态id”与vue实例中的值绑定 --\u0026gt; \u0026lt;p v-bind:id = \u0026#34;dynamicId\u0026#34;\u0026gt;我是v-bind\u0026lt;/p\u0026gt; \u0026lt;!-- v-html输出html标签渲染的内容，显示在页面上 --\u0026gt; \u0026lt;p v-html=\u0026#34;rawhtml\u0026#34;\u0026gt;我被覆盖了\u0026lt;/p\u0026gt; \u0026lt;!-- v-text输出原始的html标签代码，显示在页面上 也就是输出文本 --\u0026gt; \u0026lt;p v-text=\u0026#34;rawhtml\u0026#34;\u0026gt;我也被覆盖了\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.createApp({ data() { return { msg: \u0026#39;hello vue3\u0026#39;, title: \u0026#39;one piece\u0026#39;, price: \u0026#39;$163\u0026#39;, rawhtml:\u0026#34;\u0026lt;a href=\u0026#39;https://www.baidu.com\u0026#39;\u0026gt;百度\u0026lt;/a\u0026gt;\u0026#34;, dynamicId:1001 } } }).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 修饰符.lazy 默认行为： 默认情况下，v-model 会在每次 input 事件触发后将输入框的值与数据同步。这意味着每当用户在输入框中输入内容时，Vue 实例中的数据会实时更新。 .lazy 修饰符： 使用 .lazy 修饰符后，数据将会在 change 事件触发时进行同步，而不是在每次 input 事件时。这适用于希望在用户完成输入并离开输入框时才更新数据的场景。 change事件 只有在输入框失去焦点（例如，点击其他地方） 或者用户按下“Enter”键等触发 change 事件时，message 的值才会更新。 可以更控制何时更新数据，避免频繁的更新操作。\n第二个vueapp1\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- CDN --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- v-model 在input textarea select元素上进行数据绑定 此处account有初始值zs，输入框输入内容会改变account变量的值，进行绑定了--\u0026gt; \u0026lt;div id = \u0026#39;app\u0026#39;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model = \u0026#34;account\u0026#34; @keyup = \u0026#34;change\u0026#34;\u0026gt; \u0026lt;p\u0026gt;当前账户: {{ account }}\u0026lt;/p\u0026gt; \u0026lt;!-- 每次在输入框中输入内容时，account 的值会更新 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app = { data(){ return { account:\u0026#39;zs\u0026#39; } }, methods:{ change(){ console.log(this.account) } } } Vue.createApp(app).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;!-- 第二个vueapp 对输入框的内容与 message 变量绑定。 输入框内容和Vues实例的data()函数的message变量进行绑定。 在输入框中输入内容，message的值会自动更新，p标签也显示message的值 。--\u0026gt; \u0026lt;div id=\u0026#34;app1\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;input v-model=\u0026#34;message\u0026#34; placeholder=\u0026#34;edit me\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;input v-model.lazy=\u0026#34;message\u0026#34; placeholder=\u0026#34;edit me\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;Message is: {{ message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app1 = { data() { return { message:\u0026#34;\u0026#34; } } } Vue.createApp(app1).mount(\u0026#39;#app1\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 修饰符.trim 过滤用户输入的首尾空白字符\n报错 vue.global.js:2260 [Vue warn]: Property \u0026ldquo;methodName1\u0026rdquo; was accessed during render but is not defined on instance. at 属性\u0026quot;methodName1\u0026quot;在渲染期间内被访问了，但是没有自傲实例中定义。 调用了methodNme1但是没有写该方法导致的。\nhello\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .status { width: 100px; height: 100px; line-height: 100px; text-align: center; background-color: orange; color: #fff; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- v-on监听dom事件，并在触发事件的时候执行一些js --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;status\u0026#34; v-on:click=\u0026#34;methodName\u0026#34;\u0026gt;点我\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;status\u0026#34; @click=\u0026#34;methodName1\u0026#34;\u0026gt;点我缩写的1\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;counter += 1\u0026#34;\u0026gt;加1\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;当前计数: {{ counter }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;---内联处理器（事件传递参数）\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;say(\u0026#39;hi\u0026#39;)\u0026#34;\u0026gt;say hiokok\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const app = { methods: { // 记住为methods methodName() { console.log(\u0026#39;我被点了一下\u0026#39;); }, methodName1() { console.log(\u0026#39;我被点了一下\u0026#39;); }, say(message){ alert(message) } }, data() { return { counter: 0 } } } Vue.createApp(app).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; vue中js表达式 Vue 允许在模板中使用单个 JavaScript 表达式进行数据绑定。\n但不能使用多条语句或复杂的控制结构。\n这些表达式在当前 Vue 实例的数据作用域下被解析。\n例如：\nJavaScript 表达式： {{ number + 1 }}：将 number 增加 1。 {{ ok ? 'YES' : 'NO' }}：根据 ok 的布尔值返回 'YES' 或 'NO'。 {{ message.split('').reverse().join('') }}：将 message 字符串反转。 限制： 但每个绑定只能包含单个表达式，不能是语句。 例如，以下示例无效： {{ vara = 1 }}：这是一个赋值语句，不是表达式。 if (ok) return message：这是一个控制结构，也不是表达式。 条件逻辑使用三元表达式： 对于条件逻辑，你需要使用三元运算符（? :），而不能使用 if 语句，因为 if 是语句，不会返回值。 单文件组件 Vue单文件组件Single File Component，*.Vue文件,缩写为SFC\n通常以 .vue 为扩展名。它将 Vue 组件的模板、逻辑和样式封装在一个文件中，使得组件的结构更加清晰和易于管理。\n一个 Vue 单文件组件通常包含三个部分：\u0026lt;template\u0026gt;、\u0026lt;script\u0026gt;、\u0026lt;style\u0026gt;\n\u0026lt;template\u0026gt;\n这一部分定义了组件的 HTML 模板。在这里，你可以使用 Vue 的指令和语法来绑定数据和事件。 主组件\r```JS\r\u0026lt;template\u0026gt;\r\u0026lt;!-- 如何在主组件中加载组件？ --\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;我的主应用\u0026lt;/h1\u0026gt;\r\u0026lt;!-- 3.显示组件 --\u0026gt;\r\u0026lt;Zujian-vue\u0026gt;\u0026lt;/Zujian-vue\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\r// 1.引入\rimport Zujian from \u0026#39;./zujian.vue\u0026#39;;\rexport default {\r// 2.挂载组件\rcomponents: {\rZujian\r}\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;style scoped\u0026gt;\rh3{\rcolor:rgb(5, 0, 99);\r}\r\u0026lt;/style\u0026gt; 创建Vue项目，运行单文件组件 npm install -g @vue/cli vue --version vue create vue-demo 按键盘数字选择Babel和 Progressive Web App (PWA) Support 两个选项即可\nnpm run serve 运行成功后，删除App.vue\n在/src目录下创建MainZujian.vue\n在src/components目录下创建zujian.vue\n如下：\n\u0026lt;template\u0026gt; \u0026lt;!-- zujian.vue模板 --\u0026gt; \u0026lt;h3\u0026gt;单文件组件\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 逻辑 export default { name:\u0026#34;Zujian\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; /* 样式 */ h3{ color:red; } \u0026lt;/style\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- MainZujian.vue--\u0026gt; \u0026lt;!-- 如何在主组件中加载组件？ --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我的主应用\u0026lt;/h1\u0026gt; \u0026lt;!-- 3.显示组件 --\u0026gt; \u0026lt;!-- \u0026lt;Zujian-vue\u0026gt;\u0026lt;/Zujian-vue\u0026gt; --\u0026gt; \u0026lt;zujian\u0026gt;\u0026lt;/zujian\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 1.引入子组件 import Zujian from \u0026#39;./components/zujian.vue\u0026#39;; export default { // 2.挂载组件 components: { Zujian } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; h3{ color:rgb(5, 0, 99); } \u0026lt;/style\u0026gt; npm run serve 看到实现了\nProps组件交互（自定义的属性） 组件与组件之间是需要存在交互的，否则完全没关系，组件的意义就很小了 Prop 是什么：\nProp 是你可以在组件上注册的一些自定义 attribute（属性）\n这句话写的就不像人话 我来说：它就是 Vue 组件中自定义的属性，用于父组件向子组件传递数据。\n在父组件使用子组件时，可以通过类似 :title=\u0026quot;标题\u0026quot; 这样的方式传递一个值到子组件的 title 属性。\n在父组件中：\n\u0026lt;zujian title=\u0026#34;我是父组件中使用子组件，定义的标题属性，即将传递给子组件\u0026#34;\u0026gt;\u0026lt;/zujian\u0026gt; 子组件中：\nVue模板的逻辑中，添加：\nprops:{ title:{ type:String, default:\u0026#34;\u0026#34; //二、 default就是如果没设置子组件的title属性那么默认为空字符串 } 代码：\n子组件：\n\u0026lt;template\u0026gt; \u0026lt;!-- 模板 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;单文件组件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{ title }} \u0026lt;/p\u0026gt; \u0026lt;!-- 二、插值语法展示从父组件传过来的title属性的值 --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 逻辑 export default { name:\u0026#34;Zujian\u0026#34;, // 二、这里是子组件的 自定义属性props props:{ title:{ type:String, default:\u0026#34;\u0026#34; //二、 default就是如果没设置子组件的title属性那么默认为空字符串 } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; /* 样式 */ h3{ color:red; } \u0026lt;/style\u0026gt; 主组件：\n\u0026lt;template\u0026gt; \u0026lt;!-- 如何在主组件中加载组件？ --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我的主应用\u0026lt;/h1\u0026gt; \u0026lt;!-- 3.显示组件 --\u0026gt; \u0026lt;!-- \u0026lt;Zujian-vue\u0026gt;\u0026lt;/Zujian-vue\u0026gt; --\u0026gt; \u0026lt;zujian title=\u0026#34;我是父组件使用子组件，定义的标题属性 1+1\u0026#34;\u0026gt;123\u0026lt;/zujian\u0026gt; \u0026lt;!-- 二、prop的传递：title的值传递给子组件 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 1.引入子组件 import Zujian from \u0026#39;./components/zujian.vue\u0026#39;; export default { // 2.挂载组件 components: { Zujian } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; h3{ color:rgb(5, 0, 99); } \u0026lt;/style\u0026gt; 一定记得进入，有package.json在的文件目录中运行，否则报错缺少配置文件。 同样如果删除了package.json需要手动导入依赖，或者重新创建vue项目。 报错：The template root requires exactly one element.eslint-plugin-vue Vue模板需要有且仅有一个根元素 有该报错网页仍然可正常运行 显然这里，在template模板中，有两个元素了。\n解决：加上div包裹起来就行。\n问题：Vue使用组件时，标签内的内容默认不会自动显示在子组件中 在这里表示为，父组件中的子组件标签中的123不会显示出来。\n\u0026lt;zujian title=\u0026#34;我是父组件使用子组件，定义的标题属性 1+1\u0026#34;\u0026gt;123\u0026lt;/zujian\u0026gt; 解决：显式地使用：插槽slot 子组件的模板中使用 \u0026lt;slot\u0026gt;即可\n\u0026lt;template\u0026gt; \u0026lt;!-- 模板 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;单文件组件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{{ title }} \u0026lt;/p\u0026gt; \u0026lt;!-- 二、插值语法展示从父组件传过来的title属性的值 --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Prop类型 Prop传递参数其实是没有类型限制的\nprops: { title: String, likes: Number, isPublished: Boolean, commentIds: Array,//返回工厂模式 author: Object,//返回工厂模式 callback: Function } 数据类型为数组或者对象的时候，默认值是需要返回工厂模式\n因为如果直接使用数组或对象作为默认值，所有组件实例将共享同一个引用，这可能导致意外的副作用 可以看到在prps中自定义的attribute属性有：\ntitile标签是String likes是Number类型 Number 是 JavaScript 中的一种基本数据类型，用于表示数值。表示整数正负数和浮点数。 isPublished: Boolean,布尔类型 评论id是数组类型 作者是Object对象类型 callback是Function函数，用于父子组件之间的交互。 callback:\n类型: Function 用途: 这是一个函数 Prop，通常用于处理事件或与父组件进行交互。例如，在子组件中可能会有一些操作（如删除评论、点赞等），当这些操作发生时，子组件可以调用这个函数来通知父组件执行相应的操作。 工厂模式 工厂模式要求你返回一个函数，该函数每次调用时都会返回一个新的数组或对象实例。\n这样，每个组件实例都有自己的独立数据，避免了共享引用带来的潜在问题。\n示例： props: { title: String, likes: Number, isPublished: Boolean, commentIds: { type: Array, default: () =\u0026gt; [] // 返回一个新的空数组 }, author: { type: Object, default: () =\u0026gt; ({}) // 返回一个新的空对象 }, callback: Function } 解释： default: () =\u0026gt; []：这里使用了一个箭头函数，每次组件实例创建时都会调用这个函数，返回一个新的空数组。 default: () =\u0026gt; ({})：同样，返回一个新的空对象。 确保了每个组件实例都拥有自己独立的 commentIds 和 author 数据，避免了共享引用带来的潜在问题。\n$emit自定义事件组件交互 自定义事件可以在组件中反向传递数据\n我们知道： prop 可以将数据从父组件 传递到子组件\n自定义事件$emit\n作用：发出自定义事件（同时传递参数），让父组件能够响应子组件中的特定操作。\n而响应需要父组件中用@onCustom=\u0026ldquo;getData\u0026quot;进行监听 然后再调用函数执行特定操作。 主要作用： 事件触发: 子组件可以通过 $emit 方法触发事件，向父组件发送通知。例如，用户在子组件中点击按钮后，子组件可以通过 $emit 触发一个事件。 数据传递: $emit 还可以携带参数，使得子组件能够将数据传递给父组件。这对于需要在子组件中处理一些逻辑，然后将结果反馈给父组件的场景非常有用。 增强组件复用性: 使用 $emit 使得子组件更具灵活性和可复用性。父组件可以根据自己的需求来处理子组件发出的事件，而子组件本身不需要知道具体的实现细节。 子组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;单文件组件\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;sendHandle\u0026#34;\u0026gt;发送数据\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;Zujian\u0026#34;, props: { title: { type: String, default: \u0026#34;\u0026#34; } }, methods: { sendHandle() { this.$emit(\u0026#34;onCustom\u0026#34;, \u0026#34;数据\u0026#34;); // 触发自定义事件，并传递数据 } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; h3 { color: red; } \u0026lt;/style\u0026gt; 主组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我的主应用\u0026lt;/h1\u0026gt; \u0026lt;zujian @onCustom=\u0026#34;getData\u0026#34;\u0026gt;\u0026lt;/zujian\u0026gt; \u0026lt;!-- 监听 onCustom 事件 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Zujian from \u0026#39;./components/zujian.vue\u0026#39;; export default { components: { Zujian }, methods: { getData(data) { console.log(data); // 打印接收到的数据 } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; h3 { color: rgb(5, 0, 99); } \u0026lt;/style\u0026gt; 可以看到，子组件中设置点击按钮@click触发sendHandle方法， 然后$emit该方法，发出onCustom的事件，传递数据作为参数。\n在主组件中@onCustom=\u0026ldquo;getData\u0026quot;监听子组件发出的onCustom事件，被触发后getData调用打印传递的数据。\n组件的生命周期 每个组件在被创建时都要经过一系列的初始化过程——例如，需要 设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更 新 DOM 等。\n同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会\n为了方便记忆，我们可以将他们分类\n创建时：beforeCreate、created\n渲染时：beforeMount、mounted\n更新时：beforeUpdate、updated\n卸载时：beforeUnmount、unmounted\n","date":"2024-10-16T23:39:00Z","image":"http://localhost:1313/post/cover/vue-post.jpg","permalink":"http://localhost:1313/post/vue3/","title":"Vue3基础"},{"content":"看完了auto-coder的教程 打算跟着哔哩哔哩视频跟着走一遍流程熟悉基本命令。\n以下是几个让我印象深刻的点： 1.能够让活跃的文件组成组——达到最佳手动效率的编程效果\n2.Autom group 能让prompt和文件组成一起，下次输入prompt能够直接按照这些文件和prompt进行修改\n3.直接使用auto-coder快速理解一个github的项目，非常方便\n‌﻿﻿⁠⁠⁠⁠‍‌⁠‍⁠‬‌‬‬⁠‍⁠‍‍‬‍⁠‍022-🌟当你看到一个github 项目后（auto-coder.chat 最简教程） - 飞书云文档 (feishu.cn)\n4.切换到自然语言模式，ctrl+k，能让命令行变成warp，用自然语言处理问题，而且能检查确认。\n5.对某个文件进行@强调，对某个文件特殊强调@@，对某行代码#注释进行强调修改\n6.自己开发的大模型友好库，提供大模型理解某个lib的项目解释及最简示例，方便大模型理解文档，快速利用大模型进行编程\n7.人类模型模式，手动用大模型然后输出\n‍‬‬﻿‍⁠⁠‬﻿‬‌﻿⁠﻿﻿‌‬﻿‌‬‍﻿⁠‬012- 让你的 terminal 秒变warp 自带自然语言交互buff - 飞书云文档 (feishu.cn)\n其他：语音编程，多模态（图片）的编程，/design\n文档详细，而且视频教程充足\n8.byzer-llm（大模型友好库allwefantasy/llm_friendly_packages (github.com)）\nbyzer-llm：byzer-llm 库是 LLM 友好型库 byzer-llm 的一个示例。该项目包括允许用户快速与大型语言模型交互的功能，并提供内置的混合向量/全文搜索引擎。我们可以使用此库快速开发基于 LLM 的应用程序。\n项目：\n提到的：\n最简RAG 10w文档以下的使用方式✓ ‌⁠⁠⁠﻿‌‬﻿‬‬﻿﻿‌﻿⁠‍‌﻿⁠⁠‍﻿‬⁠‌‬auto-coder.chat： 如何自动化开发基于大模型的应用 - 飞书云文档 (feishu.cn)\n如何自动化开发基于大模型的应用（个人觉得参考即可）\n哔哩哔哩视频翻译的简单demo✓\n实践的时候可以参考 ‍﻿‬﻿﻿‍﻿‍⁠‌‍﻿﻿‌‬‌﻿‬015-编码实践推荐 - 飞书云文档 (feishu.cn)\n","date":"2024-09-21T01:47:30Z","image":"http://localhost:1313/post/cover/plugin_cover.jpg","permalink":"http://localhost:1313/post/auto-coder/","title":"auto-coder首次接触感想"},{"content":"大模型开发总结-提示词 一、RAG技术 大模型RAG基础知识 (poolbee.top)\n二、prompt编写技巧 1.使用特殊符号进行强调、分隔 结构化输出（例如：json格式，数据库语句）\n作流程处理，\n解决日常问题\n例如：需要一个按照周一、周四排人轮次的问题\n常用原则： Few-shot：给出少量示例 COT：思维链 输入：为什么我的视频播放量不高 输出： 问题陈述： 你的视频播放量不高。 ⚫ 首个为什么： 您认为是什么直接原因导致您的视频播放量没有增长？这可能包括内容的吸引力、推\r广策略、目标受众的定义或其它因素。 ⚫ 第二个为什么： 您认为是什么原因导致您的视频内容缺乏吸引力？这可能涉及到内容的主题、创意\r表现方式、视频质量、与观众的互动或者是时效性等方面。 ⚫ 第三个为什么： 您认为是什么原因使您的视频内容缺乏创意？这可能是由于灵感来源的局限性、创\r作过程中的挑战、对目标受众喜好的理解不足，或者是您遵循的内容创作流程可能过于单一和重复。 ⚫ 第四个为什么： 您认为是什么原因导致您未能深刻理解观众的喜好？这可能是因为缺乏对观众数据\r的分析、与观众互动不足、没有定期进行市场调研，或者是您的观众定位不够明确。 ⚫ 第五个为什么： 您认为是什么原因导致您的观众定位不明确？这可能是因为没有充分进行市场调研，\r或者是在内容创作和发布策略中没有明确考虑到特定群体的兴趣、需求和行为特征。也可能是由于缺\r乏对已有观众数据的深入分析，从而无法有效区分和理解不同观众群体。 自洽性（Self-consistency）COT： ​\t利用少样本Cot采样多个不同的推理路径，并使用生成结果选择最一致的答案。多个思维链，多个回答中挑选最优解。\nTOT：思维树 对于需要探索或预判的复杂任务，COT引导模型逐步思考是不足的。 示例：\n# 未使用TOT\r#输入\r我想要为我的牙医同事开发一个大模型应用，但是我不知道要为他做个什么方面的应用，只知道他正在准备助理医师资格证考试、平时工作学习很少用电脑，请你\r给我一些建议。\r#输出\r为你的牙医同事开发一个大模型应用是个好主意！考虑到他准备助理医师资格证考试和少用电脑的情况，以下是一些可能的应用建议：\r医学知识问答助手：\r开发一个能够回答医学相关问题的问答系统。可以利用大模型处理输入的医学问题，并给出详细和准确的答案，帮助他复习和理解考试内容。\r医学术语解释器：\r构建一个应用，可以解释医学术语和专业术语的含义。这可以帮助他更好地理解和记忆医学术语，提高学习效率。\r考试模拟与反馈：\r设计一个模拟考试系统，模拟助理医师资格证考试的题型和难度。系统可以根据他的答题情况给出反馈和建议，帮助他发现和弥补知识的不足。\r医学文献摘要生成器：\r开发一个工具，能够从医学文献中提取关键信息并生成摘要。这可以帮助他快速浏览大量的医学文献，获取必要的信息。\r医学新闻和研究更新：\r创建一个系统，定期从权威医学网站或数据库中获取最新的医学新闻和研究成果，并以易于理解的方式展示给他。这可以帮助他保持对行业动态的了解。\r医学学习笔记整理器：\r设计一个工具，能够帮助他整理和管理学习过程中的笔记和重要知识点。可以支持文本输入或语音输入，并自动整理成结构化的学习资料。\r以上建议可以根据他的具体需求和使用习惯进行调整和扩展，帮助他在准备考试和日常工作学习中更高效地利用大模型技术。 # 使用TOT\r# 输入\r我想要为我的牙医同事开发一个大模型应用，但是我不知道要为他做个什么方面的应用，只知道他正在准备助理医师资格证考试、平时工作学习很少用电脑，请你\r使用TOT框架思考后给我一些建议。 TOT 框架示例如下 --- #输入# 我想为我的妻子购买一束鲜花，但我不确定应该选择哪种鲜花。她喜欢淡雅的颜色和花香。 #输出# 思维步骤1：理解顾客的需求。 ⚫ 顾客想为妻子购买鲜花。 ⚫ 顾客的妻子喜欢淡雅的颜色和花香。 思维步骤2：考虑可能的鲜花选择。 ⚫ 候选1：百合，因为它有淡雅的颜色和花香。 ⚫ 候选2：玫瑰，选择淡粉色或白色，它们通常有花香。 ⚫ 候选3：紫罗兰，它有淡雅的颜色和花香。 ⚫ 候选4：桔梗，它的颜色淡雅但不一定有花香。 ⚫ 候选5：康乃馨，选择淡色系列，它们有淡雅的花香。 思维步骤3：根据顾客的需求筛选最佳选择。 ⚫ 百合和紫罗兰都符合顾客的需求，因为它们都有淡雅的颜色和花香。 ⚫ 淡粉色或白色的玫瑰也是一个不错的选择。 桔梗可能不是最佳选择，因为它可能没有花香。 ⚫ 康乃馨是一个可考虑的选择。 思维步骤4：给出建议。 “考虑到您妻子喜欢淡雅的颜色和花香，我建议您可以选择百合或紫罗兰。淡粉色或白色的玫瑰也是\r13 一个很好的选择。希望这些建议 能帮助您做出决策！”\r# 输出\r输入\r用户想为正在准备助理医师资格证考试的牙医同事开发一个大模型应用，但不确定该应用的具体功能。同事平时工作学习很少使用电脑。\r输出\r思维步骤1：理解需求和限制条件。\r用户的同事正在准备助理医师资格证考试，需要辅助工具来提高学习效率。\r同事平时很少使用电脑，因此应用应尽量简化操作，便于使用。\r思维步骤2：考虑可能的应用功能方向。\r候选1：医学知识库查询助手\r应用提供语音查询功能，方便同事快速获取医学知识或考试重点内容。\r候选2：智能错题本\r帮助同事记录并分析考试中的错题，通过语音输入将错题记录到系统，并生成针对性练习。\r候选3：考试模拟系统\r提供考试模拟题库，包含历年真题和模拟题，并给出详细解析。\r候选4：口腔医学案例分析助手\r集成常见口腔医学案例，帮助同事学习和巩固案例分析能力，支持语音描述病例功能。\r候选5：时间管理和复习计划制定工具\r应用帮助同事制定个性化复习计划，结合语音提醒功能，简化操作。\r思维步骤3：根据需求和限制筛选最佳应用方向。\r医学知识库查询助手和智能错题本适合因其可以通过语音交互简化操作流程，尤其是错题本有助于提高学习效率。\r考试模拟系统和口腔医学案例分析助手也能提供有价值的学习资源，但可能需要更多的电脑操作。\r时间管理和复习计划制定工具可以帮助同事合理安排复习时间，但功能单一。\r思维步骤4：给出建议。\r“考虑到您的同事在准备助理医师资格证考试时很少使用电脑，建议您开发一款医学知识库查询助手或智能错题本应用。这两种应用都可以通过语音交互实现简化操作，帮助您的同事高效备考。” 我想要为我的牙医同事开发一个大模型应用，但是我不知道要为他做个什么方面的应用，只知道他正在准备助理医师资格证考试、平时工作学习很少用电脑，请你 使用TOT框架思考后给我一些建议。\n这个输入中的限制条件为：平时工作学习很少用电脑。后续的思维步骤也是根据这个限制条件进行筛选的。\n让模型一步步思考： xxxxxxxxxxxxxxxxx，请你一步步来，给出每个详细步骤 让模型先思考后与正确答案进行对比，再进行判断。\n提供尽可能详细的信息 角色设定 # 输入\r我想让你做我的职业顾问。我将为你提供一个在职业生涯中寻求指导的人，你的任务是帮助他们根据自己的技能、兴趣和经验，确定自己最适合的职业。你还应该对各种可用的选择进行研究，解释不同行业的就业市场趋势，并就哪些资格证书对从事特定领域有益提出建议。我的第一个请求是“我想给那些想从事软件工程职业的人一些建议”。 三、微调 大模型微调知识实践 (poolbee.top)\n","date":"2024-09-02T03:27:30Z","image":"http://localhost:1313/post/cover/prompt_cover.png","permalink":"http://localhost:1313/post/prompt/","title":"大模型应用开发总结-提示词"},{"content":"大模型微调（指令微调/有监督微调） 1.1简介 模型微调，称为指令微调（Instruction Tuning）或者有监督微调（Supervised Fine-tuning，SFT）：使用成对的输入与预期的输出，训练模型学会以问答的形式解答问题。\n经过微调之后，大模型展现较强的指令遵循能力，后可以通过零样本学习的方式解决多种下游任务。\n指令微调还是扮催化剂的角色，激活模型内在的潜力，而非单纯灌输信息。\n1.1.1预训练对比 指令微调/有监督微调，所需数据显著减少，从十几万到上百万条，均能有效激发模型的通用任务解决能力；甚至有些少量高质量的指令数据，（数千条数万条）也能实现很好的效果。\r降低了对计算资源的依赖，也提升了微调的灵活性与效率。 1.2轻量化微调技术（Lightweight Fine-tuning）参数高效微调 由于大模型的参数量巨大，进行**全量参数微调**需要消耗非常多的算力，为了解决这一问题，提出：\r**参数高效微调**（**P**arameter-efficient **F**ine-tuning）/轻量化微调（**L**ightweight **F**ine-tuning）：通过训来拿极少的模型参数，也能保证微调后的模型表现可以与全量微调普美。\r常用的轻量化微调技术：LoRA、Adapter和Prompt Tuning 1.3LoRA技术（不是LoRa LoRA（Low-Rank Adaptation）一种降低语言模型微调参数数量的技术\n翻译是”低秩适配“的意思\n通过低秩矩阵分解，在原始矩阵的基础上增加一个旁路矩阵，然后只更新旁路矩阵的参数。\nLoRA paper第一页\n实例： 使用简历命名实体识别的数据集，进行微调，进而开发一个AI简历助手，后能批量地自动识别并提取简历中的关键信息（姓名、教育背景、工作经历等）提升效率。\r具体来说，输入一个摘录自某简历的句子，模型需要识别出所有的命名实体。实体的类别包括：姓名(NAME)国籍(CONT)、种族(RACE)、职位(TITLE)、教育背景(EDU)、专业(PRO)、组织名(ORG)、地名(LOC)。原始的数据来自于BAAI/COIG-PC-Lite · Datasets at HF Mirror (hf-mirror.com)\ntorch、transformer、streamlit安装\n下载模型\n数据处理pandas进行数据读取，转为Dataset格式\n[\u0026lsquo;input\u0026rsquo;:[\u0026rsquo;#任务描述\\n假设你是一个AI简历助手，能从简历中识别出所有的命名实体，并以json格式返回结果。\\n\\n#任务要求1n实体的类别包括：姓名、国籍、种族、职位、教育背景、专业、组织名、地名。1n返回的jso格式是一个字典，其中每个键 是实体的类别，值是一个列表，包含实体的文本。\\n\\n#样例小n输入：\\n张三，男，中国籍，工程师1n输出：1n(\u0026ldquo;姓名\u0026rdquo;：[\u0026ldquo;张三\u0026rdquo;]，\u0026ldquo;国籍\u0026rdquo;：[\u0026ldquo;中国\u0026rdquo;]，\u0026ldquo;职位\u0026rdquo;：[\u0026ldquo;工程师\u0026rdquo;]}八n\\n#当前简历\\n高勇：男，中国国籍，无境外居留权，\\n\\n#任务重述\\n请 参考样例，按照任务要求，识别出当前简历中所有的命名实体，并以jso格式返回结果。·]，\u0026lsquo;output\u0026rsquo;:[\u0026rsquo;{\u0026ldquo;姓名\u0026rdquo;：[\u0026ldquo;高勇\u0026rdquo;]，\u0026ldquo;国籍\u0026rdquo;：[\u0026ldquo;中国国籍\u0026rdquo;]}\u0026rsquo;]}\n加载tokenizer\n定义数据处理函数\ndef process_func (example): MAX_LENGTH = 384 #Llama分词器会将中文字切分为多个token因此需要放开一些最大长度，保证数据的完整性。 instruction = tokenizer (f \u0026#34;{example [\u0026#39;input\u0026#39;]} \u0026lt; sep \u0026gt;\u0026#34;) Response = tokenizer (f \u0026#34;{example [\u0026#39;output\u0026#39;]} \u0026lt; eod \u0026gt;\u0026#34;) input_ids = instruction [\u0026#34;input_ids\u0026#34;] + response [\u0026#34;input_ids\u0026#34;] attention_mask = [1] * len (input_ids) Labels = [-100] * len (instruction [\u0026#34;input_ids\u0026#34;]) + response [\u0026#34;input_ids\u0026#34;] #instruction 不计算loss if len (input_ids) \u0026gt; MAX_LENGTH: # 做一个截断 input_ids = input_ids [: MAX_LENGTH] attention_mask = attention_mask [: MAX_LENGTH] Labels = labels [: MAX_LENGTH] return { \u0026#34;input_ids\u0026#34;: input_ids, \u0026#34;attention_mask\u0026#34;: attention_mask, \u0026#34;Labels\u0026#34;: labels } 需要使用tokenizer讲文本转为id，同时讲input和output凭借，组成input_ids和attention_mask\n源大模型需要在input后面添加一个特殊的token在output后面添加一个特殊的token，同时为了防止数据超长进行了一个阶段处理。\n然后使用map函数对整个数据集进行预处理。\n处理完毕后，使用tokenizer的decode函数，将id转回文本，进行最后的检查：\n2.4模型训练 加载大模型参数，然后打印模型结构\nYuan大模型中包含24层YuanDecoderLayer每层包含self_attn、mpl和layernorm。\n为了进行模型使用训练，需要先执行，model.enable_input_require_grads()\n最后打印模型的数据类型，可以看到是torch.bfloat16\n使用lora进行轻量化微调 配置LoraConfig\n构建一个PeftModel\n通过mdoel.print_trainable_parameters()可以看到需要训练的参数在所有参数中的占比\n然后，设置训练参数TrainingArguments\n同时初始化一个Trainer:\n最后允许trainer.train()j执行模型训练。\n训练过程中会打印模型训的loss，我们可以通过loss降低的情况，检查模型是否收敛。\n训练完成后，会打印训练相关的信息：\n同时，会看到output文件夹中出现了3个文件夹，每个文件夹下保存这每个epoch训练玩的模型\n以epoch3为例，可以看到其中保存了训练的config，state，ckpt等信息\n2.5效果验证 通过生成函数generate()进行效果验证\n同时定义好输入的prompt template中要和训练保持一致。\n最后进行输入样例进行测试\n可以看到经过模型微调，模型已经具备了相应的能力。\n占用17G显存，显存占用的多少和需要训练的模型参数，batch size等相关，可以尝试不同的训练配置。\n尝试使用训练的模型 重启内核，可以看到显存已被清空。然后streamlit启动项目即可。\n3.1任务挑选和训练集构建 原则：任务是否必须微调，单纯通过prompt或者RAG能否解决\n任务来源：\n已有的任务：传统的NLP任务，分类，NER等-\u0026gt;直接服用开源训练集 新任务：构建应用过程中依赖的能力-\u0026gt;有无开源训练集可以服用？没有如何收集数据？ 训练集预处理，收集好的数据需要哪些预处理步骤？数据清洗？去重？\n3.2微调实战 效果测试：测试集如何来，轻量化微调效果能否达到需求？ 效果调优：没有达到的原因有那些？数据不够？参数设置不对？需要全量微调？模型太小? 3.3数据集推荐 Huggingface dataset: https://hf-mirror.com/datasets\n魔搭： https://modelscope.cn/datasets\nopenDataLab 数据集: https://opendatalab.org.cn/\n和鲸社区 数据集: https://www.heywhale.com/home/dataset\ngit clone https://www.modelscope.cn/datasets/Datawhale/AICamp_yuan_baseline.git\n","date":"2024-09-01T22:27:30Z","image":"http://localhost:1313/post/cover/datawhale-cover.png","permalink":"http://localhost:1313/post/fine-tuning/","title":"大模型微调知识实践"},{"content":"什么是RAG 知识局限性：大模型的知识来源于训练数据，而这些数据主要来自于互联网上已经公开的资源，对于一些实时性的或者非公开的，由于大模型没有获取到相关数据，这部分知识也就无法被掌握。\n数据安全性：为了使得大模型能够具备相应的知识，就需要将数据纳入到训练集进行训练。然而，对于企业来说，数据的安全性至关重要，任何形式的数据泄露都可能对企业构成致命的威胁。\n大模型幻觉：由于大模型是基于概率统计进行构建的，其输出本质上是一系列数值运算。因此，有时会出现模型“一本正经地胡说八道”的情况，尤其是在大模型不具备的知识或不擅长的场景中。\n检索增强生成（Retrieval Augmented Generation, RAG），引入外部知识，使大模型能够生成准确且符合上下文的答案，同时能够减少模型幻觉的出现。\n1概览：一个完整的RAG链路 从上图可以看到，大模型接收到用户query后，RAG会先进行检索。\n检索(Retrieval)：检索 Chunks 和 query 一并输入到大模型，进而回答用户的问题。\nChunks：query和离线文档经过parser和splitter（orc）向量化（或称索引）——\u0026gt;到Datebase然后和query一起进行Retrieval——\u0026gt;检索到相关的Chunks\n第二次Retrieval——\u0026gt;输入query和相关的Chunks然后得到reanked的Chunks输入到LLM后得到Answer\nquery：在第一次Retrieval和第二次Retrieval的时候输入\n为了完成检索，需要离线将文档（ppt、word、pdf等）经过解析、切割甚至OCR转写，然后进行向量化存入数据库中。 接下来，我们将分别介绍离线计算和在线计算流程。\n1.1离线计算流程 文件（pdf、word、ppt等，这些 文档documents）——解析parser——\u0026gt;切割为较短的Chunk——清洗和去重。\n知识库中知识的数量和质量决定了RAG的效果，因此这是非常关键且必不可少的环节。 向量化（Vectorization）：Chunk转化为向量或者 索引（Indexing）。 具体是构建**向量模型（Embedding Model）**作用是将一段 Chunk 转成 向量（Embedding）\n一个好的向量模型，会使得具有相同语义的文本的向量表示在语义空间中的距离会比较近，而语义不同的文本在语义空间中的距离会比较远。 由于知识库中的所有 Chunk 都需要进行 向量化，这会使得计算量非常大，因此这一过程通常是离线完成的。\n随着新知识的不断存储，向量的数量也会不断增加。这就需要将这些向量存储到 数据库 （DataBase）中进行管理，例如 Milvus 中。\n离线计算总结： 离线计算就是在文档在parse\u0026amp;splitter后将得到的Chunk进行向量化（Vectorization）或称 索引（Indexing），随着向量的数量不断增加会将向量存储到Milvus等数据库中。\n因为Chunk进行向量化的时候会使得计算量非常大，通常是离线进行的。\n1.2在线计算 **检索（Retrieval）：**RAG系统使用时候，给定一条用户 查询（Query），从知识库中找到所需的知识的操作。 具体过程：Query会经过向量模型（Embedding Model）【是的也就是向量化】得到相应向量，然后与数据库中所有的Chunk的向量计算相似度*，得到最相近的一系列Chunk。\n但 数据库 非常大的时候，向量相似度的计算过程需要一定的时间。\n这时可以在索引之前那召回（Recall）：从 数据库 中快速获得大量大概率相关的 Chunk，**然后只有这些 Chunk 会参与计算向量相似度。**使得计算的复杂度就从整个知识库降到了非常低。\n召回（Recall）： 召回（Recall）：通常采用简单的基于字符串的匹配算法，常用的算法有 TF-IDF，BM25 。【由于这些算法不需要任何模型，速度会非常快】\n也有还是致力于实现更快的 向量检索的 ，例如 faiss，annoy **总结：**在查询（Query）前增加了召回（recall），即从数据库中快速获得大量大概率相关的Chunk，用这些大概率相关的Chunk进行计算向量相似度。达到降低计算复杂度的效果。\n思维导图：向量化——query所有向量进行计算向量相似度，得到Chunk\n而是在此之前增加recall进行大概率相关的Chunk计算向量相似度。\n但人们发现，随着知识库的增大，除了检索的速度变慢外，检索的效果也会出现退化，如下图中绿线所示：\n这是由于向量模型 （Embedding Model）能力有限。\n知识库增大，超过了向量模型的容量，这种情况下相似度最高的结果可能不是最优的，因此准确度就下降了。\n为解决随着知识库的增大，除了检索的速度变慢外，检索的效果也会出现退化的问题，\n研究者提出增加一个二阶段检索——\n重排 (Rerank)： 即利用 重排模型（Reranker），使得越相似的结果排名更靠前。\n这样就能实现准确率稳定增长，即数据越多，效果越好（如上图中紫线所示）。\n一阶段检索有时也被称为 精排 。而在一些更复杂的系统中，在 召回 和 精排 之间还会添加一个 粗排 步骤。\n综上所述，在整个 检索 过程中，计算量的顺序是 召回 \u0026gt; 精排 \u0026gt; 重排，而检索效果的顺序则是 召回 \u0026lt; 精排 \u0026lt; 重排 。\n当这一复杂的 检索 过程完成后，我们就会得到排好序的一系列 检索文档（Retrieval Documents）。\n然后我们会从其中挑选最相似的 k 个结果，将它们和用户查询拼接成prompt的形式，输入到大模型。\n最后，大型模型就能够依据所提供的知识来生成回复，从而更有效地解答用户的问题。\n在线计算总结： 一阶段检索（精排）（召回recall）：在查询（Query）前增加了召回（recall），即从数据库中快速获得大量大概率相关的Chunk，用这些大概率相关的Chunk进行计算向量相似度。达到降低计算复杂度的效果。\n复杂的系统中有时候会在召回recall与精排添加一个粗排的步骤\n**二阶段检索（重排）（重排模型Reanker）：**为解决随着知识库的增大，除了检索的速度变慢外，检索的效果也会出现退化的问题。【本质向量模型容量问题】。重排模型（Reanker）使得越相似的结果排名更靠前，实现准确率稳定增长，即数据越多，效果越好。\n最终得到的是排好序的一系列 检索文档（Retrieval Documents）。\n检索（Retrieval）就是以上的一个过程。\n2开源RAG框架** 目前，开源社区中已经涌现出了众多RAG框架，例如：\nTinyRAG：DataWhale成员宋志学精心打造的纯手工搭建RAG框架。 LlamaIndex：一个用于构建大语言模型应用程序的数据框架，包括数据摄取、数据索引和查询引擎等功能。 LangChain：一个专为开发大语言模型应用程序而设计的框架，提供了构建所需的模块和工具。 QAnything：网易有道开发的本地知识库问答系统，支持任意格式文件或数据库。 RAGFlow：InfiniFlow开发的基于深度文档理解的RAG引擎。 ··· 再理解RAG的链路图： 1.离线计算就是说的图片下方，文档经过patser\u0026amp;Splitter后得到Chunk然后进行向量化Vectorization，然后再存储到DataBase中。\n向量化就是利用向量模型Embedding Model将Chunk转化为向量，得到各个文本在语义空间的相似度。 2.在线计算就是图片上方，用户的查询Query经过大模型理解，经过1st检索（Retrival）及经过2st 检索（Retrival）最终得到检索文档（Retrieval Documents）与查询Query拼接成prompt的形式，输入到大模型中，大模型根据所提供的知识回答问题。\n​\t具体来说：1st Retrival中为了解决Query向量化后 与 向量数据库中所有的Chunk的计算向量相似度的问题，提出在Query进大模型之前进行召回recall，降低了计算复杂度。_有些会在召回和精排（1st Retrival）之间增加粗排。\n召回（Recall）：从 数据库 中快速获得大量大概率相关的 Chunk**，**然后只有这些 Chunk 会参与计算向量相似度。**使得计算的复杂度就从整个知识库降到了非常低。_也有直接更快速搜索的方案faiss，annoy。 但知识库的增大，除了检索的速度变慢外，检索的效果也会出现退化，为解决这个问题：_本质是向量模型容量问题\n​\t提出2st Retrival中增加重排(Reank)，使得向量相似度越相似的结果排名更靠前，实现准确率稳定增长。\n","date":"2024-08-13T19:14:39Z","image":"http://localhost:1313/post/cover/tag-opencv.jpg","permalink":"http://localhost:1313/post/rag/","title":"大模型RAG基础知识"},{"content":"Datawhale AI夏令营第四期大模型应用开发-Task01 首先了解一些背景知识。\n一、什么是大模型 语言模型发展历史 语言模型：为了对人类语言的内在规律进行建模，研究者们提出使用语言模型（language model）来准确预测词序列中 下一个词 或者 缺失的词 的概率。\n统计语言模型：使用马儿可夫假设，假设当前词与之前的词产生联系。\n中文中，建立n元语言模型，n元作为最小的语义单元进行建模\n神经语言模型\n上下文 统计语言模型（Statistical Language Model, SLM）：使用马尔可夫假设（Markov Assumption）来建模语言序列的 𝑛 元（𝑛-gram）语言模型\n神经语言模型（Neural Language Model, NLM）：基于神经网络构建语言模型，如循环神经网络（Recurrent Neural Networks, RNN），并学习上下文相关的词表示（即分布式词向量），也被称为词嵌入（Word Embedding）。代表性工作：word2vec\n预训练语言模型（Pre-trained Language Model, PLM）：使用大量的无标注数据预训练双向 LSTM（Bidirectional LSTM, biLSTM）或者Transformer，然后在下游任务上进行微调（Fine-Tuning）。代表性工作：ELMo、BERT、GPT-1/2\n双向lstm是在RNN基础上进行改进的模型 Transformer，使用多层自注意力结构的模型 无标注数据：数据没有任何人标注，数据自监督的方式进行学习- 形成了预训练微调的范式 大语言模型（Large Language Model, LLM）：基于“扩展法则”（Scaling Law），即通过增加模型参数或训练数据，可以提升下游任务的性能，同时具有小模型不具有的“涌现能力”（Emergent Abilities）。代表性工作：GPT-3、ChatGPT、Claude、Llama\n二、大模型是怎么构建的（三个阶段） 大模型的构建过程可以分为预训练（Pretraining）、有监督微调（Supervised Fine-tuning, SFT）、基于人类反馈的强化学习对齐（Reinforcement Learning from Human Feedback, RLHF）三个阶段。\n1.预训练（Pretraining） 使用海量的数据进行模型参数的初始学习，旨在为模型参数寻找到一个优质的“起点”。 (1)预训练技术的发展 ​\t这一概念最初在计算机视觉领域萌芽，通过在ImageNet（一个大型图像数据集）上的训练，为模型参数奠定了坚实的基础。\n​\t后来在自然语言处理（NLP）领域使用，word2vec开创先河，利用未标注文本构建词嵌入模型；ELMo、BERT及GPT-1则进一步推动了**“预训练-微调”范式**的普及。\n​\t起初，只用于解决特定类别的下游任务；例如文本分类、序列标注、序列到序列生成等传统NLP任务。\n​\t之后，GPT-2——通过大规模文本数据预训练：打造能够应对广泛任务的通用解决方案，并在GPT-3中将这一理念扩展至前所未有的超大规模。\n在BERT等早期预训练模型中，模型架构和训练任务呈现出多样化特征。然而，随着GPT系列模型的兴起，“解码器架构+预测下一个词”的策略证明了其卓越效能，成为了当前主流的大模型技术路线。 (2)预训练的过程 搜集和清洗文本数据 ​\t首要任务是搜集和清洗海量的文本数据，确保剔除潜在的有害内容。获取高质、多元的数据集，并对其进行严谨的预处理。\n​\t鉴于模型的知识库几乎完全源自训练数据，数据的质量与多样性对模型性能至关重要。这是打造高性能语言模型的关键步骤。\n​\t当前，多数开源模型的预训练均基于数T的token。\n大模型 token 计算资源需求 Llama-1 1T 2,048块A100 80GB GPU三周 Llama-2 2T Llama-3 15T ​\t除了对数据量的苛刻要求，预训练阶段对计算资源的需求也极为庞大。以Llama-1的65B参数模型为例，其在2,048块A100 80GB GPU集群上进行了接近三周的训练。\n训练及细节 此外，预训练过程中还涉及诸多细节，诸如数据配比、学习率调度、模型行为监测等，这些往往缺乏公开的最佳实践指导，需要研发团队具备深厚的训练经验与故障排查能力，以规避训练过程中的回溯与重复迭代，节约计算资源，提高训练效率。 ​\t总体而言，预训练不仅是一项技术挑战，更是一场对数据质量、算力投入与研发智慧的综合考验。\n2.有监督微调（Supervised Fine-tuning, SFT）或**指令微调(instruction tuning) 预训练模型能力限制 大规模预训练后，模型已经具备较强的模型能力，能够编码丰富的世界知识，但是由于预训练任务形式所限，\n这些模型更擅长于文本补全，并不适合直接解决具体的任务。\n尽管引入了诸如上下文学习（In-Context Learning, ICL）等提示学习策略以增强模型的适应性，但模型本身在下游任务解决上的能力仍受限。为了克服这一局限，预训练后的大型语言模型往往需经历微调过程，以提升其在特定任务中的表现。\n目前来说，比较广泛使用的微调技术是“有监督微调”（也叫做指令微调，Instruction Tuning）：该方法利用成对的任务输入与预期输出数据，训练模型学会以问答的形式解答问题，从而解锁其任务解决潜能。\n经过指令微调后，大语言模型能够展现出较强的指令遵循能力，可以通过零样本学习的方式解决多种下游任务。\n指令微调更多地扮演着催化剂的角色，激活模型内在的潜在能力，而非单纯地灌输信息。**\nSFT的优点 相较于预训练所需的海量数据，指令微调所需数据量显著减少，从几十万到上百万条不等的数据，均可有效激发模型的通用任务解决能力，甚至有研究表明，少量高质量的指令数据（数千至数万条）亦能实现令人满意的微调效果。这不仅降低了对计算资源的依赖，也提升了微调的灵活性与效率。\n3.基于人类反馈的强化学习对齐 除了提升任务的解决能力外，大语言模型与**人类期望、需求及价值观的对齐（Alignment）**至关重要，这对于大模型的应用具有重要的意义。\nInstructGPT论文提出 InstructGPT论文解读 - 知乎 (zhihu.com)OpenAI在 2022 年初发布\n​\t详尽阐述了如何实现语言模型与人类对齐。论文提出了基于人类反馈的强化学习对齐（Reinforcement Learning from Human Feedback, RLHF），通过指令微调后的强化学习，提升模型的人类对齐度。RLHF的核心在于构建一个反映人类价值观的奖励模型（Reward Model）。这一模型的训练依赖于专家对模型多种输出的偏好排序，通过偏好数据训练出的奖励模型能够有效评判模型输出的质量。\n其他简化方法 ​\t目前还有很多工作试图去除复杂的强化学习算法，或其他使用 SFT 方式来达到与 RLHF 相似的效果，从而简化模型的对齐过程。\n直接偏好优化（Direct Preference Optimization, DPO），它通过与有监督微调相似的复杂度实现模型与人类对齐，是一种典型的不需要强化学习的对齐算法。相比RLHF，DPO不再需要在训练过程中针对大模型进行采样，同时超参数的选择更加容易。 最后，我们以开源大模型Llama-2-Chat为例，简要介绍一下其训练过程。\n​\t整个过程起始于利用公开数据进行预训练，获得Llama-2。在此之后，通过有监督微调创建了Llama-2-Chat的初始版本。随后，使用基于人类反馈的强化学习（RLHF）方法来迭代地改进模型，具体包括拒绝采样（Rejection Sampling）和近端策略优化（Proximal Policy Optimization, PPO）。在RLHF阶段，人类偏好数据也在并行迭代，以保持奖励模型的更新。\n三、开源大模型和闭源大模型 ​\t根据上面的学习，我们不难发现，构建大模型不仅需要海量的数据，更依赖于强大的计算能力，以确保模型能够快速迭代和优化，从而达到预期的性能水平。鉴于此，全球范围内能够独立承担起如此庞大计算成本的机构屈指可数。这些机构可以分为以下两大阵营：\n一是选择将模型开源的组织，他们秉持着促进学术交流和技术创新的理念，让全球的研究者和开发者都能受益于这些模型。通过开放模型的代码和数据集，他们加速了整个AI社区的发展，促进了创新和技术的民主化。这一阵营的代表有Meta AI、浪潮信息等。\n另一类则是保持模型闭源的公司，它们通常将模型作为核心竞争力，用于提供专有服务或产品，以维持商业优势。闭源模型通常伴随着专有技术和服务，企业可以通过API等方式提供给客户使用，而不直接公开模型的细节或代码。这种模式有助于保障公司的商业利益，同时也为用户提供了稳定和安全的服务。这一阵营的代表有OpenAI、百度等。\n无论是开源还是闭源，这些大模型都在推动人工智能领域向前发展，对于推动大语言模型技术的渐进式发展起到了至关重要的作用。\n接下来，我们以浪潮信息为例，简要介绍下浪潮信息源大模型开源体系。\n四、源大模型开源体系(浪潮信息) 截止到目前，浪潮信息已经发布了三个大模型：源1.0 ，源2.0 和 源2.0-M32，其中 源1.0 开放了模型API、高质量中文数据集和代码，源2.0 和 源2.0-M32 采用全面开源策略，全系列模型参数和代码均可免费下载使用。\n2021年9月，源1.0大模型发布，它采用76层的Transformer Decoder结构，使用5T数据训练，拥有2457亿参数量，超越OpenAI研发的GPT-3，成为全球最大规模的AI巨量模型，表现出了出色的中文理解与创作能力。\n项目链接: https://github.com/Shawn-IEITSystems/Yuan-1.0 官方报道: https://mp.weixin.qq.com/s/6CH0I4eOLzj3YDZyIxdeEQ 论文链接: https://arxiv.org/abs/2110.04725 2023年11月，源2.0大模型发布，它使用10T数据训练，包括1026亿、518亿、21亿 三款参数规模，在数理逻辑、代码生成等方面表现出色。\n在算法方面，与传统Attention对输入的所有文字一视同仁不同，\n局部注意力过滤增强机制（Localized Filtering-based Attention, LFA） 源2.0提出，它假设自然语言相邻词之间有更强的语义关联，因此针对局部依赖进行了建模，最后使得模型精度提高3.53%。\n项目链接: https://github.com/IEIT-Yuan/Yuan-2.0 官方报道: https://mp.weixin.qq.com/s/rjnsUS83TT7aEN3r2i0IPQ 论文链接: https://arxiv.org/abs/2311.15786 2024年5月，源2.0-M32发布，它是一个混合专家（Mixture of Experts, MoE）大模型，使用2000B Tokens训练，包含400亿参数，37亿激活参数\n源2.0-M32 包含32个专家，基于LFA+Attention Router的MoE模型结构。\n源2.0-M32 在数理逻辑、代码生成、知识等方面精度对标Llama3-70B，推理算力降至1/19。\n项目链接: https://github.com/IEIT-Yuan/Yuan2.0-M32 官方报道: https://mp.weixin.qq.com/s/WEVyYq9BkTTlO6EAfiCf6w 论文链接: https://arxiv.org/abs/2405.17976 本次学习，我们将以 源2.0-2B 模型为例，带领大家一起体验源大模型，欢迎大家来给项目点点 star 哦！\n五、大模型时代挖掘模型能力的开发范式 ​\t进入大模型时代，人工智能领域的边界正以前所未有的速度扩展，而如何充分挖掘大模型的内在潜能，成为了应用开发者面前的一道关键课题。\n​\t在这一背景下，不同的应用场景催生了多样化的应用开发策略，这些策略不仅展现了大模型应用开发的丰富可能性，也预示着未来AI技术在各行业落地的广阔前景。\n有手就行的Prompt工程 Prompt工程（Prompt Engineering）是指通过精心构造提示（Prompt），直接调教大模型，解决实际问题。\n为了更充分地挖掘大模型的潜能，出现了以下两种技术：\nLCT和CoT 上下文学习（In-Context Learning, ICL）：将任务说明及示例融入提示文本之中，利用模型自身的归纳能力，无需额外训练即可完成新任务的学习。 思维链提示（Chain-of-Thought, CoT）：引入连贯的逻辑推理链条至提示信息内，显著增强了模型处理复杂问题时的解析深度与广度。 Embedding辅助给LLM外接大脑大模型基础：Embedding - 知乎 (zhihu.com) ​\t尽管大模型具有非常出色的能力，然而在实际应用场景中，仍然会出现大模型无法满足我们需求的情况，主要有以下几方面原因：\n知识局限性：大模型的知识来源于训练数据，而这些数据主要来自于互联网上已经公开的资源，对于一些实时性的或者非公开的，由于大模型没有获取到相关数据，这部分知识也就无法被掌握。 数据安全性：为了使得大模型能够具备相应的知识，就需要将数据纳入到训练集进行训练。然而，对于企业来说，数据的安全性至关重要，任何形式的数据泄露都可能对企业构成致命的威胁。 大模型幻觉：由于大模型是基于概率统计进行构建的，其输出本质上是一系列数值运算。因此，有时会出现模型“一本正经地胡说八道”的情况，尤其是在大模型不具备的知识或不擅长的场景中。 因此，将知识提前转成Embedding向量，存入知识库，然后通过检索将知识作为背景信息，这样就相当于给LLM外接大脑，使大模型能够运用这些外部知识，生成准确且符合上下文的答案，同时能够减少模型幻觉的出现。\n参数高效微调Parameter-efficient Fine-tuning，轻量化微调Lightweight Fine-tuning 在实际应用场景中，大模型还会经常出现以下问题：\n大模型在当前任务上能力不佳，如果提升其能力？ 另外，怎么使大模型学习其本身不具备的能力呢？ 这些问题的答案是模型微调。\n模型微调也被称为指令微调（Instruction Tuning）或者有监督微调（Supervised Fine-tuning, SFT），首先需要构建指令训练数据，然后通过有监督的方式对大模型的参数进行微调。经过模型微调后，大模型能够更好地遵循和执行人类指令，进而完成下游任务。\n然而，由于大模型的参数量巨大， 进行全量参数微调需要消耗非常多的算力。为了解决这一问题，研究者提出了参数高效微调（Parameter-efficient Fine-tuning），也称为轻量化微调 （Lightweight Fine-tuning），这些方法通过训练极少的模型参数，同时保证微调后的模型表现可以与全量微调相媲美。\n六、大模型应用开发 必知必会 通常，一个完整的大模型应用包含一个客户端和一个服务端。\n客户端接收到用户请求后，将请求输入到服务端，服务端经过计算得到输出后，返回给客户端回复用户的请求。\n客户端 在大模型应用中，客户端需要接受用户请求，并且能将回复返回给用户。\n目前，客户端通常使用 Gradio 和 Streamlit 进行开发。\nGradio 基本概念 https://datawhaler.feishu.cn/sync/C8BfdAPevsOWctbpowocZYOGnmb\nStreamlit 基础概念 https://datawhaler.feishu.cn/sync/AylRdptJis6baEbW2f9cW17snVh\n服务端 在大模型应用中，服务端需要与大模型进行交互，大模型接受到用户请求后，经过复杂的计算，得到模型输出。\n目前，服务端主要有以下两种方式：\n直接调用大模型API 直接调用大模型API：将请求直接发送给相应的服务商，如openai，讯飞星火等，等待API返回大模型回复\n✔️ 优点：\n便捷性： 不需要关心模型的维护和更新，服务商通常会负责这些工作。 资源效率： 避免了本地硬件投资和维护成本，按需付费，灵活调整成本支出。 稳定性与安全性： 专业团队管理，可能提供更好的系统稳定性和数据安全性措施。 扩展性： API服务易于集成到现有的应用和服务中，支持高并发请求。 ✖️ 缺点：\n网络延迟： 需要稳定的网络连接，可能会受到网络延迟的影响。 数据隐私： 数据需要传输到服务商的服务器，可能涉及数据安全和隐私问题。 成本控制： 高频次或大量数据的调用可能会导致较高的费用。 依赖性： 受制于服务商的政策变化，如价格调整、服务条款变更等。 **大模型本地部署 大模型本地部署**：在本地GPU或者CPU上，下载模型文件，并基于推理框架进行部署大模型**\n✔️ 优点：\n数据主权： 数据完全在本地处理，对于敏感数据处理更为安全。 性能可控： 可以根据需求优化配置，减少网络延迟，提高响应速度。 成本固定： 初始投入后，长期运行成本相对固定，避免了按使用量付费的不确定性。 定制化： 更容易针对特定需求进行模型微调或扩展。 ✖️ 缺点：\n硬件投资： 需要强大的计算资源，如高性能GPU，初期投资成本较高。 运维复杂： 需要自行管理模型的更新、维护和故障排查。 技术门槛： 对于非专业团队而言，模型的部署和优化可能较为复杂。 资源利用率： 在低负载情况下，本地硬件资源可能无法充分利用。 综上，选择哪种方式取决于具体的应用场景、数据敏感性、预算以及对延迟和性能的需求。\n来精读一下baseline 完整baseline代码 # 导入所需的库 from transformers import AutoTokenizer, AutoModelForCausalLM import torch import streamlit as st # 创建一个标题和一个副标题 st.title(\u0026#34;💬 Yuan2.0 智能编程助手\u0026#34;) # 源大模型下载 from modelscope import snapshot_download model_dir = snapshot_download(\u0026#39;IEITYuan/Yuan2-2B-Mars-hf\u0026#39;, cache_dir=\u0026#39;./\u0026#39;) # model_dir = snapshot_download(\u0026#39;IEITYuan/Yuan2-2B-July-hf\u0026#39;, cache_dir=\u0026#39;./\u0026#39;) # 定义模型路径 path = \u0026#39;./IEITYuan/Yuan2-2B-Mars-hf\u0026#39; # path = \u0026#39;./IEITYuan/Yuan2-2B-July-hf\u0026#39; # 定义模型数据类型 torch_dtype = torch.bfloat16 # A10 # torch_dtype = torch.float16 # P100 # 定义一个函数，用于获取模型和tokenizer @st.cache_resource def get_model(): print(\u0026#34;Creat tokenizer...\u0026#34;) tokenizer = AutoTokenizer.from_pretrained(path, add_eos_token=False, add_bos_token=False, eos_token=\u0026#39;\u0026lt;eod\u0026gt;\u0026#39;) tokenizer.add_tokens([\u0026#39;\u0026lt;sep\u0026gt;\u0026#39;, \u0026#39;\u0026lt;pad\u0026gt;\u0026#39;, \u0026#39;\u0026lt;mask\u0026gt;\u0026#39;, \u0026#39;\u0026lt;predict\u0026gt;\u0026#39;, \u0026#39;\u0026lt;FIM_SUFFIX\u0026gt;\u0026#39;, \u0026#39;\u0026lt;FIM_PREFIX\u0026gt;\u0026#39;, \u0026#39;\u0026lt;FIM_MIDDLE\u0026gt;\u0026#39;,\u0026#39;\u0026lt;commit_before\u0026gt;\u0026#39;,\u0026#39;\u0026lt;commit_msg\u0026gt;\u0026#39;,\u0026#39;\u0026lt;commit_after\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_start\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_text\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_code\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_output\u0026gt;\u0026#39;,\u0026#39;\u0026lt;empty_output\u0026gt;\u0026#39;], special_tokens=True) print(\u0026#34;Creat model...\u0026#34;) model = AutoModelForCausalLM.from_pretrained(path, torch_dtype=torch_dtype, trust_remote_code=True).cuda() print(\u0026#34;Done.\u0026#34;) return tokenizer, model # 加载model和tokenizer tokenizer, model = get_model() # 初次运行时，session_state中没有\u0026#34;messages\u0026#34;，需要创建一个空列表 if \u0026#34;messages\u0026#34; not in st.session_state: st.session_state[\u0026#34;messages\u0026#34;] = [] # 每次对话时，都需要遍历session_state中的所有消息，并显示在聊天界面上 for msg in st.session_state.messages: st.chat_message(msg[\u0026#34;role\u0026#34;]).write(msg[\u0026#34;content\u0026#34;]) # 如果用户在聊天输入框中输入了内容，则执行以下操作 if prompt := st.chat_input(): # 将用户的输入添加到session_state中的messages列表中 st.session_state.messages.append({\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt}) # 在聊天界面上显示用户的输入 st.chat_message(\u0026#34;user\u0026#34;).write(prompt) # 调用模型 prompt = \u0026#34;\u0026lt;n\u0026gt;\u0026#34;.join(msg[\u0026#34;content\u0026#34;] for msg in st.session_state.messages) + \u0026#34;\u0026lt;sep\u0026gt;\u0026#34; # 拼接对话历史 inputs = tokenizer(prompt, return_tensors=\u0026#34;pt\u0026#34;)[\u0026#34;input_ids\u0026#34;].cuda() outputs = model.generate(inputs, do_sample=False, max_length=1024) # 设置解码方式和最大生成长度 output = tokenizer.decode(outputs[0]) response = output.split(\u0026#34;\u0026lt;sep\u0026gt;\u0026#34;)[-1].replace(\u0026#34;\u0026lt;eod\u0026gt;\u0026#34;, \u0026#39;\u0026#39;) # 将模型的输出添加到session_state中的messages列表中 st.session_state.messages.append({\u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: response}) # 在聊天界面上显示模型的输出 st.chat_message(\u0026#34;assistant\u0026#34;).write(response) baseline方案设计 2.1 概要设计 baseline基于源大模型的编程能力来解决用户的问题，主要包含一个Streamlit开发的客户端，以及一个部署好浪潮源大模型的服务端。客户端接收到用户请求后，首先进行交互历史拼接，然后输入到服务端的浪潮源大模型，得到模型输出结果后，返回给客户端，用于回复用户的问题。\n暂时无法在飞书文档外展示此内容\n2.2 详细设计 暂时无法在飞书文档外展示此内容\n导入库： 导入所需要的依赖，包括 transformers，torch 和 streamlit。其中torch 魔搭本身已经安装，transformers 和 streamlit在第二步也安装完毕。 模型下载： Yuan2-2B-Mars支持通过多个平台进行下载，包括魔搭、HuggingFace、OpenXlab、百度网盘、WiseModel等。因为我们的机器就在魔搭，所以这里我们直接选择通过魔搭进行下载。模型在魔搭平台的地址为 IEITYuan/Yuan2-2B-Mars-hf。\n模型下载使用的是 modelscope 中的 snapshot_download 函数，第一个参数为模型名称 IEITYuan/Yuan2-2B-Mars-hf，第二个参数 cache_dir 为模型保存路径，这里.表示当前路径。\n模型大小约为4.1G，由于是从魔搭直接进行下载，速度会非常快。下载完成后，会在当前目录增加一个名为 IEITYuan 的文件夹，其中 Yuan2-2B-Mars-hf 里面保存着我们下载好的源大模型。\n模型加载： 使用 transformers 中的 from_pretrained 函数来加载下载好的模型和tokenizer，并通过 .cuda() 将模型放置在GPU上。另外，这里额外使用了 streamlit 提供的一个装饰器 @st.cache_resource ，它可以用于缓存加载好的模型和tokenizer。\n读取用户输入： 使用 streamlit 提供的 chat_input() 来获取用户输入，同时将其保存到对话历史里，并通过st.chat_message(\u0026quot;user\u0026quot;).write(prompt) 在聊天界面上进行显示。\n对话历史拼接： 对于 Yuan2-2B-Mars 模型来说，输入需要在末尾添加 ，模型输出到 结束。如果输入是多轮对话历史，需要使用 进行拼接，并且在末尾添加。\n模型调用： 输入的prompt需要先经tokenizer切分成token，并转成对应的id，并通过 .cuda() 将输入也放置在GPU上。然后调用 model.generate() 生成输出的id，并通过 tokenizer.decode() 将id转成对应的字符串。最后从字符串中提取模型生成的内容（即 之后的字符串），并删除末尾的 ，得到最终的回复内容。\n显示模型输出： 得到回复内容后，将其保存到对话历史里，并通过st.chat_message(\u0026quot;assistant\u0026quot;).write(response) 在聊天界面上进行显示。 尝试替换其他Yuan大****模型！ https://datawhaler.feishu.cn/sync/UG0ydiJi9sSFkub60HmcuQTJn9f\n","date":"2024-08-10T17:06:00Z","image":"http://localhost:1313/post/cover/datawhale-cover.png","permalink":"http://localhost:1313/post/llm/","title":"Datawhale AI夏令营第四期大模型应用开发-Task01"},{"content":"一、迁移至腾讯云 使用Linux，而CentOs7.6不支持Node.js18所以选择了Docker创建hugo。\nDocker 为什么出现? 一款产品:开发\u0026ndash;上线 两套环境！\n应用环境,应用配置，开发即运维。\n环境配置十分麻烦的。\n（集群Redis、ES、Hadoop\u0026hellip;.），发布jar包或者war包，带上环境发布。\n项目能不能带上环境安装打包？2、聊聊Docker为什么会出现_哔哩哔哩_bilibili\n配置麻烦，不能够跨平台。\n传统观念：开发jar，运维来做！\n现在：开发打包部署上线，一套流程做完。\nDocker给以上问题，提出解决方案。\n类比：Java-apk-发布应用商店-使用apk即可\njava-jar-打包代环境\nDocker思想——容器想象为集装箱——隔离机制。\nDocker的历史 2010年-美国成立的公司dotCloud做一些pass的云计算服务！lxc有关的容器技术！\n他们将自己的技术（容器化技术）命名为Docker！但是没有引起行业注意！docCloud，就活不下去了。那么\n就选择开源代码 2013年开源！Docker越来越多人发现了docker的优点！火了，Docker每个月都会更新一个版本！\n2014年4月9日，Docker1.0发布！\n为什么这么火！轻巧！\n容器技术出来之前，我们都是使用的虚拟机技术！19G\n虚拟机：Vmware虚拟机多台一台电脑，但笨重！\nVM：linux centos原生镜像（一个电脑！）\r而docker：隔离，镜像用最核心的环境4m+jdk+mysql 十分的小巧，运行镜像就好了！小巧！几个M几个kb 秒级启动！ 聊聊Docker Docker是基于Go语言开发的！开源项目！\n基于官方文档学习 Docker: Accelerated Container Application Development\n容器化技术：\n不是模拟一个完整的操作系统。\n直接用在操作系统上，充分利用操作系统的资源。\n不同：\n传统虚拟机，虚拟一个硬件，运行一个完整的操作系统他，在系统上安装和运行软件。 容器内的引用hi直接运行在宿主机的上的，容器是没有自己的内容的，也没有虚拟硬件。 容器相互隔离，容器都有一个数以自己的文件系统，不糊影响。 更快速的交付和部署\n传统：一堆帮助文档，安装程序\nDocker：打包镜像发布测试，一键运行\n更便捷的升级和扩缩容\n使用了Docker之后，我们部署引用就和搭积木一样！\n项目打包为一个镜像，扩展——服务器A！服务器B！\n更简单的系统运维\n容器化之后，我们开发，测试环境都是高度一致的。\n更高效的计算资源利用\nDocker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例！服务器的性能能被压榨到极致。\ndocker run了之后发生了什么？ Docker在本机上寻找镜像——判断本机是否有这个镜像——yes——使用运行这个镜像\n——no——Docker上取下载——DockerHub是否可以找到——yes——下载到这个镜像到本地\nno——找不到返回错误\n底层原理 Docker是怎么工作的？\nDocker 是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket客户端访问。\nDockerServer接收到Docker-Client的指令，就会执行这个命令。\n客户端命令-守护进程-产生Dokcer\nDocker为什么比虚拟机快？ 1.Docker有着比虚拟机更少的抽象层\n虚拟机变为了容器，直接在Docker Engine上跑\n2.docker利用的是宿主机的内核，vm需要是Guest OS\n所以新建容器的时候，docker不需要像虚拟机一样重新加载一个操作系统的内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个过程，秒级。\nNS隔离（容器隔离）\nLinux现在都支持了。\nDocker常用命令 镜像命令 帮助命令: docker version docker info #显示系信息，包括镜像，容器数量 docker --help #万能所有命令 帮助文档下载地址：Reference documentation | Docker Docs\n镜像帮助命令 docker images docker images --help [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB #解释 REPOSITORY 镜像仓库源 TAG 镜像的标签 IMAGE ID 镜像的ID CREATED 镜像的创建时间 SIZE 镜像的大小 #可选项 -a,--all\t#列出所有镜像 -q\t--quite\t#只显示ID 下载Mysql\ndocker search mysql #可选项，通过收藏过滤 --filter=stars=3000\t#搜索出来的stars大于3000 #下载镜像 docker pull docker pull --help docker pull mysql docker pull mysql[:tag] #默认下载latest #下载的时候：分层下载，docker image的核心 联合文件系统 docker pull mysql:5.7 #下载5.7版本 这就是linux的联合文件系统。\n删除、查看镜像命令 #删除某镜像 docker rmi -f 镜像images的id #递归id批量删除-删除全部的镜像 docker rmi -f $(docker images -aq) #docker images查看所有镜像 容器命令 说明：有了镜像才能创建容器。\n#下载一个centos基本镜像系统 docker pull centos #run命令的帮助 docker run --help 新建容器并启动、查看 #参数 --name=\u0026#34;Name\u0026#34;\t#容器名字 tomcat01 tomcat02 用来区分容器 -d\t#后台 -it #交互运行 进入容器查看内容 -p\t#指定容器端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 容器端口 -p 随机指定端口 docker images\t#显示所有镜像 #测试，启动并进入容器 docker run -it centos /bin/bash linux的控制台一般在/bin下 #exit退出，从容器退回主机 exit #列出所有正在运行的容器 docker ps -a\t#列出正在运行、历史运行过的容器 -n=?\t#显示最近的?个容器 -q\t#只显示容器的编号 #删除镜像 docker rm mysql 7ce93a845a8a 退出容器 #退出 exit ctrl+p+q #退出容器不停止 此时就是没有停止，可以看到ps后查看所有正在运行的镜像，centos还在运行而没有停止。\n删除容器 docker rm 容器 容器的id docker rm -f $(docker ps -aq)#删除所有容器 docker ps -a -qixargs docker rm #删除所有容器 启动和停止容器 docker start 容器id docker restart 容器id\t#重启 docker stop\t容器id\t#停止 docker kill 容器id\t#强制停止当前命令 停止\n常用的其他命令 后台运行 #docker run -d 镜像名 docker run -d centos #后台运行必须要有前台服务，没有服务就会自杀——易错 docker ps #查看后发现centos停止了 没有前台服务，exit后后台centos自动停止\n查看日志 docker logs --help docker losgs -f -t --tail 容器id\t#查看所有日志和时间戳 docker ps docker run -it centos /bin/bash ctrl+p+q\t#退出容器不停止 docker logs -f -t tail 10 容器id #最近10条日志 发现什么日志也没有，那么\n-tf 显示时间戳和log\n\u0026ndash;tail number #显示日志的条数\n查看容器（容器的信息、源数据） inspect、top命令 #命令\rdocker ps docker top 容器id\t#\rUID用户id PID是进程id\r#!!!!!查看镜像源数据——显示容器的所有信息\r发现\rdocker inspect --help\r查看具体的操作\rdocker inspect 容器id #查看容器的源数据 进入容器（当前正在运行的） #通常容器都是后台运行的，需要进行容器，修改一些配置 #-it：交互模式运行 docker exec -it 容器id bin/bash #2方式attach docker attach -it 容器id #是进入正在运行的命令行 docker rm -f $(docker ps -aq)\t#删除所有 docker exec\t#进入容器后开启一个新的终端，可以在里面操作（常用） docker attach\t#进入当前容器正在运行的终端，不会启动新的进程！ docker ps docker images docker run -it centos /bin/bash 如何将容器文件拷主机 cd /home touch kaugnsheng.java ls docker ps docker attach 容器id cd /home\t#此时在容器内 ls touch test.java exit\t#虽然容器停止了，但是数据还在 docker ps docker ps -a docer cp 容器id:/home/test.java /home\t#从容器拷贝到主机 ls 二、用docker安装nginx Docker Hub Container Image Library | App Containerization\nDockerhub #1搜索镜像 #2下载镜像 [root@VM-12-5-centos home]# docker pull nginx 开放3344端口开放，公网的3344可以访问nginx01的80端口 docker run -d --name nginx01 -p 3344:80 nginx #-d 后台 #--name 给容器命名 #-p 宿主机:容器内端口 [root@VM-12-5-centos home]# docker run -d --name nginx01 -p 3344:80 nginx 15d98bf175044e55e9e5743165cf1fb1256c67c015ea6b0326dd27320b1b018a [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 26 seconds ago Up 25 seconds 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 18 minutes ago Up 18 minutes intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 24 hours ago Up 24 hours 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick #本机自测通过了——在宿主机上开启3344端口，相当于映射到了docker上的nginx的80端口 [root@VM-12-5-centos home]# curl localhost:3344 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [root@VM-12-5-centos home]# 现在在阿里云里就能localhost:3344访问到docker的nginx的80端口了\n进入容器操作\ndocker exec -it nginx01 /bin/bash\n如果阿里云防火墙安全组开了3344端口，那么外网是可以从：外网ip:3344可以访问到界面的。 可视化面板 portainer（先用这个） rancher（ci/cd）再用 图形化界面管理工具,提供一个后台面板供我们操作。\n外网8088端口\ndocker run -d -p 8088:9000\\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 安装后外网的8088端口、设置阿里云安全组，然后即可访问ui界面，看得到多少个镜像、容器在运行和端口映射关系。\n或者在curl localhost:8088然后在服务器中访问也可以。\n可视化面板。\n所有的应用，直接打包部署。\n镜像得到的方式： 远程仓库下载 朋友拷贝给你 自己制作镜像 三、理解分层管理 联合文件系统UnionFS 支持对文件系统的修改作为一次提交来一层层叠加。\ntomcat和mysql都要用到某个linux内核，那么就只会新增。\n层的概念，image+images\ndocker的镜像实际上是由一层层的文件系统组成的，这种层级的文件系统UnionFS\n黑屏\u0026mdash;开机的过程中没有了，那么这段时间都是公用的。\n**bootfs(boot file system)**相当于省去了这段时间，更快。而且精简的内核OS，例如centos很小。\n分层 docker pull redis\n这一层已经存在了\ndocker image inspect redis:laest 查看里面layers 在layer记录\n打包的时候会有6个文件\n文件能实现替换，也能文件复用。\nredis的联合文件系统的表示\n在layer中也是6个\n所以docker是分层下载的。\n特点 run起来的东西可以修改，而镜像是无法修改的。\n四、如何提交自己的镜像 commit docker commit 提交容器成为一个新的副本 #命令和git原理类似 docker commit -m \u0026#34;提交描述的消息\u0026#34; -a\u0026#34;作者\u0026#34; 举例： 将tomcat的docker的webapps的内文件拷贝打牌webapps中，制作一个webapps中有文件的镜像\ndocker images docker run -it -p 8080:8080 tomcat\t#启动docker-tomcat #1.启动了tomcat的前台 docker ps docker exec -it 容器id /bin/bash\t#进入了tomcat控制台 cd webapps ls cd.. ls cp -r webapps.dist/* webapps 发布镜像 root@7803ab322d1d:/usr/local/tomcat/webapps# ls docs examples host-manager manager ROOT root@7803ab322d1d:/usr/local/tomcat/webapps# exit exit [root@VM-12-5-centos ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7803ab322d1d tomcat \u0026#34;catalina.sh run\u0026#34; 10 minutes ago Up 10 minutes 8080/tcp, 0.0.0.0:8081-\u0026gt;8081/tcp, :::8081-\u0026gt;8081/tcp cranky_payne 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 39 hours ago Up 39 hours intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick #4.将我们操作过的容器通过commit提交为一个新的镜像 [root@VM-12-5-centos ~]# docker commit -a=\u0026#34;kuangsheng\u0026#34; -m=\u0026#34;add webapps applalala\u0026#34; 7803ab322d1d tomcat02:1.0 sha256:73725f496f3b9c35005b2089ec45f577ed62958d9bf00ca0c3b91455bc683e34 [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 11 seconds ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos ~]# 类比学习：VM的快照。\n容器数据卷 什么是容器数据卷？ docker的理念回顾，应用和环境打包为一个镜像！\n数据？如果数据在容器中，那么将容器删除，数据就会丢失！需求：数据可以持久化\nMySQL，容器删了，删除跑路！需求：MySQL数据可以存储在本地\n卷技术就是这样！\n目录的挂在，将容器内的目录挂载到Linux上面！\n总结：容器的持久化和同步操作容器间也是可以数据共享的！ 使用数据卷 方法一、直接使用命令来挂载 -v docker run -it -v 主机目录:容器目录 #测试 [root@VM-12-5-centos home]# docker run -it -v /home/ceshi:/home centos /bin/bash #可以看到宿主机有了/ceshi目录 [root@VM-12-5-centos ~]# cd home -bash: cd: home: No such file or directory [root@VM-12-5-centos ~]# cd /home [root@VM-12-5-centos home]# ls ceshi git git_1 kaungsheng.java lighthouse PoolBee www [root@VM-12-5-centos home]# #centos的容器的/home目录 [root@VM-12-5-centos ~]# cd /homge -bash: cd: /homge: No such file or directory [root@VM-12-5-centos ~]# cd /home [root@VM-12-5-centos home]# ls git git_1 kaungsheng.java lighthouse PoolBee www [root@VM-12-5-centos home]# docker run -it -v /home/ceshi:/home centos /bin/bash [root@783df7f8b77c /]# cd /home [root@783df7f8b77c home]# ls [root@783df7f8b77c home]# #以后外部放的文件以后就会和docker的cenos的/home目录同步 #查看centos的容器的信息 [root@VM-12-5-centos home]# docker inspect 783df7f8b77c #Mount中 \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/home/ceshi\u0026#34;,#主机内地址 \u0026#34;Destination\u0026#34;: \u0026#34;/home\u0026#34;,#docker容器内地址 \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;rprivate\u0026#34; } ], #测试 #可以看到主机中是空的 [root@VM-12-5-centos home]# cd ceshi [root@VM-12-5-centos ceshi]# ls [root@VM-12-5-centos ceshi]# #在容器中创建test.java [root@783df7f8b77c home]# touch test.java [root@783df7f8b77c home]# #后续在主机中查看到传过来了！ [root@VM-12-5-centos ceshi]# ls [root@VM-12-5-centos ceshi]# ls test.java [root@VM-12-5-centos ceshi]# 同步的过程 如果容器停止，但是在Linux的文件夹更改，还是会同步到容器内绑定的文件夹！ #如果容器停止，但是在Linux的文件夹更改，还是会同步到容器内绑定的文件夹！ #1.让容器停止 [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Up 40 hours intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick [root@VM-12-5-centos home]# stop 39fd379b5760 bash: stop: command not found... Similar command is: \u0026#39;top\u0026#39; [root@VM-12-5-centos home]# docker stop 39fd379b5760 39fd379b5760 [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick [root@VM-12-5-centos home]# #修改宿主机中的文件 #启动容器进行查看 [root@VM-12-5-centos home]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 09b5fac024a8 5d0da3dc9764 \u0026#34;/bin/bash\u0026#34; 2 minutes ago Exited (0) 2 minutes ago objective_noyce 783df7f8b77c centos \u0026#34;/bin/bash\u0026#34; 19 minutes ago Exited (0) 10 minutes ago affectionate_shaw 7803ab322d1d tomcat \u0026#34;catalina.sh run\u0026#34; 46 minutes ago Exited (130) 22 minutes ago cranky_payne 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 40 hours ago Up 40 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 a17f2df4b0c2 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago eloquent_northcutt 223a694af194 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago magical_volhard 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 4 minutes ago intelligent_lovelace 28e3e9b4ecdf centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago unruffled_sinoussi f75f0b03f939 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago vigilant_euclid aa158bb7f0e1 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago elated_robinson d6dfa990d314 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago nervous_montalcini 9101ac141b0f centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago competent_mcnulty 02cd07c4283d centos \u0026#34;/bin/basj\u0026#34; 40 hours ago Created upbeat_driscoll 9b872200a3b3 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago stoic_kepler 8512fca58a26 centos \u0026#34;/bin/basj\u0026#34; 40 hours ago Created hungry_sutherland 7fd5a54afd95 hello-world \u0026#34;/hello\u0026#34; 2 days ago Exited (0) 2 days ago cool_turing 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick 59e514225874 klakegg/hugo:latest-ext \u0026#34;hugo\u0026#34; 2 days ago Exited (255) 2 days ago confident_bassi [root@VM-12-5-centos home]# docker start 783df7f8b77c 783df7f8b77c [root@VM-12-5-centos home]# docker attach 783df7f8b77c [root@783df7f8b77c /]# cd /home [root@783df7f8b77c home]# ls test.java [root@783df7f8b77c home]# cat test/java cat: test/java: No such file or directory [root@783df7f8b77c home]# cat test.java hello linux update [root@783df7f8b77c home]# #可以看到成功了！ 好处：以后在本地修改，容器中会自动同步。\n实战：安装MySQL 思考：MySQL的数据持久化问题！\n#下载mysql #docker search mysql #进官网看版本 #docker pull mysql:5.7 [root@VM-12-5-centos home]# docker pull mysql:5.7 5.7: Pulling from library/mysql 20e4dcae4c69: Downloading [=============\u0026gt; ] 13.71MB/50.5MB 1c56c3d4ce74: Download complete e9f03a1c24ce: Download complete 68c3898c2015: Download complete 6b95a940e7b6: Download complete 90986bb8de6e: Download complete ae71319cb779: Waiting ffc89e9dfd88: Download complete 43d05e938198: Waiting 064b2d298fba: Waiting df9a4d85569b: Waiting [root@VM-12-5-centos home]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 49 minutes ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos home]# #运行容器进行数据挂载 #安装启动mysql，要配置【用户密码】 #去docker hub找mysql [root@VM-12-5-centos home]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 49 minutes ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 4d55165721b1195ccfb240b39dcf2f5cb9d8edd50095305d4197ae55391fbf5b [root@VM-12-5-centos home]# #启动我们的mysql -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 --name 容器名字 mysql - Official Image | Docker Hub\n官网中\n$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag -e MYSQL_ROOT_PASSWORD=123456 \u0026ndash;name mysql01 mysql:5.7\n-e 就是配置环境，那么这里就是设置密码\n新建Mysql连接 阿里云安全组、本地防火墙、虚拟机防火墙。\n且要保证这个是有程序占用的！\n#云服务器LinuxCentos上打开3306,命令行打开或图形化界面打开 #腾讯云安全组设置，本机windows设置防火墙设置出站规则 [root@VM-12-5-centos home]# firewall-cmd --permanent --add-port=3306/tcp success [root@VM-12-5-centos home]# firewall-cmd --reload success [root@VM-12-5-centos home]# 宝塔面板中可以看到状态，而腾讯云的看不到\n重启服务器，然后在宝塔中查看状态为未使用。\n已经下载了mysql5.7镜像，然后又删除了原本的mysql01容器，然后重新根据景象创建，成功了！ [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 2 hours ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 docker: Error response from daemon: Conflict. The container name \u0026#34;/mysql01\u0026#34; is already in use by container \u0026#34;4d55165721b1195ccfb240b39dcf2f5cb9d8edd50095305d4197ae55391fbf5b\u0026#34;. You have to remove (or rename) that container to be able to reuse that name. See \u0026#39;docker run --help\u0026#39;. [root@VM-12-5-centos ~]# stop mysql01 bash: stop: command not found... Similar command is: \u0026#39;top\u0026#39; [root@VM-12-5-centos ~]# docker stop mysql01 mysql01 [root@VM-12-5-centos ~]# [root@VM-12-5-centos ~]# docker rm mysql01 mysql01 #两个容器数据卷进行挂载 # -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql #1.宿主机/home/mysql/conf---\u0026gt;docker的/etc/mysql/conf.d mysql的配置文件 #2.宿主机/home/mysql/data---\u0026gt;docker的/var/lib/mysql mysql的数据文件 [root@VM-12-5-centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 f669f7ef2710692ff207cd5b8889e77289d3631e5419e494ad056fd0e405f504 [root@VM-12-5-centos ~]# #启动成功后本地是有sqlyog来测试 #sqlyog--连接到服务器的3310--3310和容器中的3306映射，这个时候可以连接上了 具名和匿名挂载 匿名挂载 # -v 容器内路径 docker run -d -p --name nginx01 -v /etc/nginx nginx docker volume --help docker volum ls\t#查看所有volum的镜像 docker volume ls\n这些都是匿名卷，每一个VOLUME NAME\n只写了容器内的路径，没有写容器外的路径。\n具名挂载 #具名挂载 #通过 -v 卷名:容器内路径 ls docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx nginx #juming-nginx这个代表是-v的名字VOLUMN NAME而不是路径。 #看一下这个卷 #是在/var/lib/docker/volumes/juming-nginx/_data #\t里面就是默认的具名挂载的位置 #/var/lib/docker/volumes\t所有卷存储的位置 #/var/lib/docker\tdocker的所有的文件 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！ -V容器内路径 #匿名挂载 -V卷名：容器内路径 #具名挂载 -V/宿主机路径：：容器内路径#指定路径挂载！ 拓展：-v 容器内路径:ro rw 改变读写权限 #通过 -v 容器内路径:ro rw 改变读写权限 ro readonly\t#只读 rw\treadwrite\t#可读可写 docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx:ro nginx docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx:rw nginx #ro 只要看到ro说明路径只能通过宿主机来操作，容器内部是无法操作的。 ","date":"2024-08-07T20:01:49Z","image":"http://localhost:1313/post/cover/docker-cover.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.08.08/","title":"Hugo主题-Docker学习-8月8日博客更新日志"},{"content":"Echarts使用方法： 官方教程：https://echarts.apache.org/handbook/zh/get-started/\n1.首先要提供一个容器，并给定大小 例如：\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .box{ width: 300px; height: 300px; background-color: rgb(188, 227, 236); } \u0026lt;/style\u0026gt; 2.引入需要的js地图文件，一般是而echart.js和一个地图js文件 (1)本地js文件引入 \u0026lt;script src=\u0026#34;/XXX/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/XXX/china.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 引入即可\n但echart官网已经挂了，不提供地图js文件。自行网上查阅吧~\n(2)CDN引入 \u0026lt;!-- \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/echarts@latest/dist/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;china.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; 注意：如果用npm等包管理器安装过了echart，然后用webpack打包了。那么在中可以使用import语句进行引入\n// import * as echarts from \u0026#39;echarts\u0026#39;; 3.实例化echarts对象 \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; var myChart = echarts.init(document.querySelector(\u0026#34;.box\u0026#34;)); 4.指定配置项和数据 var option = { title: { text: \u0026#39;ECharts 入门示例\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;销量\u0026#39;] }, xAxis: { data: [\u0026#34;衬衫\u0026#34;,\u0026#34;羊毛衫\u0026#34;,\u0026#34;雪纺衫\u0026#34;,\u0026#34;裤子\u0026#34;,\u0026#34;高跟鞋\u0026#34;,\u0026#34;袜子\u0026#34;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20] }] }; 5.将配置项设置给echarts实例对象，使用刚指定的配置项和数据显示图表 myChart.setOption(option); 完整代码 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document01\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box{ width: 300px; height: 300px; background-color: rgb(188, 227, 236); } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 1..准备具有大小的DOM容器 --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 2.方法一 、直接写路径--\u0026gt; \u0026lt;!-- 2.方法二、CDN引入--\u0026gt; \u0026lt;!-- \u0026lt;script src=\u0026#34;echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;script src=\u0026#34;echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // import * as echarts from \u0026#39;echarts\u0026#39;;不行 //3.初始化实例对象 echarts.init(dom容器) var myChart = echarts.init(document.querySelector(\u0026#34;.box\u0026#34;)); //4.指定配置项和数据 var option = { title: { text: \u0026#39;ECharts 入门示例\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;销量\u0026#39;] }, xAxis: { data: [\u0026#34;衬衫\u0026#34;,\u0026#34;羊毛衫\u0026#34;,\u0026#34;雪纺衫\u0026#34;,\u0026#34;裤子\u0026#34;,\u0026#34;高跟鞋\u0026#34;,\u0026#34;袜子\u0026#34;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20] }] }; //5.将配置项设置给echarts实例对象，使用刚指定的配置项和数据显示图表。 myChart.setOption(option); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 常见问题 1.下载地图.js文件，自行google。 2.下载的地图文件的GeoJSON 数据为乱码 地图文件的GeoJSON 乱码解决方法： DataV.GeoAtlas\n添加在对应的Geojson即可。 ","date":"2024-07-25T23:50:28Z","image":"http://localhost:1313/post/cover/plugin_cover.jpg","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.26-2/","title":"Echart使用及常见问题"},{"content":"​\n这几天逛了很多博客，找到了十年之约 (foreverblog.cn)、博客广场 - 博友圈 · 博客人的朋友圈！ (boyouquan.com)等博客交流圈子，等我慢慢写博客，然后域名备案下来了，提交申请吧~ 一、新增博客背景虚化图片 ​\t这个很简单，在assets\\scss\\custom.scss中对body选择器声明块中增加，背景图片即可。\n如果要点击暗色模式的时候，切换背景虚化的颜色。那么需要在为暗色模式的click事件中增加背景虚化的类。\n\\主题文件夹\\public\\ts\\main.ts中\n首先在CSS: 使用 .dark-mode 类在暗色模式下应用黑色毛玻璃效果。\nbody { background-image: url(\u0026#39;/page/nav-img/background4.jpg\u0026#39;); background-size: cover; background-attachment: fixed; position: relative; transition: background-color 0.3s ease; } body::after { content: \u0026#39;\u0026#39;; position: absolute; top: 0; left: 0; right: 0; bottom: 0; /* 白色模式下的样式 */ background: rgba(176, 176, 176, 0.595); /* 黑色半透明 */ backdrop-filter: blur(10px); /* 毛玻璃效果 */ z-index: -1; // transition: background 0.3s ease, backdrop-filter 0.3s ease; /* 平滑过渡效果 */ } /* 暗色模式下的样式 */ body.dark-mode::after { background: rgba(158, 157, 157, 0.5); /* 更强的黑色半透明毛玻璃效果 */ 其次main.ts的JS中: 切换 dark-mode 类以应用新的样式。\nmain.ts // 初始化颜色方案切换器 const colorSchemeToggler = new colorScheme_default(document.getElementById(\u0026#34;dark-mode-toggle\u0026#34;)); // 为暗色模式切换按钮添加事件监听器 const darkModeToggleButton = document.getElementById(\u0026#34;dark-mode-toggle\u0026#34;); if (darkModeToggleButton) { darkModeToggleButton.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { // 切换 body 上的 \u0026#39;dark-mode\u0026#39; 类，切换到暗色模式 document.body.classList.toggle(\u0026#34;dark-mode\u0026#34;); }); } } }; 实现效果。\n二、新增导航栏及Home、关于我、走走停停板块 (1)导航栏 1.创建导航栏的html layouts/partials 文件夹中创建一个新的部分文件 我创建在了\\hugo-theme-stack-3.26.0\\layouts\\partials\\navbar目录下的navbar.html\n\u0026lt;!-- layouts/partials/navbar.html --\u0026gt; \u0026lt;nav class=\u0026#34;navbar--fixed-top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34; class=\u0026#34;navbar-brand\u0026#34;\u0026gt;Logo\u0026lt;/a\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/about\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/contact\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;Contact\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; 2.在Hugo主模板中包含导航栏 修改_default目录下的baseof.html，这个文件是Hugo主题的模板文件，可以用go自己设计模板。\n要包含navbar.html即可\n\\hugo-theme-stack-3.26.0\\layouts\\_default\\baseof.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34; dir=\u0026#34;{{ default `ltr` .Language.LanguageDirection }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{- partial \u0026#34;head/head.html\u0026#34; . -}} {{- block \u0026#34;head\u0026#34; . -}}{{ end }} \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;{{ block `body-class` . }}{{ end }}\u0026#34;\u0026gt; {{- partial \u0026#34;head/colorScheme\u0026#34; . -}} \u0026lt;!-- 导航栏的html文件包含 --\u0026gt; {{ partial \u0026#34;navbar/navbar.html\u0026#34; . }} \u0026lt;!-- 包含导航栏 --\u0026gt; {{/* The container is wider when there\u0026#39;s any activated widget */}} {{- $hasWidget := false -}} {{- range .Site.Params.widgets -}} {{- if gt (len .) 0 -}} {{- $hasWidget = true -}} {{- end -}} {{- end -}} \u0026lt;div class=\u0026#34;container main-container flex on-phone--column {{ if $hasWidget }}extended{{ else }}compact{{ end }}\u0026#34;\u0026gt; {{- block \u0026#34;left-sidebar\u0026#34; . -}} {{ partial \u0026#34;sidebar/left.html\u0026#34; . }} {{- end -}} {{- block \u0026#34;right-sidebar\u0026#34; . -}}{{ end }} \u0026lt;main class=\u0026#34;main full-width\u0026#34;\u0026gt; {{- block \u0026#34;main\u0026#34; . }}{{- end }} \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; {{ partial \u0026#34;footer/include.html\u0026#34; . }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3.为导航栏的html增加css样式 我放在了\\hugo-theme-stack-3.26.0\\assets\\scss\\partials的navbar.scss中\n/* assets/css/styles.css */ .navbar--fixed-top { position: sticky; top: 0; z-index: var(--ifm-z-index-fixed); background-color: white; /* 你可以根据需要添加其他样式 */ box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); padding: 10px 0; } .navbar-nav { list-style: none; display: flex; gap: 20px; } .nav-item { display: inline; } .nav-link { text-decoration: none; color: black; } .navbar-brand { font-size: 1.5em; font-weight: bold; } 4.在head.html文件下确保css被正确引用 theme-stack-3.26.0\\layouts\\partials\\head\\head.html中\n\u0026lt;meta charset=\u0026#39;utf-8\u0026#39;\u0026gt; \u0026lt;meta name=\u0026#39;viewport\u0026#39; content=\u0026#39;width=device-width, initial-scale=1\u0026#39;\u0026gt; {{- $description := partialCached \u0026#34;data/description\u0026#34; . .RelPermalink -}} \u0026lt;meta name=\u0026#39;description\u0026#39; {{ printf \u0026#34;content=%q\u0026#34; $description | safeHTMLAttr }}\u0026gt; {{ with .Params.Keywords }}\u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;{{ delimit . \u0026#34;, \u0026#34; }}\u0026#34;\u0026gt;{{ end }} {{- $title := partial \u0026#34;data/title\u0026#34; . -}} \u0026lt;title\u0026gt;{{ $title }}\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#39;canonical\u0026#39; href=\u0026#39;{{ .Permalink }}\u0026#39;\u0026gt; \u0026lt;!-- navbar的css引用 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ \u0026#34;/scss/partials/navbar.scss\u0026#34; | relURL }}\u0026#34;\u0026gt; \u0026lt;!-- 添加CSS文件引用 --\u0026gt; {{- partial \u0026#34;head/style.html\u0026#34; . -}} {{- partial \u0026#34;head/script.html\u0026#34; . -}} {{- partial \u0026#34;head/opengraph/include.html\u0026#34; . -}} {{- range .AlternativeOutputFormats -}} \u0026lt;link rel=\u0026#34;{{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; href=\u0026#34;{{ .Permalink | safeURL }}\u0026#34;\u0026gt; {{- end -}} {{ with .Site.Params.favicon }} \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;{{ . | relURL }}\u0026#34; /\u0026gt; {{ end }} {{- template \u0026#34;_internal/google_analytics.html\u0026#34; . -}} {{- partial \u0026#34;head/custom.html\u0026#34; . -}} \u0026lt;!-- busuanzi --\u0026gt; {{- if .Site.Params.busuanzi.enable -}} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; {{- end -}} 5.然后在style.scss中增加scss引用 /*! * Hugo Theme Stack * * @author: Jimmy Cai * @website: https://jimmycai.com * @link: https://github.com/CaiJimmy/hugo-theme-stack 这个 SCSS 文件作为一个主文件，起到将所有相关样式文件引入到一个地方的作用。 它确保项目中的样式文件能够被组织和管理，使得最终生成的 CSS 文件包含了所有必要的样式定义。 这种结构化的样式管理方式有助于保持代码的清晰和模块化。 */ @import \u0026#34;breakpoints.scss\u0026#34;; @import \u0026#34;variables.scss\u0026#34;; @import \u0026#34;grid.scss\u0026#34;; @import \u0026#34;external/normalize.scss\u0026#34;; @import \u0026#34;partials/menu.scss\u0026#34;; @import \u0026#34;partials/article.scss\u0026#34;; @import \u0026#34;partials/widgets.scss\u0026#34;; @import \u0026#34;partials/footer.scss\u0026#34;; @import \u0026#34;partials/pagination.scss\u0026#34;; @import \u0026#34;partials/sidebar.scss\u0026#34;; @import \u0026#34;partials/base.scss\u0026#34;; @import \u0026#34;partials/layout/article.scss\u0026#34;; @import \u0026#34;partials/layout/list.scss\u0026#34;; @import \u0026#34;partials/layout/404.scss\u0026#34;; @import \u0026#34;partials/layout/search.scss\u0026#34;; @import \u0026#34;general.scss\u0026#34;; @import \u0026#34;custom.scss\u0026#34;; // narbar @import \u0026#34;partials/navbar.scss\u0026#34; 这就可以增加导航栏了。\n(2)关于我 定位到acrchives的.md文件。navbar的html中设置a标签href跳转即可。 md文件的layout设置为已经存在的layout文件，我使用的是archives的layout文件。 (3)走走停停 1.使用Apache ECharts创建地图 一个基于 JavaScript 的开源可视化图表库Apache ECharts\n三、走走停停板块的设置 pb主题\\content\\page\\daily_info中的index.md\nlayout自定义了daily_info的Hugo模块\n\\hugo-theme-stack-3.26.0\\layouts\\partials\\map中创建了index4.html设置了地图及时间轴\n\\hugo-theme-stack-3.26.0\\layouts_default中创建了daily_info.html自定义了模板，引入了index4.index（archives.html也默认再此设置的）\n","date":"2024-07-25T22:14:28Z","image":"http://localhost:1313/post/cover/stack-logo-128.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.26-1/","title":"Hugo主题配置记录-7月26日博客更新日志"},{"content":"解决了一些小问题，之前建站留下的小问题\n一、左侧栏的正确跳转 点击图标后跳转到链接栏中有二维码\nconfig.yaml中修改跳转链接到/post/link即可\n点击\u0026quot;链接\u0026quot;后出现二维码\n二、文章图片的正确插入 1.文章封面图片 \\content\\post中的文章 ##Front Matter图片插入记得要添加/post/路径 例如： image: /post/123.png\n--- title: 文章标题 date: 2024-07-23 10:00:00 tags: - 标签1 - 标签2 categories: - 分类1 - 分类2 #这里的就是文章封面图片 image: /post/stack-logo-128.png --- 这里注意\\content\\page\\中的文章\n在文章内部的时候，\n![图片](123.jpg)不需要添加/post/路径\n2.文章内部图片 \\content\\post\\中需要添加多个图片\n可以放入文件夹中，避免多个md文件和多个图片堆在一起。【注意：可以不写明在哪个文件夹，直接写/post/文件名即可】\n例如：![image-20240607184445492](/post/123.png)\n![image-20240607184336146](/post/文件夹/123.png)这样详细写明最好，实现图片的插入。\n其实在/post目录中用/post/123.png这样的方式，会自动搜寻/post目录下的123.png文件，（自我理解）所以不用写明中间的/before文件夹。\n最后：\nFront Matter中的links项的路径也一样需要加post，从post路径开始必须指定路径清晰到文件 links: \\- title: Bilibili description: bilibili是国内知名的视频弹幕网站,这里有及时的动漫新番,活跃的ACG氛围,有创意的Up主。大家可以在这里找到许多欢乐。 website: https://www.bilibili.com/ image: /post/logo/Bilibili_Logo_Blue.svg ","date":"2024-07-22T15:41:48Z","image":"http://localhost:1313/post/cover/stack-logo-128.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.23/","title":"Hugo主题配置记录-7月23日博客更新日志"},{"content":"Hugo主题配置记录 1.引入busuanzi插件进行字数、访问量统计。 \\layouts\\partials\\footer\nfooter文件中\n增加以下代码\n\u0026lt;!-- 卜算子统计信息 --\u0026gt; \u0026lt;section class=\u0026#34;count_info\u0026#34;\u0026gt; \u0026lt;!-- 1运行时间 --\u0026gt; \u0026lt;div\u0026gt; {{ T \u0026#34;footer.runtime1\u0026#34; }} \u0026lt;span id=\u0026#34;ds\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime2\u0026#34; }} \u0026lt;span id=\u0026#34;hs\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime3\u0026#34; }} \u0026lt;span id=\u0026#34;ms\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime4\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;!-- 2文章个数和字数 --\u0026gt; \u0026lt;div\u0026gt; {{ $scratch := newScratch }} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34;) }} {{ $scratch.Add \u0026#34;total\u0026#34; .WordCount }} {{ end }} \u0026lt;!-- 转换为整数 --\u0026gt; {{ $total := $scratch.Get \u0026#34;total\u0026#34; | int }} \u0026lt;!-- 转换为浮点数 --\u0026gt; {{ $totalFloat := $total | float }} {{ T \u0026#34;footer.count1\u0026#34; }} {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }} {{ T \u0026#34;footer.count2\u0026#34; }} {{ div $totalFloat 1000.0 | lang.FormatNumber 2 }} k {{ T \u0026#34;footer.count3\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;!-- 3本站访问量 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt;{{ T \u0026#34;footer.pv1\u0026#34; }}\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;{{ T \u0026#34;footer.pv2\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 卜算子js脚本 --\u0026gt; \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; (1)运行时间 \u0026lt;!-- 1运行时间 --\u0026gt; \u0026lt;div\u0026gt; {{ T \u0026#34;footer.runtime1\u0026#34; }} \u0026lt;span id=\u0026#34;ds\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime2\u0026#34; }} \u0026lt;span id=\u0026#34;hs\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime3\u0026#34; }} \u0026lt;span id=\u0026#34;ms\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime4\u0026#34; }} \u0026lt;/div\u0026gt; (2)文章个数和字数 使用 Hugo 的Scratch 存储器计算总字数。range (where .Site.Pages \u0026ldquo;Kind\u0026rdquo; \u0026ldquo;page\u0026rdquo;)遍历所有页面类型为 page 的页面。\n{{ $scratch.Add \u0026ldquo;total\u0026rdquo; .WordCount }} 将每个页面的字数累加到total。转化为整数和浮点数，\n{{ len (where .Site.RegularPages \u0026ldquo;Section\u0026rdquo; \u0026ldquo;post\u0026rdquo;) }}计算文章数量。\n{{ div $totalFloat 1000.0 | lang.FormatNumber 2 }} k将总字数除以 1000 格式化为两位小数。\nHugo 的T函数插入翻译文本\n(3)本站访问量 使用js脚本\n不蒜子 - 极简网页计数器 (ibruce.info)\n复制js代码即可。\n2.删除网站语言切换 config.yaml中删除默认语言设置\n主题最新的配置文件可以在 exampleSite/config.yaml\n配置主题 | Hugo 主题 Stack (stack-docs.netlify.app)\n\u0026lt;--删除自己的配置即可--\u0026gt; 3.更改社交图标样式、间距 \\assets\\scss\\custom.scss\n中修改即可\n.menu-social{ gap: 15px; margin-top: 25px; } 4.增加返回顶部按钮、样式替换 \\layouts\\partials\\widget\n增加如下代码\n{{ $topImg := resources.Get (\u0026#34;icons/back-to-top.svg\u0026#34;) }} \u0026lt;a id=\u0026#34;back-to-top\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt; {{$topImg.Content | safeHTML}} \u0026lt;/a\u0026gt; resources.Get获取svg文件到$topImg\na标签属性链接href=\u0026quot;#\u0026ldquo;实现返回顶部，插入svg内容进行渲染。\n\\assets\\scss\\custom.scss $hover: 0.2s ease-in-out; #back-to-top { position: fixed; margin-left: 150px; bottom: 60px; display: none; border: 0; transition: transform $hover; \u0026amp;:hover { transform: translateY(-10px); } } ease-in-out过渡，#back-to-top 定义了 ID 为 back-to-top 的元素的样式规则。\n\\assets\\icons iconfont-阿里巴巴矢量图标库 下载svg格式的图标，然后记住颜色代码，编辑搜索将颜色代码替换为currentColor就能实现颜色随暗色模式切换变化。\n链接： ","date":"2024-07-20T20:01:49Z","image":"http://localhost:1313/post/cover/stack-logo-128.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.21/","title":"Hugo主题配置记录-7月21日博客更新日志"},{"content":"Hugo主题配置记录\n建站回顾 1. 域名 正在ICP备案,预计7个工作日后能拿到备案的域名。慢慢来吧1111\n2. 服务器 腾讯云服务器，40G, 1M带宽，1核2G内存。\n3. 博客框架 暂时用的Hugo，建站很快。\n历程 框架选来选去，之前用过Hexo主题,但是时间过于久远。这次想在云服务器上运行，遂重新开始。框架从Hexo到Halo到Hugo。 原本在Linux上安装Hexo得心应手，但这次在CentOS7.6并不支持Nodejs8,支持不了最新的Hexo主题,又转为Halo， Halo苦于教程少啊,而且Hugo整体还是很方便,比较下来Hexo的教程\u0026gt;Hugo\u0026gt;Halo，最终确定了Hugo框架。 现在网站搭起来了，后续慢慢再更新文章~~。 ","date":"2024-07-19T21:14:39Z","permalink":"http://localhost:1313/post/%E9%9A%8F%E7%AC%94/","title":"随笔"},{"content":"\ncheck point 就是菜单——选择不同的模型\nlora更精确的人物或画风，更可控\n图生图\n上传\n描述图片\nAI摄影\nlora炼丹\n七天免费试用领取\n聚焦剪裁、中央剪裁、无需剪裁、\n使用deepbooru算法反推标注。0.6 系数越小越精细\n日志看loss值，数值降低大概率没什么问题\n一、提示词prompt 类别\n其他提示词：画质等\n但是真实系的操作是更依赖真实的模型\n1.prompt模板: 具体的直接使用即可 2.提示词权重分配 增强减弱(){}\t[] 安全范围1+-0.5，单个的\n():1.1倍，1.331倍\n{}\n[1]进阶语法-坑 不想出现就是负向提示词 单色风格的画作\n3.采样迭代步数 加噪点——去除噪点\n闪一次，就步数\u0026gt;20后意义不大\n最低不要低于10\n采样方法 带有++号的是改进的算法，最好使用比较稳定。\n分辨率过高容易出现多人，多手。\n一般低分辨率绘制，然后hires fix 来放大 高清修复、 面部修复、平铺/分块：生成无缝贴满整个屏幕的纹理性图片的；一般不用\n7-12相关性一般\n批次和数量\n批次是格子预览图。每次批次数量不宜过高，容易爆显存。\n4.写提示词方法 1.翻译、描述确切场景，然后直接让词组翻译为英文 2.功能插件、翻译的插件——国内有——SD也有 3.更好书写提示词网站：AI词汇加速器 提示词网站：\n二次元和亚洲面孔多：\n人物、\n画风、质感：\n二、图生图 原理：原本提醒上记录的像素信息会在加噪和去噪的过程中、被作为一种特征反应到生成的图片上。\n1.上传图片、导入到SD里 2.提示词书写 1man,1girl\n3.参数设置 重绘幅度0.6-0.8\n分辨率设置，原始尺寸一样最好\n按长宽比例一致生成、\n[1]随机种子 xxx in backgroud\n景深depth of field\n如果要保留生成的原本的元素的样子，只改动背景，不改动人物风格呢？ 同一个随机种子、同一套随机种子、 骰子：-1是随机，循环按钮是上一次的种子。\n图库浏览器中以前生成的图片，里面有种子。\n种子加上+需要的背景提示词。 不像人物的物品的拟人化、静物或者墙角的旮旯来想象。——抖音评论区中有 [2]图生图的风格迁移： 游戏中的卡通形象到真实的现实中、可以输入提示词、更加精确的需要lora模型。\n[3]photoshop中搭建图像框架+SD生成图片——炫酷的效果。 画布\n画图中\n然后场景插画就完成了！ 三、画风 1.Checkpoint 模型信息：\n下载的模型放入这里就能加载。\n所以就叫关键点、存档。\n所以这些检查点，这些模型就能有迭代、更新的能力，AOM3A3深橘色。\n2. .ckpt文件 几个G的叫大模型\n3. .safetensors 训练者让模型更加可靠高效来使用的一种格式。\n点击刷星按钮\n命令行中跳出提示才算成功\n秋叶的启动器能对管理下载\n4. VAE VAE选项[变分自解码器Variational Autp Encoder] 负责将加噪后的潜空间数据转化为正常图像。\nAI绘图的调色滤镜，直接表现是影响色彩质感。—— 一般checkpoint里包含了VAE但是也有没有到——图片会发灰，发白\n会推荐使用一些VAE\n也有适用于大多数checkpoint的VAE：kl-f8-anime2.ckpt\n也有safetensors的VAE\n[1]自动的适配VAE方法 改为和模型一样的名字\n三-进阶 {1}Hypernetwork超网络模型 画面微调\n作用：和Lora差不多的，也可以让AI学习一些原本不存在它世界里的东西，\n不像Lora是彩卡插画。那么它像一张小名片\nHypernetwork一般用于改善画面的整体风格 这种画风区别：不是二次元真实感那种区别，而像梵高和莫奈那种小区别 hYPERNETwORK路径\n绕：设置中找到附加网络\n在这里也可以添加Lora,【坑】但是Lora会有更方便的应用形式 正方形、就可以得到Q版\n多数研究者对于Hypernetwork在图像生成方面的评价并不好，\n至少不如lora和embaddings好，\n也有部分Lora对训练样本的把控实现了对画风的塑造植入。\n尽管如此，超网络在实现特定的风格时，仍然会提供不少的帮助\n{2}embeddings嵌入式向量 优化画风\n.pt\n翻译为：文本嵌入\n有时候网站上叫Textual Inversion文本倒置\n很小的文件——相当于大模型中的书签，指向特定的形象——嵌入式向量 与VAE一样\n使用：只要在输入中输入书签翻字典的过程。 举例： 固定随机种子+embadding的固定咒语——\n更像D.VA——加入描述她身上本身有的东西\n[1]技巧反推提示词 Dva的一张图片导入_图生图\n识别东西，然后转化为AI中的东西DB更具优势。\n每次识别的再筛选——删除降低权重\n**生成图片不可能完全一致，**因为embeddings到头是个几十kb的小文件 只是按图索骥而已。\n所以embaddings适用于一些广泛、容错率高的形象的概念，表现会好很多。 而特定的人物更多的用Lora [坑]CharTurner-embaddings三视图 真NB啊\n使用方法： Eva的和charturner两个embaddings使用——化学反应自己观察 开启高清修复\n[2]embaddings解决手等的问题 只要避开错误案例就可以了 EasyNegative\n放入负面提示词里\n就修复了\n综合的、全方位的基于负面样本的提炼\n灰度，多人、等等\n{3}LoRa 低秩适应模型 固定特定人物角色特征\n作用：有助于向Ai传递/描述某一个特征准确/主体清晰的形象 夹在书中的彩页100-200M\n各方各个方面的素材、角度、画风等\n有些模型会提供触发提示词——训练过程中有基于这个提示词反复强化过AI认知\n也可以加入进行强化效果\n[1]lora会出现一些小问题 因为它的训练图源复杂、\n所以一般也会对画风进行影响\n权重减小\n[坑-深入]有专门为Lora的插件应用。 5.模型下载渠道 midjourney的提供的模型数量有限 默认的模型也能实现挺好的效果，\nSD官方也有1.4、2.0等开源模型 官方的炉在版权和尺度有限制 0.个人训练发布并分享的模型 大多数是“私炉模型” 1.Hugging face使用方法 允许用户共享AI学习模型和数据集的平台\n搜索栏中搜索stable diffusion中可以下载 筛选栏中可以找到\nWaifuDiffusion Anything DreamShop files and version中看源代码 - 大模型在Safey_checker找 - vae就在vae中找 community可以交流 2.C站 iativic.com\n不注册可使用，火热的模型\ntrained的模型 根据图像一点点训练出来的，一手的丹。\nMerged融合模型 几个模型融合到一起创造出来的。一般叫xxxMIx\n【坑】Base model 模型训练过程中的底模\n四、模型的类目及推荐 1.漫画/插画风：二次元 Anything、Counterfeit、Dreamlike Diffusion等 2.真实系 Deliberate、Realistic Vision、LOFI等 3.2.5D风 NeverEnding Dream、Protogen、国风V3 \u0026mdash;- 质感类似于建模软件出来的三维渲染图，不如平面那么平，也不如真实那么真。\n很接近一些游戏和3D动画的想象\nCounterfeit 细节感、精致感、各种复杂室内外场景\nDreamlike Diffusion 漫画插画风\n幻想的超现实魔幻作品\nDeliberate 真实系的,自由度非常高\nRealistic Vision 朴素踏实、有整活空间的写实模型。\n事物、动物图片等\nLOFI-融合模型 人物面部处理精致\nNED模型 造人的方面有一股特殊\nProtogen 国风3\n结合其他lora模型能创作\n4.小类模型 魔幻感场景\n现代建筑 高级感的平面设计\n高清 1.Hi-Res Fix 高清修复/高分辨率修复/\n皮肤分辨率太低人物皮肤模糊、人物面部不真实—— 如果用大分辨率的会有缺点 1.采样次数： 高清修复需要经过一次重绘、因此需要设置采样步数、保持默认0数值、它会和我们设置的采样次数(20)一致\n高清修勾，无法突破显存限制。\n[1]低分抽卡+固定种子+高清修复\n加戏，降低重绘幅度可以消除。\n繁纷复杂的花、多出的戒指等等\n只是高清：0.3-0.5即可\n0.5-0.7——AI重绘空间\n2.放大算法 感觉差不多，没有大到感觉很多区别\n带有GAN的算法，重绘的细节保留更加准确\n同行无脑方法\n无脑R-ESRGAN 4x+\n二次元第二个\n看模型的制作者推荐、或者自己试试。\n小技巧-简便高清方法 图库浏览器中，点击已经号的图片，再点击图生图。\n会自动填写信息\n3.放大算法设置 设置-放大-图生图算法设置\n2.Upscale放大脚本_SD放大 简便方法-\n图块重叠像素64——起到四张图片融合的缓冲带的作用\n高度-宽度分别增加64，\n然后开始。\n画面会混乱\n[1]如果脸在切割的地方 -降低重绘幅度-增大图块重叠度\n3.附加功能放大 人工智能算法修复\n一般成品的算法修复\n也可以不选Upscaler 2\n[2 [坑]下面的三个比较复杂 局部重绘 1.随机种子+咒语修改的问题\n即使随机种子一致，但是咒语还是修改了，出现了画面不可控的样子\n所以会有，不同姿势等问题\n如果是已经经过了高清修复和放大，那么要耗费的时间就更长了\n99%都是满意的，1% 直接点击-局部重绘，其他素材图片也可以 修改咒语+重绘幅度修改\n会出现笔尖，涂抹好重绘区域\n下方参数设置\n重绘过程：整个图片经历了重新加噪然后去噪的过程。\n眼睛部分被强调了，最后的效果是只针对这个区域的重绘了\n局部修复参数 1.蒙版： 可以写填充\n【坑】潜变量噪声、潜变量数值零 简答说：图生图的过程进一步复杂化、加入加噪、去噪的过程。\n理论上对图像的改变会更显著\n2.全图、3.仅蒙版\n2.全图： 基于新的要求（提示词、参数）把图重新画一遍【我觉得受到重绘幅度的影响】，尽管没涂的部分修改很小，但是还是有点点点点\n最后只保留你涂的部分拼回去\n3.仅蒙版: 就是只画框选出来的区域附近，速度快，但是没有基于图像全貌画。然后再拼回去。把这一小块当做一幅画来画。\n[坑]针对性强的修改、反而需要修改图片的尺幅：降低重绘幅度避免变形，并对提示词净化处理。 1.仅蒙版模式的边缘预留像素 4.蒙版模糊——类似羽化 消除硬接触的边缘\n10以下比较好\n太大会影响区域的读取或影响周边其他区域\n区域大可以增大，区域小可以缩小。\n局部重绘进阶 [1]inPaintSketch（手涂蒙版） 调色盘按钮\n修复的坏的手等 加蓝色爱心口罩 调色盘按钮—选黑色—画口罩——\n重绘幅度可以稍大\n蓝色\n咒语中权重降低了，因为咒语的东西复杂了，让它更稳定的产出\n玩法无限可能性大 吸管吸取背景，覆盖手的颜色，然后用肉色把手勾勒出来。\n正向提示词用上，击掌等\n负面提示词中用Negative Embeddings\n1.蒙版透明度 颜色映在图片上的透明度\n降低重绘幅度——因为太大了会让手部线条模糊+蒙版模糊也不宜过大\n如果不满意，那么随机种子多试试。\n单独使用Sketch（绘图） 直接使用Sketch\n然后重新对整个图进做一个完整的图生图，肯定会对原图有影响。\n——灵魂画手功能的实现可以用这个 不想影响就用局部修复即可 [2]上传蒙版功能应用 上传蒙版区域\nPS主体的对象选择工具，框选工具，会自动框选出来，然后套索工具-alt-ctrl-可以增加减少\n然后再\n先定义为白色\n然后选中填充的图层复制一个\n然后双击该图层前面的小白方块、填充颜色改为黑\n单机长方形\n这个长方形就是PS的蒙版了\n选中ctrl+I交换蒙版区域，就黑白换过来了。\n就导出来PNG、jpg就可了。\n人为代替了蒙版选择的了\n[坑]其他软件进行关联，无穷的潜力挖掘 更为精确的手部修复。\n总结 1.SD（Stable Diffusion）基本操作：\n使用菜单选择不同的模型（Checkpoint）。 包括 Lora 模型，提供更精确的人物或画风控制。 2.图生成图：\n上传图片并描述，使用 DeepBooru 算法反推标注。\n调整重绘幅度和分辨率，生成无缝贴图。\n包括聚焦剪裁、中央剪裁等操作，通过观察损失值调整训练过程。\n3.Prompt模板和提示词：\n设计提示词模板，权重分配和增强减弱方法。 4.VAE（Variational Auto Encoder）：\n使用加噪和去噪处理转换潜空间数据为正常图像。 5.Hypernetwork超网络模型：\n改进画面整体风格，与Lora类似但更适合创造新元素。 .6Embeddings嵌入式向量：\n优化画风，通过小文件链接到特定形象。 7.LoRa低秩适应模型：\n固定特定人物角色特征，更清晰地表达形象。 8.模型下载渠道：\nHugging Face、C站等平台获取和共享模型和数据集。 ","date":"2024-06-09T11:54:39Z","image":"http://localhost:1313/post/before/image-20240607184336146.png","permalink":"http://localhost:1313/post/sd/","title":"Stable Diffusion笔记"},{"content":"Typlog 的相册语法 介绍了图像处理中的形态学操作，以及如何使用OpenCV库来执行这些操作。括腐蚀、膨胀、开运算、闭运算、梯度运算、顶帽运算和黑帽运算。每种操作都有不同的效果和应用。\n一、噪声处理的基本操作 1.腐蚀 让图像沿着自己边界向内收缩，OpenCV通过核（kernel）来实现收缩计算。\n在形态学中，可以理解为由N个像素组成的像素块，（每一个像素块，包含一个核（kernel））在图像的边缘移动，移动的过程中，核将会在图像的边缘抹除图像和核（kernel）重合但又没有越过核心（kernel）的像素点抹除。\r例子一、消除仙人掌的刺 import cv2 import numpy as np img =cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((3,3),np.uint8)#3*3矩阵定义核的大小 cv2.imshow( \u0026#34;img\u0026#34;,img) dst=cv2.erode(img,k)#腐蚀 cv2.imshow(\u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllwindows( ) dst=cv2.erode(src,kernel,anchor,iterations,borderType,borderValue) 参数说明: src原始图像 kernel腐蚀使用的核 anchor可选参数 核的锚点位置 iterations可选参数 腐蚀操作的迭代次数，默认值为1，后面两个参数建议采用默认\n2.膨胀 膨胀操作与腐蚀操作相反，膨胀操作可以让图像沿着自己的边界向内扩张。\r同样是通过核来计，当核在图像的边缘移动时，核会将图像边缘填补新的像素\rimport cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((9,9),np.uint8) cv2.imshow( \u0026#34;img\u0026#34;,img) dst=cv2.dilate(img, k) cv2.imshow( \u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllwindows() ​```Python dst=cv2.dilate(src,kernel,anchor,iterations,borderType,borderValue)\\ 参数说明如下\nsrc原始图像 kernel膨胀使用的核 anchor可选参数核的锚点位置 iterations可选参数膨胀操作的迭代次数 后面两个为可选参数建议取默认值\n膨胀可以产生一种“近视眼”的效果。\n3.开运算 开运算是将图像先进行腐蚀操作，再进行膨胀操作。\r开运算可以用来抹除图像外部的细节。\n#开运算 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\tzzy.png\u0026#34;) k=np.ones((6,6),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img \u0026#34; ,img) dst=cv2.erode(img,k)#腐蚀操作 dst=cv2.dilate(dst,k)#膨胀操作 cv2.imshow( \u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllWindows() 4.闭运算 闭运算是将图像先进行膨胀操作，再进行腐蚀操作。\r闭运算可以抹除图像内部的细节。\n#闭运算 import cv2 import numpy as np img = cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img, (900, 900)) k = np.ones((9,9),np.uint8) cv2.imshow(\u0026#34;img\u0026#34;,img) dst = cv2.dilate(img,k) dst = cv2.erode(dst,k) cv2.imshow(\u0026#34;dst2\u0026#34;,dst) cv2.waitKey() cv2.destroyAllWindows() 二、形态学其他方法： 腐蚀和膨胀都是形态学的基础操作，开运算和闭运算是两种方法的运用。除了这两种方法外，形态学还有集中比较有特点的运算，OpenCV提供了一个morphologyEx方法\r英 [mɔːˈfɒlədʒi] 美 [mɔːrˈfɑːlədʒi]\nmorphologyEx(src,op,kernel,anchor) src 原始图像\nop 操作类型\nkernel 操作过程中使用的核\nanchor 核锚点的位置\n操作类型如下：\n参数值 含义 cv2.MORPH_ERODE 腐蚀操作 cv2.MORPH_DILATE 膨胀操作 cv2.MORPH_OPEN 开运算，先腐蚀后膨胀 cv2.MORPH_CLOSE 闭运算，先膨胀后腐蚀 cv2.MORPH_GRADIENT 梯度运算，膨胀图减腐蚀图 cv2.MORPH_TOPHAT 顶帽运算，原始图减开运算图 cv2.MORPH_BLACKHAT 黑帽运算，闭运算图减原始图 1.梯度运算 梯度是指图像梯度，可以简单理解为像素的变化程度。几个连续的像素，像素的跨度值越大，梯度值就越大。\r梯度运算就是，膨胀图减去腐蚀图，就是将扩张的膨胀图挖去收缩过的腐蚀图。\r梯度运算可以得到原图的轮廓。\n#梯度运算，得到简笔画的轮廓 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img,(600,600)) k=np.ones((5,5),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img\u0026#34; ,img) #进行梯度运算 dst=cv2.morphologyEx(img,cv2.MORPH_GRADIENT,k) cv2.imshow( \u0026#34;dst\u0026#34; ,dst)#显示梯度运算结果 cv2.waitKey() cv2.destroyAllwindows( ) 兔子为实心线条，膨胀-腐蚀后，所以会在兔子周围形成两条线。\n2.顶帽运算 原图减去原图的开运算图，就是用有细节的原图挖去去除外部细节的开运算图。也就是只剩下外部细节的图。\r顶帽运算=原图-开运算图形=外部细节图\n#顶帽运算，原图减开运算图 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((10,10),np.uint8) cv2.imshow( \u0026#34;img\u0026#34; ,img) dst=cv2.morphologyEx(img,cv2.MORPH_TOPHAT,k) cv2.imshow( \u0026#34;dst\u0026#34; ,dst) cv2.waitKey() cv2.destroyAllwindows() 3.黑帽运算 原图的闭运算减去原图，也就是去除内部细节的图挖去有内部细节的原图，只剩内部细节。\r黑帽运算=原图像-闭运算图像=内部细节图\n#黑帽运算 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img,(600,600)) k=np.ones((3,3),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img\u0026#34; ,img) #进行黑帽运算 dst=cv2.morphologyEx(img, cv2.MORPH_BLACKHAT,k) cv2.imshow( \u0026#34;dst\u0026#34;,dst)#显示黑帽运算结果 cv2.waitKey() cv2.destroyAllwindows() 三、总结 腐蚀操作：通过核来缩小图像中的对象，用于去除小细节或分离连接的对象。\n膨胀操作：通过核来扩大图像中的对象，用于填充空洞或连接对象。\n开运算：先腐蚀后膨胀，用于去除小物体，平滑边界，分离物体。\n闭运算：先膨胀后腐蚀，用于填充小孔，连接物体。\n梯度运算：膨胀图减腐蚀图，用于提取物体的边界。\n顶帽运算：原图减开运算图，用于提取图像中的细节。\n黑帽运算：闭运算图减原图，用于提取图像中的内部细节。\n这些形态学操作可以用于图像增强、去噪、分割和特征提取等应用。通过适当选择和组合这些操作，可以实现多种图像处理效果。\r","date":"2023-11-06T21:14:39Z","image":"http://localhost:1313/post/cover/tag-opencv.jpg","permalink":"http://localhost:1313/post/opencv/","title":"OpenCV中对图像噪声处理的常用形态学操作"},{"content":"流操作 是Java 8中引入的一种数据处理模式，通常涉及数据的读取、写入、转换、过滤等，这些操作可以在数据流上连续进行，形成一条处理链。\n例如：stream() 方法是 Java 8 引入的 Stream API 的一部分，它用于将集合（如数组、列表等）转换为流（Stream）。\n例如：能用max()和min()对流操作找到流中的最大元素。\n[参数:可用Comparator接口自定义比较的逻辑]\nimport java.util.Arrays; import java.util.Optional; import java.util.Comparator; public class StreamExample { public static void main(String[] args) { Integer[] numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5}; // 使用默认比较器找到最大元素 Optional\u0026lt;Integer\u0026gt; max = Arrays.stream(numbers).max(); max.ifPresent(System.out::println); // 输出：9 // 使用默认比较器找到最小元素 Optional\u0026lt;Integer\u0026gt; min = Arrays.stream(numbers).min(); min.ifPresent(System.out::println); // 输出：1 // 使用自定义比较器找到最大元素（基于绝对值） Optional\u0026lt;Integer\u0026gt; maxAbs = Arrays.stream(numbers).max(Comparator.comparingInt(Math::abs)); maxAbs.ifPresent(System.out::println); // 输出：9 或 -5取决于绝对值的比较 } } 其中Optional\nOptional是Java8中引入的容器类，可以包含Integer对象或不含任何对象(空)。\n程序员可以避免在代码中出现大量的空值判断，从而减少了if-else控制判断的使用，提高了代码的健壮性和可读性。\n避免NullPointerException\n流操作的主要目的是简化数据处理和提高代码的可读性。通过使用流，程序员可以链式地应用一系列的操作，\n如过滤、映射、归约等，以实现对数据的转换和聚合。流操作还支持并行处理，可以充分利用多核处理器的优势，提高数据处理的速度。\n函数式编程 import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class FunctionalOperationExample { public static void main(String[] args) { // 创建一个整数列表 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 使用Stream API进行函数式操作 List\u0026lt;Integer\u0026gt; squaredEvenNumbers = numbers.stream() // 将列表转换为流 .filter(n -\u0026gt; n % 2 == 0) // 过滤出偶数 .map(n -\u0026gt; n * n) // 将每个偶数平方 .collect(Collectors.toList()); // 收集结果到新的列表 // 输出结果 squaredEvenNumbers.forEach(System.out::println); } } 整个操作链以声明性的方式描述了我们的意图：找到所有偶数并将它们平方。\n我们不需要显式地编写循环或条件语句，函数式操作提供了一种更加简洁、高效和可维护的编程方式。\n流式编程的声明性主要体现在其通过一系列的操作来定义数据的转换和聚合过程，而无需显式地编写复杂的控制流代码。这使得代码更加简洁、易于理解，并且关注点更集中于数据的处理逻辑，而非流程控制。\n下面是一个使用Java 8 Stream API进行流式编程的示例，该示例体现了流式编程的声明性：\n假设我们有一个包含员工信息的列表，每个员工都有姓名（String）和薪水（double）两个属性。我们想要找出薪水最高的员工。\n首先，我们定义一个简单的Employee类：\npublic class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public String getName() { return name; } public double getSalary() { return salary; } @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, salary=\u0026#34; + salary + \u0026#39;}\u0026#39;; } } 接下来，我们创建一个包含多个Employee对象的列表，并使用流式编程找出薪水最高的员工：\nimport java.util.Arrays; import java.util.List; import java.util.Optional; public class DeclarativeStreamingExample { public static void main(String[] args) { // 创建一个员工列表 List\u0026lt;Employee\u0026gt; employees = Arrays.asList( new Employee(\u0026#34;Alice\u0026#34;, 50000), new Employee(\u0026#34;Bob\u0026#34;, 60000), new Employee(\u0026#34;Charlie\u0026#34;, 45000), new Employee(\u0026#34;David\u0026#34;, 70000) ); // 使用流式编程找出薪水最高的员工 Optional\u0026lt;Employee\u0026gt; highestPaidEmployee = employees.stream() // 转换为流 .max((e1, e2) -\u0026gt; Double.compare(e1.getSalary(), e2.getSalary())); // 根据薪水比较员工 // 处理结果 highestPaidEmployee.ifPresent(emp -\u0026gt; { System.out.println(\u0026#34;Highest paid employee is: \u0026#34; + emp); }); } } 在这个例子中，我们使用了stream()方法将员工列表转换为一个流。然后，我们调用了max()方法，并传入了一个lambda表达式作为比较器，用于比较两个员工的薪水。max()方法会返回一个Optional对象，它可能包含薪水最高的员工（如果存在的话）。最后，我们使用ifPresent()方法来处理找到的员工（如果存在）。\n这个例子体现了流式编程的声明性，因为我们没有编写显式的循环或条件语句来遍历列表和比较元素。相反，我们通过调用一系列的方法（stream(), max(), ifPresent()）并传入必要的函数式接口实例（lambda表达式）来声明我们的意图。这种方式使得代码更加简洁和易于理解，同时也更容易进行扩展和修改。\n","date":"2023-03-28T11:08:00Z","image":"http://localhost:1313/post/cover/archives-java.png","permalink":"http://localhost:1313/post/java/","title":"流操作和函数式编程"},{"content":"产品上把大模型的缺点规避掉了 错误生成有错误了，参考的文档中设置答案。\n准确性患者的问题，\n上传题库—生成的内容是虚假的（向量数据库进行检索）——具体的prompt生\n最小demo实现！ 个人知识库——关键字——对比——\n爱好语音输入？文盲，只会说不会写\n文字 视频长、大、处理有瓶颈\nchatGLM抽取关键词和词频\n分析在线/离线视屏解析，文字转写，\n在线直播\n不断递归式的抽摘要。\n十条结果，然后展示，\n视屏——文字——关键词+词云图\n多模态、想法很重要。\n调研优秀项目和协调个人想法。\n功能多，产品形态上。\n大视频，文本解析的好的方案？\n1.whisper\n2.加速方案\n七分钟用的2080ti显卡，30s解析。\n会议视屏长，直播撰写，实时的转写——提升撰写的效果。\n最小demo实现！！ 核心思路：先堆免费有资源的能力、再做更多稳定性和UI的考虑\n一定是一个输入输出的结果。\n目前掌握：\ntask1：智能编程助手\n问答最小demo\ntask3：AI科研助手\n上传PDF——解析PDF——拼接摘要Prompt—到大模型—输出给用户：\n根据提问——Embedding和Faiss检索chunks——用户请求拼接Prompt—到大模型—结构输出给用户\n客户端接收到用户上传的PDF后，发送到服务端。服务端首先完成PDF内容解析，然后拼接摘要Prompt并输入源大模型，得到模型输出结果后，返回给客户端并展示给用户。\n如果用户接下来进行提问，客户端将用户请求发送到服务端，服务端进行Embedding和Faiss检索，然后将检索到的chunks与用户请求拼接成Prompt并输入到源大模型，得到模型输出结果后，返回给客户端进行结构化，然后展示给用户。\n关键词提取 从论文中提取关键概念和术语，帮助用户快速了解研究重点。 x月x日 论文对比 比较两篇或者多篇论文的内容，总结他们之间的异同点。 x月x日 相关工作推荐 根据用户的兴趣领域推荐相关的最新研究成果。 x月x日 扩展功能： 1.视屏录像摘要，词云图——实时视屏摘要助手\n2.导入的文档作为题目，给出正确选项——刷题助手？\n3.\n想法： Joe-2002/LinChance_GPT: 本项目致力于打造数智化平台级智能人机交互产品，结合智能知识库和知识检索的功能，满足高效运行和优质服务的需求。 (github.com)\n算法含量也很高\n使用lora微调\n交互逻辑\n语言模型——十万个为什么——（实体gai）段文本少儿科普内容——打印卡片——版权ying\n剧情卡片，多张卡片交互，组合几何级数的。语言模型能为。\n传统早教机不可能为每种卡片设置不同的台词——补全每种组合的信息，产生创意性的句子进行学习\n实体玩具的识别，注册实体玩具的识别，任意。\n版权方面，实体玩具，古生物不容易被拍摄到的。\n键盘版的demo\n旋转位移放缩，泛化能力\nA-B的映射\n传统计算机映射——学生掌握的很好。\n更强的迁移学习的能力，以前是数据标注\n计算机及图形学，NeRF神经辐射场\n社会不是随机的，按劳分配\nAnki卡片制作，艾宾浩斯遗忘曲线，单词\n数据分布在二维三维的空间上，\n正样本和负样本，线性，\n数据是高维空间的数据流行\n二维纸的数据，一条线，（判别模型）延展为到三维一个面。\n延展的数据一般是错的真实的数据。\n生成模型会对样本的分布有更好的认知。\n生成模型：\n1.采样功能：数据中抽样中抽样出很像的数据\n2.判别一个：数据在不在一个分布里。\n过往的，例子：\n不是\ncat cat cat\nI play guitar.概率更高\n主谓宾\ncat eat me\ncat teach me\n错误的\n考虑下一次的概率\n统计概率\n后面更聪明的模型\n隐函数：记忆\nlstm rnn\n告诉我要开始一个句子\n输出一个次\n再放入记忆\n根据上一次的记忆和字再生成\u0026hellip;\n最终eos终止符\n一层rnn，lstm的模型\n多层，正过来反过来，9层十几层的模型。\nattention技术，考虑某个词的时候，不止来自前一个记忆，先做判断跟之前的词哪个更相关，\nattention+lstm=transforomer\n9-12层，\nGTP创新、-归一化的层，基础的原理是这样，词是以序列化输入，\n4000-8000浮点数\n图片生成 英语学习，网站过往的图片和生成的词。\ncollab工具\n想出来的话生成图。\n中文模型，clip模型没到。\n扩散模型： 随机采样向量和图片对应的，\n深度学习后的去噪的能力很强的。\n除以信噪比越来越低，反过来深度学习是可以学习的。\n噪音还原为原图。\n如果我数据是高维空间的高位流行。\n通过随机过程拉出diwei流行，Gan对抗生成，\n姚期智GAN。\nDiffusion背后的CLIP，\nZero-Shot Learning\n句子和图编码为特征——图和句子的点乘比较大的。\n把类别编码为句子，看图片的句子和句子之间的相似。\n是很可怕的。零样本点学习。\n黄色香蕉——绿色香蕉，迁移很强的。\n深度学习特征和直方图特征有什么不一样？\n传统颜色相近的，深度学习是语义相近的。\n以图搜图。\n最近邻分类。\n迁移到另一个领域是非常强的。\nClip模型成功将语言和图片进行关联。\nGTP4迁移进去，特征空间人脸编码到表情空间，\n表情空间解码为不同的人，实现人脸的驱动。\nClip用了\n数据集\n都能识别出来的。1h筛1000个出来，2-10w张图。\n10-100h小时标注，训练工业级。\n新时代的工业检测会有很大改变的。\n科创评委角度，加入到新的。\ncahtgtp和copliot实时演示。初步做实验飞擦汗有效的。\nGTP3的时候，openai和github合作，\n重构一个东西，\n新版信息技术提纲，写了爬虫。\npython的爬虫，climper。\n摄像机转换，\nnoit普及组的考试的。\n偏上，偏下，偏左，偏右。\n长的文本效果不是很好。\n单元测试代码，\npygame\npymank\n物理\n不到2h实现，沟通成本过高，今天这个角度。\n新的工具产生， 新的工作流也会实现。\n王天一，积分第一的选手。\n每周一两次课，每周一两小时。\nOpenai,第五代编程语言\n自然语言去操控编程。\n前沿科技，辅助代码\n需要能说清楚程序需求和输入输出，程序需求。\n关注代码细节。买了接口，整体实现一个应用，分解，分布，核心算法部分研究的，向评委展示。\n容易关注代码的细节，人均的实现能力\n正面：10个人干更多的事情。\n负面：外包，接受外包会有更大的需求。\nmonk物理的模拟。\n标完数据，传统数据流。\ncolab\n普通用户，\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E4%BA%A7%E5%93%81%E4%BA%A4%E6%B5%81/","title":""},{"content":"1.大模型应用开发——Datawhale\n2.吴恩达的课程学习——骆驼先知LC1332/Prophet-Andrew-Ng: 李鲁鲁老师对 吴恩达《ChatGPT Prompt Engineering for Developers》课程中文版的实践 (github.com)\n【骆驼读论文】关于Andrew Ng的prompt工程课程的实践，为GPT编写更准确而多样的提示词 - 知乎 (zhihu.com)\n3.大模型应用开发——简单应用\n可以用到骆驼这个开源的模型，进行embadding处理。\nLuotuo-Text-Embedding/report.md at main · LC1332/Luotuo-Text-Embedding (github.com)\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E5%90%B4%E6%81%A9%E8%BE%BE%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E9%AA%86%E9%A9%BC%E5%85%88%E7%9F%A5/","title":""}]