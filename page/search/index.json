[{"content":"建站回顾 1. 域名 正在ICP备案,预计7个工作日后能拿到备案的域名。慢慢来吧\n2. 服务器 腾讯云服务器，40G, 1M带宽，1核2G内存。\n3. 博客框架 暂时用的Hugo，建站很快。\n历程 框架选来选去，之前用过Hexo主题,但是时间过于久远。这次想在云服务器上运行，遂重新开始。框架从Hexo到Halo到Hugo。 原本在Linux上安装Hexo得心应手，但这次在CentOS7.6并不支持Nodejs8,支持不了最新的Hexo主题,又转为Halo， Halo苦于教程少啊,而且Hugo整体还是很方便,比较下来Hexo的教程\u0026gt;Hugo\u0026gt;Halo，最终确定了Hugo框架。 现在网站搭起来了，后续慢慢再更新文章~~。 ","date":"2024-07-19T21:14:39Z","permalink":"http://localhost:1313/post/%E9%9A%8F%E7%AC%94/","title":"随笔"},{"content":"Typlog 的相册语法 介绍了图像处理中的形态学操作，以及如何使用OpenCV库来执行这些操作。括腐蚀、膨胀、开运算、闭运算、梯度运算、顶帽运算和黑帽运算。每种操作都有不同的效果和应用。\n一、噪声处理的基本操作 1.腐蚀 让图像沿着自己边界向内收缩，OpenCV通过核（kernel）来实现收缩计算。\n在形态学中，可以理解为由N个像素组成的像素块，（每一个像素块，包含一个核（kernel））在图像的边缘移动，移动的过程中，核将会在图像的边缘抹除图像和核（kernel）重合但又没有越过核心（kernel）的像素点抹除。\r例子一、消除仙人掌的刺 import cv2 import numpy as np img =cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((3,3),np.uint8)#3*3矩阵定义核的大小 cv2.imshow( \u0026#34;img\u0026#34;,img) dst=cv2.erode(img,k)#腐蚀 cv2.imshow(\u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllwindows( ) dst=cv2.erode(src,kernel,anchor,iterations,borderType,borderValue) 参数说明: src原始图像 kernel腐蚀使用的核 anchor可选参数 核的锚点位置 iterations可选参数 腐蚀操作的迭代次数，默认值为1，后面两个参数建议采用默认\n2.膨胀 膨胀操作与腐蚀操作相反，膨胀操作可以让图像沿着自己的边界向内扩张。\r同样是通过核来计，当核在图像的边缘移动时，核会将图像边缘填补新的像素\rimport cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((9,9),np.uint8) cv2.imshow( \u0026#34;img\u0026#34;,img) dst=cv2.dilate(img, k) cv2.imshow( \u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllwindows() ```Python dst=cv2.dilate(src,kernel,anchor,iterations,borderType,borderValue)\\ 参数说明如下\nsrc原始图像 kernel膨胀使用的核 anchor可选参数核的锚点位置 iterations可选参数膨胀操作的迭代次数 后面两个为可选参数建议取默认值\n膨胀可以产生一种“近视眼”的效果。\n3.开运算 开运算是将图像先进行腐蚀操作，再进行膨胀操作。\r开运算可以用来抹除图像外部的细节。\n#开运算 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\tzzy.png\u0026#34;) k=np.ones((6,6),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img \u0026#34; ,img) dst=cv2.erode(img,k)#腐蚀操作 dst=cv2.dilate(dst,k)#膨胀操作 cv2.imshow( \u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllWindows() 4.闭运算 闭运算是将图像先进行膨胀操作，再进行腐蚀操作。\r闭运算可以抹除图像内部的细节。\n#闭运算 import cv2 import numpy as np img = cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img, (900, 900)) k = np.ones((9,9),np.uint8) cv2.imshow(\u0026#34;img\u0026#34;,img) dst = cv2.dilate(img,k) dst = cv2.erode(dst,k) cv2.imshow(\u0026#34;dst2\u0026#34;,dst) cv2.waitKey() cv2.destroyAllWindows() 二、形态学其他方法： 腐蚀和膨胀都是形态学的基础操作，开运算和闭运算是两种方法的运用。除了这两种方法外，形态学还有集中比较有特点的运算，OpenCV提供了一个morphologyEx方法\r英 [mɔːˈfɒlədʒi] 美 [mɔːrˈfɑːlədʒi]\nmorphologyEx(src,op,kernel,anchor) src 原始图像\nop 操作类型\nkernel 操作过程中使用的核\nanchor 核锚点的位置\n操作类型如下：\n参数值 含义 cv2.MORPH_ERODE 腐蚀操作 cv2.MORPH_DILATE 膨胀操作 cv2.MORPH_OPEN 开运算，先腐蚀后膨胀 cv2.MORPH_CLOSE 闭运算，先膨胀后腐蚀 cv2.MORPH_GRADIENT 梯度运算，膨胀图减腐蚀图 cv2.MORPH_TOPHAT 顶帽运算，原始图减开运算图 cv2.MORPH_BLACKHAT 黑帽运算，闭运算图减原始图 1.梯度运算 梯度是指图像梯度，可以简单理解为像素的变化程度。几个连续的像素，像素的跨度值越大，梯度值就越大。\r梯度运算就是，膨胀图减去腐蚀图，就是将扩张的膨胀图挖去收缩过的腐蚀图。\r梯度运算可以得到原图的轮廓。\n#梯度运算，得到简笔画的轮廓 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img,(600,600)) k=np.ones((5,5),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img\u0026#34; ,img) #进行梯度运算 dst=cv2.morphologyEx(img,cv2.MORPH_GRADIENT,k) cv2.imshow( \u0026#34;dst\u0026#34; ,dst)#显示梯度运算结果 cv2.waitKey() cv2.destroyAllwindows( ) 兔子为实心线条，膨胀-腐蚀后，所以会在兔子周围形成两条线。\n2.顶帽运算 原图减去原图的开运算图，就是用有细节的原图挖去去除外部细节的开运算图。也就是只剩下外部细节的图。\r顶帽运算=原图-开运算图形=外部细节图\n#顶帽运算，原图减开运算图 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((10,10),np.uint8) cv2.imshow( \u0026#34;img\u0026#34; ,img) dst=cv2.morphologyEx(img,cv2.MORPH_TOPHAT,k) cv2.imshow( \u0026#34;dst\u0026#34; ,dst) cv2.waitKey() cv2.destroyAllwindows() 3.黑帽运算 原图的闭运算减去原图，也就是去除内部细节的图挖去有内部细节的原图，只剩内部细节。\r黑帽运算=原图像-闭运算图像=内部细节图\n#黑帽运算 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img,(600,600)) k=np.ones((3,3),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img\u0026#34; ,img) #进行黑帽运算 dst=cv2.morphologyEx(img, cv2.MORPH_BLACKHAT,k) cv2.imshow( \u0026#34;dst\u0026#34;,dst)#显示黑帽运算结果 cv2.waitKey() cv2.destroyAllwindows() 三、总结 腐蚀操作：通过核来缩小图像中的对象，用于去除小细节或分离连接的对象。\n膨胀操作：通过核来扩大图像中的对象，用于填充空洞或连接对象。\n开运算：先腐蚀后膨胀，用于去除小物体，平滑边界，分离物体。\n闭运算：先膨胀后腐蚀，用于填充小孔，连接物体。\n梯度运算：膨胀图减腐蚀图，用于提取物体的边界。\n顶帽运算：原图减开运算图，用于提取图像中的细节。\n黑帽运算：闭运算图减原图，用于提取图像中的内部细节。\n这些形态学操作可以用于图像增强、去噪、分割和特征提取等应用。通过适当选择和组合这些操作，可以实现多种图像处理效果。\r","date":"2023-11-06T21:14:39Z","image":"http://localhost:1313/tag-opencv.jpg","permalink":"http://localhost:1313/post/opencv/","title":"OpenCV中对图像噪声处理的常用形态学操作"},{"content":"流操作 是Java 8中引入的一种数据处理模式，通常涉及数据的读取、写入、转换、过滤等，这些操作可以在数据流上连续进行，形成一条处理链。\n例如：stream() 方法是 Java 8 引入的 Stream API 的一部分，它用于将集合（如数组、列表等）转换为流（Stream）。\n例如：能用max()和min()对流操作找到流中的最大元素。\n[参数:可用Comparator接口自定义比较的逻辑]\nimport java.util.Arrays; import java.util.Optional; import java.util.Comparator; public class StreamExample { public static void main(String[] args) { Integer[] numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5}; // 使用默认比较器找到最大元素 Optional\u0026lt;Integer\u0026gt; max = Arrays.stream(numbers).max(); max.ifPresent(System.out::println); // 输出：9 // 使用默认比较器找到最小元素 Optional\u0026lt;Integer\u0026gt; min = Arrays.stream(numbers).min(); min.ifPresent(System.out::println); // 输出：1 // 使用自定义比较器找到最大元素（基于绝对值） Optional\u0026lt;Integer\u0026gt; maxAbs = Arrays.stream(numbers).max(Comparator.comparingInt(Math::abs)); maxAbs.ifPresent(System.out::println); // 输出：9 或 -5取决于绝对值的比较 } } 其中Optional\nOptional是Java8中引入的容器类，可以包含Integer对象或不含任何对象(空)。\n程序员可以避免在代码中出现大量的空值判断，从而减少了if-else控制判断的使用，提高了代码的健壮性和可读性。\n避免NullPointerException\n流操作的主要目的是简化数据处理和提高代码的可读性。通过使用流，程序员可以链式地应用一系列的操作，\n如过滤、映射、归约等，以实现对数据的转换和聚合。流操作还支持并行处理，可以充分利用多核处理器的优势，提高数据处理的速度。\n函数式编程 import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class FunctionalOperationExample { public static void main(String[] args) { // 创建一个整数列表 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 使用Stream API进行函数式操作 List\u0026lt;Integer\u0026gt; squaredEvenNumbers = numbers.stream() // 将列表转换为流 .filter(n -\u0026gt; n % 2 == 0) // 过滤出偶数 .map(n -\u0026gt; n * n) // 将每个偶数平方 .collect(Collectors.toList()); // 收集结果到新的列表 // 输出结果 squaredEvenNumbers.forEach(System.out::println); } } 整个操作链以声明性的方式描述了我们的意图：找到所有偶数并将它们平方。\n我们不需要显式地编写循环或条件语句，函数式操作提供了一种更加简洁、高效和可维护的编程方式。\n流式编程的声明性主要体现在其通过一系列的操作来定义数据的转换和聚合过程，而无需显式地编写复杂的控制流代码。这使得代码更加简洁、易于理解，并且关注点更集中于数据的处理逻辑，而非流程控制。\n下面是一个使用Java 8 Stream API进行流式编程的示例，该示例体现了流式编程的声明性：\n假设我们有一个包含员工信息的列表，每个员工都有姓名（String）和薪水（double）两个属性。我们想要找出薪水最高的员工。\n首先，我们定义一个简单的Employee类：\npublic class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public String getName() { return name; } public double getSalary() { return salary; } @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, salary=\u0026#34; + salary + \u0026#39;}\u0026#39;; } } 接下来，我们创建一个包含多个Employee对象的列表，并使用流式编程找出薪水最高的员工：\nimport java.util.Arrays; import java.util.List; import java.util.Optional; public class DeclarativeStreamingExample { public static void main(String[] args) { // 创建一个员工列表 List\u0026lt;Employee\u0026gt; employees = Arrays.asList( new Employee(\u0026#34;Alice\u0026#34;, 50000), new Employee(\u0026#34;Bob\u0026#34;, 60000), new Employee(\u0026#34;Charlie\u0026#34;, 45000), new Employee(\u0026#34;David\u0026#34;, 70000) ); // 使用流式编程找出薪水最高的员工 Optional\u0026lt;Employee\u0026gt; highestPaidEmployee = employees.stream() // 转换为流 .max((e1, e2) -\u0026gt; Double.compare(e1.getSalary(), e2.getSalary())); // 根据薪水比较员工 // 处理结果 highestPaidEmployee.ifPresent(emp -\u0026gt; { System.out.println(\u0026#34;Highest paid employee is: \u0026#34; + emp); }); } } 在这个例子中，我们使用了stream()方法将员工列表转换为一个流。然后，我们调用了max()方法，并传入了一个lambda表达式作为比较器，用于比较两个员工的薪水。max()方法会返回一个Optional对象，它可能包含薪水最高的员工（如果存在的话）。最后，我们使用ifPresent()方法来处理找到的员工（如果存在）。\n这个例子体现了流式编程的声明性，因为我们没有编写显式的循环或条件语句来遍历列表和比较元素。相反，我们通过调用一系列的方法（stream(), max(), ifPresent()）并传入必要的函数式接口实例（lambda表达式）来声明我们的意图。这种方式使得代码更加简洁和易于理解，同时也更容易进行扩展和修改。\n","date":"2023-03-28T11:08:00Z","image":"http://localhost:1313/java.png","permalink":"http://localhost:1313/post/java/","title":"流操作和函数式编程"}]