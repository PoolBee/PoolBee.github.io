[{"content":"Datawhale AI夏令营第四期大模型应用开发-Task01 首先了解一些背景知识。\n一、什么是大模型 语言模型发展历史 语言模型：为了对人类语言的内在规律进行建模，研究者们提出使用语言模型（language model）来准确预测词序列中 下一个词 或者 缺失的词 的概率。\n统计语言模型：使用马儿可夫假设，假设当前词与之前的词产生联系。\n中文中，建立n元语言模型，n元作为最小的语义单元进行建模\n神经语言模型\n上下文 统计语言模型（Statistical Language Model, SLM）：使用马尔可夫假设（Markov Assumption）来建模语言序列的 𝑛 元（𝑛-gram）语言模型\n神经语言模型（Neural Language Model, NLM）：基于神经网络构建语言模型，如循环神经网络（Recurrent Neural Networks, RNN），并学习上下文相关的词表示（即分布式词向量），也被称为词嵌入（Word Embedding）。代表性工作：word2vec\n预训练语言模型（Pre-trained Language Model, PLM）：使用大量的无标注数据预训练双向 LSTM（Bidirectional LSTM, biLSTM）或者Transformer，然后在下游任务上进行微调（Fine-Tuning）。代表性工作：ELMo、BERT、GPT-1/2\n双向lstm是在RNN基础上进行改进的模型 Transformer，使用多层自注意力结构的模型 无标注数据：数据没有任何人标注，数据自监督的方式进行学习- 形成了预训练微调的范式 大语言模型（Large Language Model, LLM）：基于“扩展法则”（Scaling Law），即通过增加模型参数或训练数据，可以提升下游任务的性能，同时具有小模型不具有的“涌现能力”（Emergent Abilities）。代表性工作：GPT-3、ChatGPT、Claude、Llama\n二、大模型是怎么构建的（三个阶段） 大模型的构建过程可以分为预训练（Pretraining）、有监督微调（Supervised Fine-tuning, SFT）、基于人类反馈的强化学习对齐（Reinforcement Learning from Human Feedback, RLHF）三个阶段。\n1.预训练（Pretraining） 使用海量的数据进行模型参数的初始学习，旨在为模型参数寻找到一个优质的“起点”。 (1)预训练技术的发展 ​\t这一概念最初在计算机视觉领域萌芽，通过在ImageNet（一个大型图像数据集）上的训练，为模型参数奠定了坚实的基础。\n​\t后来在自然语言处理（NLP）领域使用，word2vec开创先河，利用未标注文本构建词嵌入模型；ELMo、BERT及GPT-1则进一步推动了**“预训练-微调”范式**的普及。\n​\t起初，只用于解决特定类别的下游任务；例如文本分类、序列标注、序列到序列生成等传统NLP任务。\n​\t之后，GPT-2——通过大规模文本数据预训练：打造能够应对广泛任务的通用解决方案，并在GPT-3中将这一理念扩展至前所未有的超大规模。\n在BERT等早期预训练模型中，模型架构和训练任务呈现出多样化特征。然而，随着GPT系列模型的兴起，“解码器架构+预测下一个词”的策略证明了其卓越效能，成为了当前主流的大模型技术路线。 (2)预训练的过程 搜集和清洗文本数据 ​\t首要任务是搜集和清洗海量的文本数据，确保剔除潜在的有害内容。获取高质、多元的数据集，并对其进行严谨的预处理。\n​\t鉴于模型的知识库几乎完全源自训练数据，数据的质量与多样性对模型性能至关重要。这是打造高性能语言模型的关键步骤。\n​\t当前，多数开源模型的预训练均基于数T的token。\n大模型 token 计算资源需求 Llama-1 1T 2,048块A100 80GB GPU三周 Llama-2 2T Llama-3 15T ​\t除了对数据量的苛刻要求，预训练阶段对计算资源的需求也极为庞大。以Llama-1的65B参数模型为例，其在2,048块A100 80GB GPU集群上进行了接近三周的训练。\n训练及细节 此外，预训练过程中还涉及诸多细节，诸如数据配比、学习率调度、模型行为监测等，这些往往缺乏公开的最佳实践指导，需要研发团队具备深厚的训练经验与故障排查能力，以规避训练过程中的回溯与重复迭代，节约计算资源，提高训练效率。 ​\t总体而言，预训练不仅是一项技术挑战，更是一场对数据质量、算力投入与研发智慧的综合考验。\n2.有监督微调（Supervised Fine-tuning, SFT）或**指令微调(instruction tuning) 预训练模型能力限制 大规模预训练后，模型已经具备较强的模型能力，能够编码丰富的世界知识，但是由于预训练任务形式所限，\n这些模型更擅长于文本补全，并不适合直接解决具体的任务。\n尽管引入了诸如上下文学习（In-Context Learning, ICL）等提示学习策略以增强模型的适应性，但模型本身在下游任务解决上的能力仍受限。为了克服这一局限，预训练后的大型语言模型往往需经历微调过程，以提升其在特定任务中的表现。\n目前来说，比较广泛使用的微调技术是“有监督微调”（也叫做指令微调，Instruction Tuning）：该方法利用成对的任务输入与预期输出数据，训练模型学会以问答的形式解答问题，从而解锁其任务解决潜能。\n经过指令微调后，大语言模型能够展现出较强的指令遵循能力，可以通过零样本学习的方式解决多种下游任务。\n指令微调更多地扮演着催化剂的角色，激活模型内在的潜在能力，而非单纯地灌输信息。**\nSFT的优点 相较于预训练所需的海量数据，指令微调所需数据量显著减少，从几十万到上百万条不等的数据，均可有效激发模型的通用任务解决能力，甚至有研究表明，少量高质量的指令数据（数千至数万条）亦能实现令人满意的微调效果。这不仅降低了对计算资源的依赖，也提升了微调的灵活性与效率。\n3.基于人类反馈的强化学习对齐 除了提升任务的解决能力外，大语言模型与**人类期望、需求及价值观的对齐（Alignment）**至关重要，这对于大模型的应用具有重要的意义。\nInstructGPT论文提出 InstructGPT论文解读 - 知乎 (zhihu.com)OpenAI在 2022 年初发布\n​\t详尽阐述了如何实现语言模型与人类对齐。论文提出了基于人类反馈的强化学习对齐（Reinforcement Learning from Human Feedback, RLHF），通过指令微调后的强化学习，提升模型的人类对齐度。RLHF的核心在于构建一个反映人类价值观的奖励模型（Reward Model）。这一模型的训练依赖于专家对模型多种输出的偏好排序，通过偏好数据训练出的奖励模型能够有效评判模型输出的质量。\n其他简化方法 ​\t目前还有很多工作试图去除复杂的强化学习算法，或其他使用 SFT 方式来达到与 RLHF 相似的效果，从而简化模型的对齐过程。\n直接偏好优化（Direct Preference Optimization, DPO），它通过与有监督微调相似的复杂度实现模型与人类对齐，是一种典型的不需要强化学习的对齐算法。相比RLHF，DPO不再需要在训练过程中针对大模型进行采样，同时超参数的选择更加容易。 最后，我们以开源大模型Llama-2-Chat为例，简要介绍一下其训练过程。\n​\t整个过程起始于利用公开数据进行预训练，获得Llama-2。在此之后，通过有监督微调创建了Llama-2-Chat的初始版本。随后，使用基于人类反馈的强化学习（RLHF）方法来迭代地改进模型，具体包括拒绝采样（Rejection Sampling）和近端策略优化（Proximal Policy Optimization, PPO）。在RLHF阶段，人类偏好数据也在并行迭代，以保持奖励模型的更新。\n三、开源大模型和闭源大模型 ​\t根据上面的学习，我们不难发现，构建大模型不仅需要海量的数据，更依赖于强大的计算能力，以确保模型能够快速迭代和优化，从而达到预期的性能水平。鉴于此，全球范围内能够独立承担起如此庞大计算成本的机构屈指可数。这些机构可以分为以下两大阵营：\n一是选择将模型开源的组织，他们秉持着促进学术交流和技术创新的理念，让全球的研究者和开发者都能受益于这些模型。通过开放模型的代码和数据集，他们加速了整个AI社区的发展，促进了创新和技术的民主化。这一阵营的代表有Meta AI、浪潮信息等。\n另一类则是保持模型闭源的公司，它们通常将模型作为核心竞争力，用于提供专有服务或产品，以维持商业优势。闭源模型通常伴随着专有技术和服务，企业可以通过API等方式提供给客户使用，而不直接公开模型的细节或代码。这种模式有助于保障公司的商业利益，同时也为用户提供了稳定和安全的服务。这一阵营的代表有OpenAI、百度等。\n无论是开源还是闭源，这些大模型都在推动人工智能领域向前发展，对于推动大语言模型技术的渐进式发展起到了至关重要的作用。\n接下来，我们以浪潮信息为例，简要介绍下浪潮信息源大模型开源体系。\n四、源大模型开源体系(浪潮信息) 截止到目前，浪潮信息已经发布了三个大模型：源1.0 ，源2.0 和 源2.0-M32，其中 源1.0 开放了模型API、高质量中文数据集和代码，源2.0 和 源2.0-M32 采用全面开源策略，全系列模型参数和代码均可免费下载使用。\n2021年9月，源1.0大模型发布，它采用76层的Transformer Decoder结构，使用5T数据训练，拥有2457亿参数量，超越OpenAI研发的GPT-3，成为全球最大规模的AI巨量模型，表现出了出色的中文理解与创作能力。\n项目链接: https://github.com/Shawn-IEITSystems/Yuan-1.0 官方报道: https://mp.weixin.qq.com/s/6CH0I4eOLzj3YDZyIxdeEQ 论文链接: https://arxiv.org/abs/2110.04725 2023年11月，源2.0大模型发布，它使用10T数据训练，包括1026亿、518亿、21亿 三款参数规模，在数理逻辑、代码生成等方面表现出色。\n在算法方面，与传统Attention对输入的所有文字一视同仁不同，\n局部注意力过滤增强机制（Localized Filtering-based Attention, LFA） 源2.0提出，它假设自然语言相邻词之间有更强的语义关联，因此针对局部依赖进行了建模，最后使得模型精度提高3.53%。\n项目链接: https://github.com/IEIT-Yuan/Yuan-2.0 官方报道: https://mp.weixin.qq.com/s/rjnsUS83TT7aEN3r2i0IPQ 论文链接: https://arxiv.org/abs/2311.15786 2024年5月，源2.0-M32发布，它是一个混合专家（Mixture of Experts, MoE）大模型，使用2000B Tokens训练，包含400亿参数，37亿激活参数\n源2.0-M32 包含32个专家，基于LFA+Attention Router的MoE模型结构。\n源2.0-M32 在数理逻辑、代码生成、知识等方面精度对标Llama3-70B，推理算力降至1/19。\n项目链接: https://github.com/IEIT-Yuan/Yuan2.0-M32 官方报道: https://mp.weixin.qq.com/s/WEVyYq9BkTTlO6EAfiCf6w 论文链接: https://arxiv.org/abs/2405.17976 本次学习，我们将以 源2.0-2B 模型为例，带领大家一起体验源大模型，欢迎大家来给项目点点 star 哦！\n五、大模型时代挖掘模型能力的开发范式 ​\t进入大模型时代，人工智能领域的边界正以前所未有的速度扩展，而如何充分挖掘大模型的内在潜能，成为了应用开发者面前的一道关键课题。\n​\t在这一背景下，不同的应用场景催生了多样化的应用开发策略，这些策略不仅展现了大模型应用开发的丰富可能性，也预示着未来AI技术在各行业落地的广阔前景。\n有手就行的Prompt工程 Prompt工程（Prompt Engineering）是指通过精心构造提示（Prompt），直接调教大模型，解决实际问题。\n为了更充分地挖掘大模型的潜能，出现了以下两种技术：\nLCT和CoT 上下文学习（In-Context Learning, ICL）：将任务说明及示例融入提示文本之中，利用模型自身的归纳能力，无需额外训练即可完成新任务的学习。 思维链提示（Chain-of-Thought, CoT）：引入连贯的逻辑推理链条至提示信息内，显著增强了模型处理复杂问题时的解析深度与广度。 Embedding辅助给LLM外接大脑 ​\t尽管大模型具有非常出色的能力，然而在实际应用场景中，仍然会出现大模型无法满足我们需求的情况，主要有以下几方面原因：\n知识局限性：大模型的知识来源于训练数据，而这些数据主要来自于互联网上已经公开的资源，对于一些实时性的或者非公开的，由于大模型没有获取到相关数据，这部分知识也就无法被掌握。 数据安全性：为了使得大模型能够具备相应的知识，就需要将数据纳入到训练集进行训练。然而，对于企业来说，数据的安全性至关重要，任何形式的数据泄露都可能对企业构成致命的威胁。 大模型幻觉：由于大模型是基于概率统计进行构建的，其输出本质上是一系列数值运算。因此，有时会出现模型“一本正经地胡说八道”的情况，尤其是在大模型不具备的知识或不擅长的场景中。 因此，将知识提前转成Embedding向量，存入知识库，然后通过检索将知识作为背景信息，这样就相当于给LLM外接大脑，使大模型能够运用这些外部知识，生成准确且符合上下文的答案，同时能够减少模型幻觉的出现。\n参数高效微调Parameter-efficient Fine-tuning，轻量化微调Lightweight Fine-tuning 在实际应用场景中，大模型还会经常出现以下问题：\n大模型在当前任务上能力不佳，如果提升其能力？ 另外，怎么使大模型学习其本身不具备的能力呢？ 这些问题的答案是模型微调。\n模型微调也被称为指令微调（Instruction Tuning）或者有监督微调（Supervised Fine-tuning, SFT），首先需要构建指令训练数据，然后通过有监督的方式对大模型的参数进行微调。经过模型微调后，大模型能够更好地遵循和执行人类指令，进而完成下游任务。\n然而，由于大模型的参数量巨大， 进行全量参数微调需要消耗非常多的算力。为了解决这一问题，研究者提出了参数高效微调（Parameter-efficient Fine-tuning），也称为轻量化微调 （Lightweight Fine-tuning），这些方法通过训练极少的模型参数，同时保证微调后的模型表现可以与全量微调相媲美。\n六、大模型应用开发 必知必会 通常，一个完整的大模型应用包含一个客户端和一个服务端。\n客户端接收到用户请求后，将请求输入到服务端，服务端经过计算得到输出后，返回给客户端回复用户的请求。\n暂时无法在飞书文档外展示此内容\n客户端 在大模型应用中，客户端需要接受用户请求，并且能将回复返回给用户。\n目前，客户端通常使用 Gradio 和 Streamlit 进行开发。\nGradio 基本概念 https://datawhaler.feishu.cn/sync/C8BfdAPevsOWctbpowocZYOGnmb\nStreamlit 基础概念 https://datawhaler.feishu.cn/sync/AylRdptJis6baEbW2f9cW17snVh\n服务端 在大模型应用中，服务端需要与大模型进行交互，大模型接受到用户请求后，经过复杂的计算，得到模型输出。\n目前，服务端主要有以下两种方式：\n直接调用大模型API 直接调用大模型API：将请求直接发送给相应的服务商，如openai，讯飞星火等，等待API返回大模型回复\n✔️ 优点：\n便捷性： 不需要关心模型的维护和更新，服务商通常会负责这些工作。 资源效率： 避免了本地硬件投资和维护成本，按需付费，灵活调整成本支出。 稳定性与安全性： 专业团队管理，可能提供更好的系统稳定性和数据安全性措施。 扩展性： API服务易于集成到现有的应用和服务中，支持高并发请求。 ✖️ 缺点：\n网络延迟： 需要稳定的网络连接，可能会受到网络延迟的影响。 数据隐私： 数据需要传输到服务商的服务器，可能涉及数据安全和隐私问题。 成本控制： 高频次或大量数据的调用可能会导致较高的费用。 依赖性： 受制于服务商的政策变化，如价格调整、服务条款变更等。 **大模型本地部署 大模型本地部署**：在本地GPU或者CPU上，下载模型文件，并基于推理框架进行部署大模型**\n✔️ 优点：\n数据主权： 数据完全在本地处理，对于敏感数据处理更为安全。 性能可控： 可以根据需求优化配置，减少网络延迟，提高响应速度。 成本固定： 初始投入后，长期运行成本相对固定，避免了按使用量付费的不确定性。 定制化： 更容易针对特定需求进行模型微调或扩展。 ✖️ 缺点：\n硬件投资： 需要强大的计算资源，如高性能GPU，初期投资成本较高。 运维复杂： 需要自行管理模型的更新、维护和故障排查。 技术门槛： 对于非专业团队而言，模型的部署和优化可能较为复杂。 资源利用率： 在低负载情况下，本地硬件资源可能无法充分利用。 综上，选择哪种方式取决于具体的应用场景、数据敏感性、预算以及对延迟和性能的需求。\n来精读一下baseline 完整baseline代码 # 导入所需的库 from transformers import AutoTokenizer, AutoModelForCausalLM import torch import streamlit as st # 创建一个标题和一个副标题 st.title(\u0026#34;💬 Yuan2.0 智能编程助手\u0026#34;) # 源大模型下载 from modelscope import snapshot_download model_dir = snapshot_download(\u0026#39;IEITYuan/Yuan2-2B-Mars-hf\u0026#39;, cache_dir=\u0026#39;./\u0026#39;) # model_dir = snapshot_download(\u0026#39;IEITYuan/Yuan2-2B-July-hf\u0026#39;, cache_dir=\u0026#39;./\u0026#39;) # 定义模型路径 path = \u0026#39;./IEITYuan/Yuan2-2B-Mars-hf\u0026#39; # path = \u0026#39;./IEITYuan/Yuan2-2B-July-hf\u0026#39; # 定义模型数据类型 torch_dtype = torch.bfloat16 # A10 # torch_dtype = torch.float16 # P100 # 定义一个函数，用于获取模型和tokenizer @st.cache_resource def get_model(): print(\u0026#34;Creat tokenizer...\u0026#34;) tokenizer = AutoTokenizer.from_pretrained(path, add_eos_token=False, add_bos_token=False, eos_token=\u0026#39;\u0026lt;eod\u0026gt;\u0026#39;) tokenizer.add_tokens([\u0026#39;\u0026lt;sep\u0026gt;\u0026#39;, \u0026#39;\u0026lt;pad\u0026gt;\u0026#39;, \u0026#39;\u0026lt;mask\u0026gt;\u0026#39;, \u0026#39;\u0026lt;predict\u0026gt;\u0026#39;, \u0026#39;\u0026lt;FIM_SUFFIX\u0026gt;\u0026#39;, \u0026#39;\u0026lt;FIM_PREFIX\u0026gt;\u0026#39;, \u0026#39;\u0026lt;FIM_MIDDLE\u0026gt;\u0026#39;,\u0026#39;\u0026lt;commit_before\u0026gt;\u0026#39;,\u0026#39;\u0026lt;commit_msg\u0026gt;\u0026#39;,\u0026#39;\u0026lt;commit_after\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_start\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_text\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_code\u0026gt;\u0026#39;,\u0026#39;\u0026lt;jupyter_output\u0026gt;\u0026#39;,\u0026#39;\u0026lt;empty_output\u0026gt;\u0026#39;], special_tokens=True) print(\u0026#34;Creat model...\u0026#34;) model = AutoModelForCausalLM.from_pretrained(path, torch_dtype=torch_dtype, trust_remote_code=True).cuda() print(\u0026#34;Done.\u0026#34;) return tokenizer, model # 加载model和tokenizer tokenizer, model = get_model() # 初次运行时，session_state中没有\u0026#34;messages\u0026#34;，需要创建一个空列表 if \u0026#34;messages\u0026#34; not in st.session_state: st.session_state[\u0026#34;messages\u0026#34;] = [] # 每次对话时，都需要遍历session_state中的所有消息，并显示在聊天界面上 for msg in st.session_state.messages: st.chat_message(msg[\u0026#34;role\u0026#34;]).write(msg[\u0026#34;content\u0026#34;]) # 如果用户在聊天输入框中输入了内容，则执行以下操作 if prompt := st.chat_input(): # 将用户的输入添加到session_state中的messages列表中 st.session_state.messages.append({\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt}) # 在聊天界面上显示用户的输入 st.chat_message(\u0026#34;user\u0026#34;).write(prompt) # 调用模型 prompt = \u0026#34;\u0026lt;n\u0026gt;\u0026#34;.join(msg[\u0026#34;content\u0026#34;] for msg in st.session_state.messages) + \u0026#34;\u0026lt;sep\u0026gt;\u0026#34; # 拼接对话历史 inputs = tokenizer(prompt, return_tensors=\u0026#34;pt\u0026#34;)[\u0026#34;input_ids\u0026#34;].cuda() outputs = model.generate(inputs, do_sample=False, max_length=1024) # 设置解码方式和最大生成长度 output = tokenizer.decode(outputs[0]) response = output.split(\u0026#34;\u0026lt;sep\u0026gt;\u0026#34;)[-1].replace(\u0026#34;\u0026lt;eod\u0026gt;\u0026#34;, \u0026#39;\u0026#39;) # 将模型的输出添加到session_state中的messages列表中 st.session_state.messages.append({\u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: response}) # 在聊天界面上显示模型的输出 st.chat_message(\u0026#34;assistant\u0026#34;).write(response) baseline方案设计 2.1 概要设计 baseline基于源大模型的编程能力来解决用户的问题，主要包含一个Streamlit开发的客户端，以及一个部署好浪潮源大模型的服务端。客户端接收到用户请求后，首先进行交互历史拼接，然后输入到服务端的浪潮源大模型，得到模型输出结果后，返回给客户端，用于回复用户的问题。\n暂时无法在飞书文档外展示此内容\n2.2 详细设计 暂时无法在飞书文档外展示此内容\n导入库： 导入所需要的依赖，包括 transformers，torch 和 streamlit。其中torch 魔搭本身已经安装，transformers 和 streamlit在第二步也安装完毕。 模型下载： Yuan2-2B-Mars支持通过多个平台进行下载，包括魔搭、HuggingFace、OpenXlab、百度网盘、WiseModel等。因为我们的机器就在魔搭，所以这里我们直接选择通过魔搭进行下载。模型在魔搭平台的地址为 IEITYuan/Yuan2-2B-Mars-hf。\n模型下载使用的是 modelscope 中的 snapshot_download 函数，第一个参数为模型名称 IEITYuan/Yuan2-2B-Mars-hf，第二个参数 cache_dir 为模型保存路径，这里.表示当前路径。\n模型大小约为4.1G，由于是从魔搭直接进行下载，速度会非常快。下载完成后，会在当前目录增加一个名为 IEITYuan 的文件夹，其中 Yuan2-2B-Mars-hf 里面保存着我们下载好的源大模型。\n模型加载： 使用 transformers 中的 from_pretrained 函数来加载下载好的模型和tokenizer，并通过 .cuda() 将模型放置在GPU上。另外，这里额外使用了 streamlit 提供的一个装饰器 @st.cache_resource ，它可以用于缓存加载好的模型和tokenizer。\n读取用户输入： 使用 streamlit 提供的 chat_input() 来获取用户输入，同时将其保存到对话历史里，并通过st.chat_message(\u0026quot;user\u0026quot;).write(prompt) 在聊天界面上进行显示。\n对话历史拼接： 对于 Yuan2-2B-Mars 模型来说，输入需要在末尾添加 ，模型输出到 结束。如果输入是多轮对话历史，需要使用 进行拼接，并且在末尾添加。\n模型调用： 输入的prompt需要先经tokenizer切分成token，并转成对应的id，并通过 .cuda() 将输入也放置在GPU上。然后调用 model.generate() 生成输出的id，并通过 tokenizer.decode() 将id转成对应的字符串。最后从字符串中提取模型生成的内容（即 之后的字符串），并删除末尾的 ，得到最终的回复内容。\n显示模型输出： 得到回复内容后，将其保存到对话历史里，并通过st.chat_message(\u0026quot;assistant\u0026quot;).write(response) 在聊天界面上进行显示。 尝试替换其他Yuan大****模型！ https://datawhaler.feishu.cn/sync/UG0ydiJi9sSFkub60HmcuQTJn9f\n","date":"2024-08-10T17:06:00Z","image":"http://localhost:1313/post/cover/datawhale-cover.png","permalink":"http://localhost:1313/post/llm/","title":"Datawhale AI夏令营第四期大模型应用开发-Task01"},{"content":"一、迁移至腾讯云 使用Linux，而CentOs7.6不支持Node.js18所以选择了Docker创建hugo。\nDocker 为什么出现? 一款产品:开发\u0026ndash;上线 两套环境！\n应用环境,应用配置，开发即运维。\n环境配置十分麻烦的。\n（集群Redis、ES、Hadoop\u0026hellip;.），发布jar包或者war包，带上环境发布。\n项目能不能带上环境安装打包？2、聊聊Docker为什么会出现_哔哩哔哩_bilibili\n配置麻烦，不能够跨平台。\n传统观念：开发jar，运维来做！\n现在：开发打包部署上线，一套流程做完。\nDocker给以上问题，提出解决方案。\n类比：Java-apk-发布应用商店-使用apk即可\njava-jar-打包代环境\nDocker思想——容器想象为集装箱——隔离机制。\nDocker的历史 2010年-美国成立的公司dotCloud做一些pass的云计算服务！lxc有关的容器技术！\n他们将自己的技术（容器化技术）命名为Docker！但是没有引起行业注意！docCloud，就活不下去了。那么\n就选择开源代码 2013年开源！Docker越来越多人发现了docker的优点！火了，Docker每个月都会更新一个版本！\n2014年4月9日，Docker1.0发布！\n为什么这么火！轻巧！\n容器技术出来之前，我们都是使用的虚拟机技术！19G\n虚拟机：Vmware虚拟机多台一台电脑，但笨重！\nVM：linux centos原生镜像（一个电脑！）\r而docker：隔离，镜像用最核心的环境4m+jdk+mysql 十分的小巧，运行镜像就好了！小巧！几个M几个kb 秒级启动！ 聊聊Docker Docker是基于Go语言开发的！开源项目！\n基于官方文档学习 Docker: Accelerated Container Application Development\n容器化技术：\n不是模拟一个完整的操作系统。\n直接用在操作系统上，充分利用操作系统的资源。\n不同：\n传统虚拟机，虚拟一个硬件，运行一个完整的操作系统他，在系统上安装和运行软件。 容器内的引用hi直接运行在宿主机的上的，容器是没有自己的内容的，也没有虚拟硬件。 容器相互隔离，容器都有一个数以自己的文件系统，不糊影响。 更快速的交付和部署\n传统：一堆帮助文档，安装程序\nDocker：打包镜像发布测试，一键运行\n更便捷的升级和扩缩容\n使用了Docker之后，我们部署引用就和搭积木一样！\n项目打包为一个镜像，扩展——服务器A！服务器B！\n更简单的系统运维\n容器化之后，我们开发，测试环境都是高度一致的。\n更高效的计算资源利用\nDocker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例！服务器的性能能被压榨到极致。\ndocker run了之后发生了什么？ Docker在本机上寻找镜像——判断本机是否有这个镜像——yes——使用运行这个镜像\n——no——Docker上取下载——DockerHub是否可以找到——yes——下载到这个镜像到本地\nno——找不到返回错误\n底层原理 Docker是怎么工作的？\nDocker 是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket客户端访问。\nDockerServer接收到Docker-Client的指令，就会执行这个命令。\n客户端命令-守护进程-产生Dokcer\nDocker为什么比虚拟机快？ 1.Docker有着比虚拟机更少的抽象层\n虚拟机变为了容器，直接在Docker Engine上跑\n2.docker利用的是宿主机的内核，vm需要是Guest OS\n所以新建容器的时候，docker不需要像虚拟机一样重新加载一个操作系统的内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个过程，秒级。\nNS隔离（容器隔离）\nLinux现在都支持了。\nDocker常用命令 镜像命令 帮助命令: docker version docker info #显示系信息，包括镜像，容器数量 docker --help #万能所有命令 帮助文档下载地址：Reference documentation | Docker Docs\n镜像帮助命令 docker images docker images --help [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB #解释 REPOSITORY 镜像仓库源 TAG 镜像的标签 IMAGE ID 镜像的ID CREATED 镜像的创建时间 SIZE 镜像的大小 #可选项 -a,--all\t#列出所有镜像 -q\t--quite\t#只显示ID 下载Mysql\ndocker search mysql #可选项，通过收藏过滤 --filter=stars=3000\t#搜索出来的stars大于3000 #下载镜像 docker pull docker pull --help docker pull mysql docker pull mysql[:tag] #默认下载latest #下载的时候：分层下载，docker image的核心 联合文件系统 docker pull mysql:5.7 #下载5.7版本 这就是linux的联合文件系统。\n删除、查看镜像命令 #删除某镜像 docker rmi -f 镜像images的id #递归id批量删除-删除全部的镜像 docker rmi -f $(docker images -aq) #docker images查看所有镜像 容器命令 说明：有了镜像才能创建容器。\n#下载一个centos基本镜像系统 docker pull centos #run命令的帮助 docker run --help 新建容器并启动、查看 #参数 --name=\u0026#34;Name\u0026#34;\t#容器名字 tomcat01 tomcat02 用来区分容器 -d\t#后台 -it #交互运行 进入容器查看内容 -p\t#指定容器端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 容器端口 -p 随机指定端口 docker images\t#显示所有镜像 #测试，启动并进入容器 docker run -it centos /bin/bash linux的控制台一般在/bin下 #exit退出，从容器退回主机 exit #列出所有正在运行的容器 docker ps -a\t#列出正在运行、历史运行过的容器 -n=?\t#显示最近的?个容器 -q\t#只显示容器的编号 #删除镜像 docker rm mysql 7ce93a845a8a 退出容器 #退出 exit ctrl+p+q #退出容器不停止 此时就是没有停止，可以看到ps后查看所有正在运行的镜像，centos还在运行而没有停止。\n删除容器 docker rm 容器 容器的id docker rm -f $(docker ps -aq)#删除所有容器 docker ps -a -qixargs docker rm #删除所有容器 启动和停止容器 docker start 容器id docker restart 容器id\t#重启 docker stop\t容器id\t#停止 docker kill 容器id\t#强制停止当前命令 停止\n常用的其他命令 后台运行 #docker run -d 镜像名 docker run -d centos #后台运行必须要有前台服务，没有服务就会自杀——易错 docker ps #查看后发现centos停止了 没有前台服务，exit后后台centos自动停止\n查看日志 docker logs --help docker losgs -f -t --tail 容器id\t#查看所有日志和时间戳 docker ps docker run -it centos /bin/bash ctrl+p+q\t#退出容器不停止 docker logs -f -t tail 10 容器id #最近10条日志 发现什么日志也没有，那么\n-tf 显示时间戳和log\n\u0026ndash;tail number #显示日志的条数\n查看容器（容器的信息、源数据） inspect、top命令 #命令\rdocker ps docker top 容器id\t#\rUID用户id PID是进程id\r#!!!!!查看镜像源数据——显示容器的所有信息\r发现\rdocker inspect --help\r查看具体的操作\rdocker inspect 容器id #查看容器的源数据 进入容器（当前正在运行的） #通常容器都是后台运行的，需要进行容器，修改一些配置 #-it：交互模式运行 docker exec -it 容器id bin/bash #2方式attach docker attach -it 容器id #是进入正在运行的命令行 docker rm -f $(docker ps -aq)\t#删除所有 docker exec\t#进入容器后开启一个新的终端，可以在里面操作（常用） docker attach\t#进入当前容器正在运行的终端，不会启动新的进程！ docker ps docker images docker run -it centos /bin/bash 如何将容器文件拷主机 cd /home touch kaugnsheng.java ls docker ps docker attach 容器id cd /home\t#此时在容器内 ls touch test.java exit\t#虽然容器停止了，但是数据还在 docker ps docker ps -a docer cp 容器id:/home/test.java /home\t#从容器拷贝到主机 ls 二、用docker安装nginx Docker Hub Container Image Library | App Containerization\nDockerhub #1搜索镜像 #2下载镜像 [root@VM-12-5-centos home]# docker pull nginx 开放3344端口开放，公网的3344可以访问nginx01的80端口 docker run -d --name nginx01 -p 3344:80 nginx #-d 后台 #--name 给容器命名 #-p 宿主机:容器内端口 [root@VM-12-5-centos home]# docker run -d --name nginx01 -p 3344:80 nginx 15d98bf175044e55e9e5743165cf1fb1256c67c015ea6b0326dd27320b1b018a [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 26 seconds ago Up 25 seconds 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 18 minutes ago Up 18 minutes intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 24 hours ago Up 24 hours 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick #本机自测通过了——在宿主机上开启3344端口，相当于映射到了docker上的nginx的80端口 [root@VM-12-5-centos home]# curl localhost:3344 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [root@VM-12-5-centos home]# 现在在阿里云里就能localhost:3344访问到docker的nginx的80端口了\n进入容器操作\ndocker exec -it nginx01 /bin/bash\n如果阿里云防火墙安全组开了3344端口，那么外网是可以从：外网ip:3344可以访问到界面的。 可视化面板 portainer（先用这个） rancher（ci/cd）再用 图形化界面管理工具,提供一个后台面板供我们操作。\n外网8088端口\ndocker run -d -p 8088:9000\\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 安装后外网的8088端口、设置阿里云安全组，然后即可访问ui界面，看得到多少个镜像、容器在运行和端口映射关系。\n或者在curl localhost:8088然后在服务器中访问也可以。\n可视化面板。\n所有的应用，直接打包部署。\n镜像得到的方式： 远程仓库下载 朋友拷贝给你 自己制作镜像 三、理解分层管理 联合文件系统UnionFS 支持对文件系统的修改作为一次提交来一层层叠加。\ntomcat和mysql都要用到某个linux内核，那么就只会新增。\n层的概念，image+images\ndocker的镜像实际上是由一层层的文件系统组成的，这种层级的文件系统UnionFS\n黑屏\u0026mdash;开机的过程中没有了，那么这段时间都是公用的。\n**bootfs(boot file system)**相当于省去了这段时间，更快。而且精简的内核OS，例如centos很小。\n分层 docker pull redis\n这一层已经存在了\ndocker image inspect redis:laest 查看里面layers 在layer记录\n打包的时候会有6个文件\n文件能实现替换，也能文件复用。\nredis的联合文件系统的表示\n在layer中也是6个\n所以docker是分层下载的。\n特点 run起来的东西可以修改，而镜像是无法修改的。\n四、如何提交自己的镜像 commit docker commit 提交容器成为一个新的副本 #命令和git原理类似 docker commit -m \u0026#34;提交描述的消息\u0026#34; -a\u0026#34;作者\u0026#34; 举例： 将tomcat的docker的webapps的内文件拷贝打牌webapps中，制作一个webapps中有文件的镜像\ndocker images docker run -it -p 8080:8080 tomcat\t#启动docker-tomcat #1.启动了tomcat的前台 docker ps docker exec -it 容器id /bin/bash\t#进入了tomcat控制台 cd webapps ls cd.. ls cp -r webapps.dist/* webapps 发布镜像 root@7803ab322d1d:/usr/local/tomcat/webapps# ls docs examples host-manager manager ROOT root@7803ab322d1d:/usr/local/tomcat/webapps# exit exit [root@VM-12-5-centos ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7803ab322d1d tomcat \u0026#34;catalina.sh run\u0026#34; 10 minutes ago Up 10 minutes 8080/tcp, 0.0.0.0:8081-\u0026gt;8081/tcp, :::8081-\u0026gt;8081/tcp cranky_payne 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 39 hours ago Up 39 hours intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick #4.将我们操作过的容器通过commit提交为一个新的镜像 [root@VM-12-5-centos ~]# docker commit -a=\u0026#34;kuangsheng\u0026#34; -m=\u0026#34;add webapps applalala\u0026#34; 7803ab322d1d tomcat02:1.0 sha256:73725f496f3b9c35005b2089ec45f577ed62958d9bf00ca0c3b91455bc683e34 [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 11 seconds ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos ~]# 类比学习：VM的快照。\n容器数据卷 什么是容器数据卷？ docker的理念回顾，应用和环境打包为一个镜像！\n数据？如果数据在容器中，那么将容器删除，数据就会丢失！需求：数据可以持久化\nMySQL，容器删了，删除跑路！需求：MySQL数据可以存储在本地\n卷技术就是这样！\n目录的挂在，将容器内的目录挂载到Linux上面！\n总结：容器的持久化和同步操作容器间也是可以数据共享的！ 使用数据卷 方法一、直接使用命令来挂载 -v docker run -it -v 主机目录:容器目录 #测试 [root@VM-12-5-centos home]# docker run -it -v /home/ceshi:/home centos /bin/bash #可以看到宿主机有了/ceshi目录 [root@VM-12-5-centos ~]# cd home -bash: cd: home: No such file or directory [root@VM-12-5-centos ~]# cd /home [root@VM-12-5-centos home]# ls ceshi git git_1 kaungsheng.java lighthouse PoolBee www [root@VM-12-5-centos home]# #centos的容器的/home目录 [root@VM-12-5-centos ~]# cd /homge -bash: cd: /homge: No such file or directory [root@VM-12-5-centos ~]# cd /home [root@VM-12-5-centos home]# ls git git_1 kaungsheng.java lighthouse PoolBee www [root@VM-12-5-centos home]# docker run -it -v /home/ceshi:/home centos /bin/bash [root@783df7f8b77c /]# cd /home [root@783df7f8b77c home]# ls [root@783df7f8b77c home]# #以后外部放的文件以后就会和docker的cenos的/home目录同步 #查看centos的容器的信息 [root@VM-12-5-centos home]# docker inspect 783df7f8b77c #Mount中 \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/home/ceshi\u0026#34;,#主机内地址 \u0026#34;Destination\u0026#34;: \u0026#34;/home\u0026#34;,#docker容器内地址 \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;rprivate\u0026#34; } ], #测试 #可以看到主机中是空的 [root@VM-12-5-centos home]# cd ceshi [root@VM-12-5-centos ceshi]# ls [root@VM-12-5-centos ceshi]# #在容器中创建test.java [root@783df7f8b77c home]# touch test.java [root@783df7f8b77c home]# #后续在主机中查看到传过来了！ [root@VM-12-5-centos ceshi]# ls [root@VM-12-5-centos ceshi]# ls test.java [root@VM-12-5-centos ceshi]# 同步的过程 如果容器停止，但是在Linux的文件夹更改，还是会同步到容器内绑定的文件夹！ #如果容器停止，但是在Linux的文件夹更改，还是会同步到容器内绑定的文件夹！ #1.让容器停止 [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Up 40 hours intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick [root@VM-12-5-centos home]# stop 39fd379b5760 bash: stop: command not found... Similar command is: \u0026#39;top\u0026#39; [root@VM-12-5-centos home]# docker stop 39fd379b5760 39fd379b5760 [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick [root@VM-12-5-centos home]# #修改宿主机中的文件 #启动容器进行查看 [root@VM-12-5-centos home]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 09b5fac024a8 5d0da3dc9764 \u0026#34;/bin/bash\u0026#34; 2 minutes ago Exited (0) 2 minutes ago objective_noyce 783df7f8b77c centos \u0026#34;/bin/bash\u0026#34; 19 minutes ago Exited (0) 10 minutes ago affectionate_shaw 7803ab322d1d tomcat \u0026#34;catalina.sh run\u0026#34; 46 minutes ago Exited (130) 22 minutes ago cranky_payne 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 40 hours ago Up 40 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 a17f2df4b0c2 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago eloquent_northcutt 223a694af194 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago magical_volhard 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 4 minutes ago intelligent_lovelace 28e3e9b4ecdf centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago unruffled_sinoussi f75f0b03f939 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago vigilant_euclid aa158bb7f0e1 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago elated_robinson d6dfa990d314 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago nervous_montalcini 9101ac141b0f centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago competent_mcnulty 02cd07c4283d centos \u0026#34;/bin/basj\u0026#34; 40 hours ago Created upbeat_driscoll 9b872200a3b3 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago stoic_kepler 8512fca58a26 centos \u0026#34;/bin/basj\u0026#34; 40 hours ago Created hungry_sutherland 7fd5a54afd95 hello-world \u0026#34;/hello\u0026#34; 2 days ago Exited (0) 2 days ago cool_turing 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick 59e514225874 klakegg/hugo:latest-ext \u0026#34;hugo\u0026#34; 2 days ago Exited (255) 2 days ago confident_bassi [root@VM-12-5-centos home]# docker start 783df7f8b77c 783df7f8b77c [root@VM-12-5-centos home]# docker attach 783df7f8b77c [root@783df7f8b77c /]# cd /home [root@783df7f8b77c home]# ls test.java [root@783df7f8b77c home]# cat test/java cat: test/java: No such file or directory [root@783df7f8b77c home]# cat test.java hello linux update [root@783df7f8b77c home]# #可以看到成功了！ 好处：以后在本地修改，容器中会自动同步。\n实战：安装MySQL 思考：MySQL的数据持久化问题！\n#下载mysql #docker search mysql #进官网看版本 #docker pull mysql:5.7 [root@VM-12-5-centos home]# docker pull mysql:5.7 5.7: Pulling from library/mysql 20e4dcae4c69: Downloading [=============\u0026gt; ] 13.71MB/50.5MB 1c56c3d4ce74: Download complete e9f03a1c24ce: Download complete 68c3898c2015: Download complete 6b95a940e7b6: Download complete 90986bb8de6e: Download complete ae71319cb779: Waiting ffc89e9dfd88: Download complete 43d05e938198: Waiting 064b2d298fba: Waiting df9a4d85569b: Waiting [root@VM-12-5-centos home]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 49 minutes ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos home]# #运行容器进行数据挂载 #安装启动mysql，要配置【用户密码】 #去docker hub找mysql [root@VM-12-5-centos home]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 49 minutes ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 4d55165721b1195ccfb240b39dcf2f5cb9d8edd50095305d4197ae55391fbf5b [root@VM-12-5-centos home]# #启动我们的mysql -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 --name 容器名字 mysql - Official Image | Docker Hub\n官网中\n$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag -e MYSQL_ROOT_PASSWORD=123456 \u0026ndash;name mysql01 mysql:5.7\n-e 就是配置环境，那么这里就是设置密码\n新建Mysql连接 阿里云安全组、本地防火墙、虚拟机防火墙。\n且要保证这个是有程序占用的！\n#云服务器LinuxCentos上打开3306,命令行打开或图形化界面打开 #腾讯云安全组设置，本机windows设置防火墙设置出站规则 [root@VM-12-5-centos home]# firewall-cmd --permanent --add-port=3306/tcp success [root@VM-12-5-centos home]# firewall-cmd --reload success [root@VM-12-5-centos home]# 宝塔面板中可以看到状态，而腾讯云的看不到\n重启服务器，然后在宝塔中查看状态为未使用。\n已经下载了mysql5.7镜像，然后又删除了原本的mysql01容器，然后重新根据景象创建，成功了！ [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 2 hours ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 docker: Error response from daemon: Conflict. The container name \u0026#34;/mysql01\u0026#34; is already in use by container \u0026#34;4d55165721b1195ccfb240b39dcf2f5cb9d8edd50095305d4197ae55391fbf5b\u0026#34;. You have to remove (or rename) that container to be able to reuse that name. See \u0026#39;docker run --help\u0026#39;. [root@VM-12-5-centos ~]# stop mysql01 bash: stop: command not found... Similar command is: \u0026#39;top\u0026#39; [root@VM-12-5-centos ~]# docker stop mysql01 mysql01 [root@VM-12-5-centos ~]# [root@VM-12-5-centos ~]# docker rm mysql01 mysql01 #两个容器数据卷进行挂载 # -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql #1.宿主机/home/mysql/conf---\u0026gt;docker的/etc/mysql/conf.d mysql的配置文件 #2.宿主机/home/mysql/data---\u0026gt;docker的/var/lib/mysql mysql的数据文件 [root@VM-12-5-centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 f669f7ef2710692ff207cd5b8889e77289d3631e5419e494ad056fd0e405f504 [root@VM-12-5-centos ~]# #启动成功后本地是有sqlyog来测试 #sqlyog--连接到服务器的3310--3310和容器中的3306映射，这个时候可以连接上了 具名和匿名挂载 匿名挂载 # -v 容器内路径 docker run -d -p --name nginx01 -v /etc/nginx nginx docker volume --help docker volum ls\t#查看所有volum的镜像 docker volume ls\n这些都是匿名卷，每一个VOLUME NAME\n只写了容器内的路径，没有写容器外的路径。\n具名挂载 #具名挂载 #通过 -v 卷名:容器内路径 ls docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx nginx #juming-nginx这个代表是-v的名字VOLUMN NAME而不是路径。 #看一下这个卷 #是在/var/lib/docker/volumes/juming-nginx/_data #\t里面就是默认的具名挂载的位置 #/var/lib/docker/volumes\t所有卷存储的位置 #/var/lib/docker\tdocker的所有的文件 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！ -V容器内路径 #匿名挂载 -V卷名：容器内路径 #具名挂载 -V/宿主机路径：：容器内路径#指定路径挂载！ 拓展：-v 容器内路径:ro rw 改变读写权限 #通过 -v 容器内路径:ro rw 改变读写权限 ro readonly\t#只读 rw\treadwrite\t#可读可写 docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx:ro nginx docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx:rw nginx #ro 只要看到ro说明路径只能通过宿主机来操作，容器内部是无法操作的。 ","date":"2024-08-07T20:01:49Z","image":"http://localhost:1313/post/cover/docker-cover.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.08.08/","title":"Hugo主题-Docker学习-8月8日博客更新日志"},{"content":"Echarts使用方法： 官方教程：https://echarts.apache.org/handbook/zh/get-started/\n1.首先要提供一个容器，并给定大小 例如：\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .box{ width: 300px; height: 300px; background-color: rgb(188, 227, 236); } \u0026lt;/style\u0026gt; 2.引入需要的js地图文件，一般是而echart.js和一个地图js文件 (1)本地js文件引入 \u0026lt;script src=\u0026#34;/XXX/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/XXX/china.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 引入即可\n但echart官网已经挂了，不提供地图js文件。自行网上查阅吧~\n(2)CDN引入 \u0026lt;!-- \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/echarts@latest/dist/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;china.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; 注意：如果用npm等包管理器安装过了echart，然后用webpack打包了。那么在中可以使用import语句进行引入\n// import * as echarts from \u0026#39;echarts\u0026#39;; 3.实例化echarts对象 \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; var myChart = echarts.init(document.querySelector(\u0026#34;.box\u0026#34;)); 4.指定配置项和数据 var option = { title: { text: \u0026#39;ECharts 入门示例\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;销量\u0026#39;] }, xAxis: { data: [\u0026#34;衬衫\u0026#34;,\u0026#34;羊毛衫\u0026#34;,\u0026#34;雪纺衫\u0026#34;,\u0026#34;裤子\u0026#34;,\u0026#34;高跟鞋\u0026#34;,\u0026#34;袜子\u0026#34;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20] }] }; 5.将配置项设置给echarts实例对象，使用刚指定的配置项和数据显示图表 myChart.setOption(option); 完整代码 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document01\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box{ width: 300px; height: 300px; background-color: rgb(188, 227, 236); } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 1..准备具有大小的DOM容器 --\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 2.方法一 、直接写路径--\u0026gt; \u0026lt;!-- 2.方法二、CDN引入--\u0026gt; \u0026lt;!-- \u0026lt;script src=\u0026#34;echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;script src=\u0026#34;echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // import * as echarts from \u0026#39;echarts\u0026#39;;不行 //3.初始化实例对象 echarts.init(dom容器) var myChart = echarts.init(document.querySelector(\u0026#34;.box\u0026#34;)); //4.指定配置项和数据 var option = { title: { text: \u0026#39;ECharts 入门示例\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;销量\u0026#39;] }, xAxis: { data: [\u0026#34;衬衫\u0026#34;,\u0026#34;羊毛衫\u0026#34;,\u0026#34;雪纺衫\u0026#34;,\u0026#34;裤子\u0026#34;,\u0026#34;高跟鞋\u0026#34;,\u0026#34;袜子\u0026#34;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20] }] }; //5.将配置项设置给echarts实例对象，使用刚指定的配置项和数据显示图表。 myChart.setOption(option); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 常见问题 1.下载地图.js文件，自行google。 2.下载的地图文件的GeoJSON 数据为乱码 地图文件的GeoJSON 乱码解决方法： DataV.GeoAtlas\n添加在对应的Geojson即可。 ","date":"2024-07-25T23:50:28Z","image":"http://localhost:1313/post/cover/plugin_cover.jpg","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.26-2/","title":"Echart使用及常见问题"},{"content":"​\n这几天逛了很多博客，找到了十年之约 (foreverblog.cn)、博客广场 - 博友圈 · 博客人的朋友圈！ (boyouquan.com)等博客交流圈子，等我慢慢写博客，然后域名备案下来了，提交申请吧~ 一、新增博客背景虚化图片 ​\t这个很简单，在assets\\scss\\custom.scss中对body选择器声明块中增加，背景图片即可。\n如果要点击暗色模式的时候，切换背景虚化的颜色。那么需要在为暗色模式的click事件中增加背景虚化的类。\n\\主题文件夹\\public\\ts\\main.ts中\n首先在CSS: 使用 .dark-mode 类在暗色模式下应用黑色毛玻璃效果。\nbody { background-image: url(\u0026#39;/page/nav-img/background4.jpg\u0026#39;); background-size: cover; background-attachment: fixed; position: relative; transition: background-color 0.3s ease; } body::after { content: \u0026#39;\u0026#39;; position: absolute; top: 0; left: 0; right: 0; bottom: 0; /* 白色模式下的样式 */ background: rgba(176, 176, 176, 0.595); /* 黑色半透明 */ backdrop-filter: blur(10px); /* 毛玻璃效果 */ z-index: -1; // transition: background 0.3s ease, backdrop-filter 0.3s ease; /* 平滑过渡效果 */ } /* 暗色模式下的样式 */ body.dark-mode::after { background: rgba(158, 157, 157, 0.5); /* 更强的黑色半透明毛玻璃效果 */ 其次main.ts的JS中: 切换 dark-mode 类以应用新的样式。\nmain.ts // 初始化颜色方案切换器 const colorSchemeToggler = new colorScheme_default(document.getElementById(\u0026#34;dark-mode-toggle\u0026#34;)); // 为暗色模式切换按钮添加事件监听器 const darkModeToggleButton = document.getElementById(\u0026#34;dark-mode-toggle\u0026#34;); if (darkModeToggleButton) { darkModeToggleButton.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { // 切换 body 上的 \u0026#39;dark-mode\u0026#39; 类，切换到暗色模式 document.body.classList.toggle(\u0026#34;dark-mode\u0026#34;); }); } } }; 实现效果。\n二、新增导航栏及Home、关于我、走走停停板块 (1)导航栏 1.创建导航栏的html layouts/partials 文件夹中创建一个新的部分文件 我创建在了\\hugo-theme-stack-3.26.0\\layouts\\partials\\navbar目录下的navbar.html\n\u0026lt;!-- layouts/partials/navbar.html --\u0026gt; \u0026lt;nav class=\u0026#34;navbar--fixed-top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34; class=\u0026#34;navbar-brand\u0026#34;\u0026gt;Logo\u0026lt;/a\u0026gt; \u0026lt;ul class=\u0026#34;navbar-nav\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/about\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;nav-item\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/contact\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;Contact\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; 2.在Hugo主模板中包含导航栏 修改_default目录下的baseof.html，这个文件是Hugo主题的模板文件，可以用go自己设计模板。\n要包含navbar.html即可\n\\hugo-theme-stack-3.26.0\\layouts\\_default\\baseof.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34; dir=\u0026#34;{{ default `ltr` .Language.LanguageDirection }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{- partial \u0026#34;head/head.html\u0026#34; . -}} {{- block \u0026#34;head\u0026#34; . -}}{{ end }} \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;{{ block `body-class` . }}{{ end }}\u0026#34;\u0026gt; {{- partial \u0026#34;head/colorScheme\u0026#34; . -}} \u0026lt;!-- 导航栏的html文件包含 --\u0026gt; {{ partial \u0026#34;navbar/navbar.html\u0026#34; . }} \u0026lt;!-- 包含导航栏 --\u0026gt; {{/* The container is wider when there\u0026#39;s any activated widget */}} {{- $hasWidget := false -}} {{- range .Site.Params.widgets -}} {{- if gt (len .) 0 -}} {{- $hasWidget = true -}} {{- end -}} {{- end -}} \u0026lt;div class=\u0026#34;container main-container flex on-phone--column {{ if $hasWidget }}extended{{ else }}compact{{ end }}\u0026#34;\u0026gt; {{- block \u0026#34;left-sidebar\u0026#34; . -}} {{ partial \u0026#34;sidebar/left.html\u0026#34; . }} {{- end -}} {{- block \u0026#34;right-sidebar\u0026#34; . -}}{{ end }} \u0026lt;main class=\u0026#34;main full-width\u0026#34;\u0026gt; {{- block \u0026#34;main\u0026#34; . }}{{- end }} \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; {{ partial \u0026#34;footer/include.html\u0026#34; . }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3.为导航栏的html增加css样式 我放在了\\hugo-theme-stack-3.26.0\\assets\\scss\\partials的navbar.scss中\n/* assets/css/styles.css */ .navbar--fixed-top { position: sticky; top: 0; z-index: var(--ifm-z-index-fixed); background-color: white; /* 你可以根据需要添加其他样式 */ box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); padding: 10px 0; } .navbar-nav { list-style: none; display: flex; gap: 20px; } .nav-item { display: inline; } .nav-link { text-decoration: none; color: black; } .navbar-brand { font-size: 1.5em; font-weight: bold; } 4.在head.html文件下确保css被正确引用 theme-stack-3.26.0\\layouts\\partials\\head\\head.html中\n\u0026lt;meta charset=\u0026#39;utf-8\u0026#39;\u0026gt; \u0026lt;meta name=\u0026#39;viewport\u0026#39; content=\u0026#39;width=device-width, initial-scale=1\u0026#39;\u0026gt; {{- $description := partialCached \u0026#34;data/description\u0026#34; . .RelPermalink -}} \u0026lt;meta name=\u0026#39;description\u0026#39; {{ printf \u0026#34;content=%q\u0026#34; $description | safeHTMLAttr }}\u0026gt; {{ with .Params.Keywords }}\u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;{{ delimit . \u0026#34;, \u0026#34; }}\u0026#34;\u0026gt;{{ end }} {{- $title := partial \u0026#34;data/title\u0026#34; . -}} \u0026lt;title\u0026gt;{{ $title }}\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#39;canonical\u0026#39; href=\u0026#39;{{ .Permalink }}\u0026#39;\u0026gt; \u0026lt;!-- navbar的css引用 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ \u0026#34;/scss/partials/navbar.scss\u0026#34; | relURL }}\u0026#34;\u0026gt; \u0026lt;!-- 添加CSS文件引用 --\u0026gt; {{- partial \u0026#34;head/style.html\u0026#34; . -}} {{- partial \u0026#34;head/script.html\u0026#34; . -}} {{- partial \u0026#34;head/opengraph/include.html\u0026#34; . -}} {{- range .AlternativeOutputFormats -}} \u0026lt;link rel=\u0026#34;{{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; href=\u0026#34;{{ .Permalink | safeURL }}\u0026#34;\u0026gt; {{- end -}} {{ with .Site.Params.favicon }} \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;{{ . | relURL }}\u0026#34; /\u0026gt; {{ end }} {{- template \u0026#34;_internal/google_analytics.html\u0026#34; . -}} {{- partial \u0026#34;head/custom.html\u0026#34; . -}} \u0026lt;!-- busuanzi --\u0026gt; {{- if .Site.Params.busuanzi.enable -}} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; {{- end -}} 5.然后在style.scss中增加scss引用 /*! * Hugo Theme Stack * * @author: Jimmy Cai * @website: https://jimmycai.com * @link: https://github.com/CaiJimmy/hugo-theme-stack 这个 SCSS 文件作为一个主文件，起到将所有相关样式文件引入到一个地方的作用。 它确保项目中的样式文件能够被组织和管理，使得最终生成的 CSS 文件包含了所有必要的样式定义。 这种结构化的样式管理方式有助于保持代码的清晰和模块化。 */ @import \u0026#34;breakpoints.scss\u0026#34;; @import \u0026#34;variables.scss\u0026#34;; @import \u0026#34;grid.scss\u0026#34;; @import \u0026#34;external/normalize.scss\u0026#34;; @import \u0026#34;partials/menu.scss\u0026#34;; @import \u0026#34;partials/article.scss\u0026#34;; @import \u0026#34;partials/widgets.scss\u0026#34;; @import \u0026#34;partials/footer.scss\u0026#34;; @import \u0026#34;partials/pagination.scss\u0026#34;; @import \u0026#34;partials/sidebar.scss\u0026#34;; @import \u0026#34;partials/base.scss\u0026#34;; @import \u0026#34;partials/layout/article.scss\u0026#34;; @import \u0026#34;partials/layout/list.scss\u0026#34;; @import \u0026#34;partials/layout/404.scss\u0026#34;; @import \u0026#34;partials/layout/search.scss\u0026#34;; @import \u0026#34;general.scss\u0026#34;; @import \u0026#34;custom.scss\u0026#34;; // narbar @import \u0026#34;partials/navbar.scss\u0026#34; 这就可以增加导航栏了。\n(2)关于我 定位到acrchives的.md文件。navbar的html中设置a标签href跳转即可。 md文件的layout设置为已经存在的layout文件，我使用的是archives的layout文件。 (3)走走停停 1.使用Apache ECharts创建地图 一个基于 JavaScript 的开源可视化图表库Apache ECharts\n三、走走停停板块的设置 pb主题\\content\\page\\daily_info中的index.md\nlayout自定义了daily_info的Hugo模块\n\\hugo-theme-stack-3.26.0\\layouts\\partials\\map中创建了index4.html设置了地图及时间轴\n\\hugo-theme-stack-3.26.0\\layouts_default中创建了daily_info.html自定义了模板，引入了index4.index（archives.html也默认再此设置的）\n","date":"2024-07-25T22:14:28Z","image":"http://localhost:1313/post/cover/stack-logo-128.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.26-1/","title":"Hugo主题配置记录-7月26日博客更新日志"},{"content":"解决了一些小问题，之前建站留下的小问题\n一、左侧栏的正确跳转 点击图标后跳转到链接栏中有二维码\nconfig.yaml中修改跳转链接到/post/link即可\n点击\u0026quot;链接\u0026quot;后出现二维码\n二、文章图片的正确插入 1.文章封面图片 \\content\\post中的文章 ##Front Matter图片插入记得要添加/post/路径 例如： image: /post/123.png\n--- title: 文章标题 date: 2024-07-23 10:00:00 tags: - 标签1 - 标签2 categories: - 分类1 - 分类2 #这里的就是文章封面图片 image: /post/stack-logo-128.png --- 这里注意\\content\\page\\中的文章\n在文章内部的时候，\n![图片](123.jpg)不需要添加/post/路径\n2.文章内部图片 \\content\\post\\中需要添加多个图片\n可以放入文件夹中，避免多个md文件和多个图片堆在一起。【注意：可以不写明在哪个文件夹，直接写/post/文件名即可】\n例如：![image-20240607184445492](/post/123.png)\n![image-20240607184336146](/post/文件夹/123.png)这样详细写明最好，实现图片的插入。\n其实在/post目录中用/post/123.png这样的方式，会自动搜寻/post目录下的123.png文件，（自我理解）所以不用写明中间的/before文件夹。\n最后：\nFront Matter中的links项的路径也一样需要加post，从post路径开始必须指定路径清晰到文件 links: \\- title: Bilibili description: bilibili是国内知名的视频弹幕网站,这里有及时的动漫新番,活跃的ACG氛围,有创意的Up主。大家可以在这里找到许多欢乐。 website: https://www.bilibili.com/ image: /post/logo/Bilibili_Logo_Blue.svg ","date":"2024-07-22T15:41:48Z","image":"http://localhost:1313/post/cover/stack-logo-128.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.23/","title":"Hugo主题配置记录-7月23日博客更新日志"},{"content":"Hugo主题配置记录 1.引入busuanzi插件进行字数、访问量统计。 \\layouts\\partials\\footer\nfooter文件中\n增加以下代码\n\u0026lt;!-- 卜算子统计信息 --\u0026gt; \u0026lt;section class=\u0026#34;count_info\u0026#34;\u0026gt; \u0026lt;!-- 1运行时间 --\u0026gt; \u0026lt;div\u0026gt; {{ T \u0026#34;footer.runtime1\u0026#34; }} \u0026lt;span id=\u0026#34;ds\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime2\u0026#34; }} \u0026lt;span id=\u0026#34;hs\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime3\u0026#34; }} \u0026lt;span id=\u0026#34;ms\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime4\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;!-- 2文章个数和字数 --\u0026gt; \u0026lt;div\u0026gt; {{ $scratch := newScratch }} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34;) }} {{ $scratch.Add \u0026#34;total\u0026#34; .WordCount }} {{ end }} \u0026lt;!-- 转换为整数 --\u0026gt; {{ $total := $scratch.Get \u0026#34;total\u0026#34; | int }} \u0026lt;!-- 转换为浮点数 --\u0026gt; {{ $totalFloat := $total | float }} {{ T \u0026#34;footer.count1\u0026#34; }} {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }} {{ T \u0026#34;footer.count2\u0026#34; }} {{ div $totalFloat 1000.0 | lang.FormatNumber 2 }} k {{ T \u0026#34;footer.count3\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;!-- 3本站访问量 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt;{{ T \u0026#34;footer.pv1\u0026#34; }}\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;{{ T \u0026#34;footer.pv2\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 卜算子js脚本 --\u0026gt; \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; (1)运行时间 \u0026lt;!-- 1运行时间 --\u0026gt; \u0026lt;div\u0026gt; {{ T \u0026#34;footer.runtime1\u0026#34; }} \u0026lt;span id=\u0026#34;ds\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime2\u0026#34; }} \u0026lt;span id=\u0026#34;hs\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime3\u0026#34; }} \u0026lt;span id=\u0026#34;ms\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime4\u0026#34; }} \u0026lt;/div\u0026gt; (2)文章个数和字数 使用 Hugo 的Scratch 存储器计算总字数。range (where .Site.Pages \u0026ldquo;Kind\u0026rdquo; \u0026ldquo;page\u0026rdquo;)遍历所有页面类型为 page 的页面。\n{{ $scratch.Add \u0026ldquo;total\u0026rdquo; .WordCount }} 将每个页面的字数累加到total。转化为整数和浮点数，\n{{ len (where .Site.RegularPages \u0026ldquo;Section\u0026rdquo; \u0026ldquo;post\u0026rdquo;) }}计算文章数量。\n{{ div $totalFloat 1000.0 | lang.FormatNumber 2 }} k将总字数除以 1000 格式化为两位小数。\nHugo 的T函数插入翻译文本\n(3)本站访问量 使用js脚本\n不蒜子 - 极简网页计数器 (ibruce.info)\n复制js代码即可。\n2.删除网站语言切换 config.yaml中删除默认语言设置\n主题最新的配置文件可以在 exampleSite/config.yaml\n配置主题 | Hugo 主题 Stack (stack-docs.netlify.app)\n\u0026lt;--删除自己的配置即可--\u0026gt; 3.更改社交图标样式、间距 \\assets\\scss\\custom.scss\n中修改即可\n.menu-social{ gap: 15px; margin-top: 25px; } 4.增加返回顶部按钮、样式替换 \\layouts\\partials\\widget\n增加如下代码\n{{ $topImg := resources.Get (\u0026#34;icons/back-to-top.svg\u0026#34;) }} \u0026lt;a id=\u0026#34;back-to-top\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt; {{$topImg.Content | safeHTML}} \u0026lt;/a\u0026gt; resources.Get获取svg文件到$topImg\na标签属性链接href=\u0026quot;#\u0026ldquo;实现返回顶部，插入svg内容进行渲染。\n\\assets\\scss\\custom.scss $hover: 0.2s ease-in-out; #back-to-top { position: fixed; margin-left: 150px; bottom: 60px; display: none; border: 0; transition: transform $hover; \u0026amp;:hover { transform: translateY(-10px); } } ease-in-out过渡，#back-to-top 定义了 ID 为 back-to-top 的元素的样式规则。\n\\assets\\icons iconfont-阿里巴巴矢量图标库 下载svg格式的图标，然后记住颜色代码，编辑搜索将颜色代码替换为currentColor就能实现颜色随暗色模式切换变化。\n链接： ","date":"2024-07-20T20:01:49Z","image":"http://localhost:1313/post/cover/stack-logo-128.png","permalink":"http://localhost:1313/post/%E5%BB%BA%E7%AB%992024.07.21/","title":"Hugo主题配置记录-7月21日博客更新日志"},{"content":"Hugo主题配置记录\n建站回顾 1. 域名 正在ICP备案,预计7个工作日后能拿到备案的域名。慢慢来吧1111\n2. 服务器 腾讯云服务器，40G, 1M带宽，1核2G内存。\n3. 博客框架 暂时用的Hugo，建站很快。\n历程 框架选来选去，之前用过Hexo主题,但是时间过于久远。这次想在云服务器上运行，遂重新开始。框架从Hexo到Halo到Hugo。 原本在Linux上安装Hexo得心应手，但这次在CentOS7.6并不支持Nodejs8,支持不了最新的Hexo主题,又转为Halo， Halo苦于教程少啊,而且Hugo整体还是很方便,比较下来Hexo的教程\u0026gt;Hugo\u0026gt;Halo，最终确定了Hugo框架。 现在网站搭起来了，后续慢慢再更新文章~~。 ","date":"2024-07-19T21:14:39Z","permalink":"http://localhost:1313/post/%E9%9A%8F%E7%AC%94/","title":"随笔"},{"content":"\ncheck point 就是菜单——选择不同的模型\nlora更精确的人物或画风，更可控\n图生图\n上传\n描述图片\nAI摄影\nlora炼丹\n七天免费试用领取\n聚焦剪裁、中央剪裁、无需剪裁、\n使用deepbooru算法反推标注。0.6 系数越小越精细\n日志看loss值，数值降低大概率没什么问题\n一、提示词prompt 类别\n其他提示词：画质等\n但是真实系的操作是更依赖真实的模型\n1.prompt模板: 具体的直接使用即可 2.提示词权重分配 增强减弱(){}\t[] 安全范围1+-0.5，单个的\n():1.1倍，1.331倍\n{}\n[1]进阶语法-坑 不想出现就是负向提示词 单色风格的画作\n3.采样迭代步数 加噪点——去除噪点\n闪一次，就步数\u0026gt;20后意义不大\n最低不要低于10\n采样方法 带有++号的是改进的算法，最好使用比较稳定。\n分辨率过高容易出现多人，多手。\n一般低分辨率绘制，然后hires fix 来放大 高清修复、 面部修复、平铺/分块：生成无缝贴满整个屏幕的纹理性图片的；一般不用\n7-12相关性一般\n批次和数量\n批次是格子预览图。每次批次数量不宜过高，容易爆显存。\n4.写提示词方法 1.翻译、描述确切场景，然后直接让词组翻译为英文 2.功能插件、翻译的插件——国内有——SD也有 3.更好书写提示词网站：AI词汇加速器 提示词网站：\n二次元和亚洲面孔多：\n人物、\n画风、质感：\n二、图生图 原理：原本提醒上记录的像素信息会在加噪和去噪的过程中、被作为一种特征反应到生成的图片上。\n1.上传图片、导入到SD里 2.提示词书写 1man,1girl\n3.参数设置 重绘幅度0.6-0.8\n分辨率设置，原始尺寸一样最好\n按长宽比例一致生成、\n[1]随机种子 xxx in backgroud\n景深depth of field\n如果要保留生成的原本的元素的样子，只改动背景，不改动人物风格呢？ 同一个随机种子、同一套随机种子、 骰子：-1是随机，循环按钮是上一次的种子。\n图库浏览器中以前生成的图片，里面有种子。\n种子加上+需要的背景提示词。 不像人物的物品的拟人化、静物或者墙角的旮旯来想象。——抖音评论区中有 [2]图生图的风格迁移： 游戏中的卡通形象到真实的现实中、可以输入提示词、更加精确的需要lora模型。\n[3]photoshop中搭建图像框架+SD生成图片——炫酷的效果。 画布\n画图中\n然后场景插画就完成了！ 三、画风 1.Checkpoint 模型信息：\n下载的模型放入这里就能加载。\n所以就叫关键点、存档。\n所以这些检查点，这些模型就能有迭代、更新的能力，AOM3A3深橘色。\n2. .ckpt文件 几个G的叫大模型\n3. .safetensors 训练者让模型更加可靠高效来使用的一种格式。\n点击刷星按钮\n命令行中跳出提示才算成功\n秋叶的启动器能对管理下载\n4. VAE VAE选项[变分自解码器Variational Autp Encoder] 负责将加噪后的潜空间数据转化为正常图像。\nAI绘图的调色滤镜，直接表现是影响色彩质感。—— 一般checkpoint里包含了VAE但是也有没有到——图片会发灰，发白\n会推荐使用一些VAE\n也有适用于大多数checkpoint的VAE：kl-f8-anime2.ckpt\n也有safetensors的VAE\n[1]自动的适配VAE方法 改为和模型一样的名字\n三-进阶 {1}Hypernetwork超网络模型 画面微调\n作用：和Lora差不多的，也可以让AI学习一些原本不存在它世界里的东西，\n不像Lora是彩卡插画。那么它像一张小名片\nHypernetwork一般用于改善画面的整体风格 这种画风区别：不是二次元真实感那种区别，而像梵高和莫奈那种小区别 hYPERNETwORK路径\n绕：设置中找到附加网络\n在这里也可以添加Lora,【坑】但是Lora会有更方便的应用形式 正方形、就可以得到Q版\n多数研究者对于Hypernetwork在图像生成方面的评价并不好，\n至少不如lora和embaddings好，\n也有部分Lora对训练样本的把控实现了对画风的塑造植入。\n尽管如此，超网络在实现特定的风格时，仍然会提供不少的帮助\n{2}embeddings嵌入式向量 优化画风\n.pt\n翻译为：文本嵌入\n有时候网站上叫Textual Inversion文本倒置\n很小的文件——相当于大模型中的书签，指向特定的形象——嵌入式向量 与VAE一样\n使用：只要在输入中输入书签翻字典的过程。 举例： 固定随机种子+embadding的固定咒语——\n更像D.VA——加入描述她身上本身有的东西\n[1]技巧反推提示词 Dva的一张图片导入_图生图\n识别东西，然后转化为AI中的东西DB更具优势。\n每次识别的再筛选——删除降低权重\n**生成图片不可能完全一致，**因为embeddings到头是个几十kb的小文件 只是按图索骥而已。\n所以embaddings适用于一些广泛、容错率高的形象的概念，表现会好很多。 而特定的人物更多的用Lora [坑]CharTurner-embaddings三视图 真NB啊\n使用方法： Eva的和charturner两个embaddings使用——化学反应自己观察 开启高清修复\n[2]embaddings解决手等的问题 只要避开错误案例就可以了 EasyNegative\n放入负面提示词里\n就修复了\n综合的、全方位的基于负面样本的提炼\n灰度，多人、等等\n{3}LoRa 低秩适应模型 固定特定人物角色特征\n作用：有助于向Ai传递/描述某一个特征准确/主体清晰的形象 夹在书中的彩页100-200M\n各方各个方面的素材、角度、画风等\n有些模型会提供触发提示词——训练过程中有基于这个提示词反复强化过AI认知\n也可以加入进行强化效果\n[1]lora会出现一些小问题 因为它的训练图源复杂、\n所以一般也会对画风进行影响\n权重减小\n[坑-深入]有专门为Lora的插件应用。 5.模型下载渠道 midjourney的提供的模型数量有限 默认的模型也能实现挺好的效果，\nSD官方也有1.4、2.0等开源模型 官方的炉在版权和尺度有限制 0.个人训练发布并分享的模型 大多数是“私炉模型” 1.Hugging face使用方法 允许用户共享AI学习模型和数据集的平台\n搜索栏中搜索stable diffusion中可以下载 筛选栏中可以找到\nWaifuDiffusion Anything DreamShop files and version中看源代码 - 大模型在Safey_checker找 - vae就在vae中找 community可以交流 2.C站 iativic.com\n不注册可使用，火热的模型\ntrained的模型 根据图像一点点训练出来的，一手的丹。\nMerged融合模型 几个模型融合到一起创造出来的。一般叫xxxMIx\n【坑】Base model 模型训练过程中的底模\n四、模型的类目及推荐 1.漫画/插画风：二次元 Anything、Counterfeit、Dreamlike Diffusion等 2.真实系 Deliberate、Realistic Vision、LOFI等 3.2.5D风 NeverEnding Dream、Protogen、国风V3 \u0026mdash;- 质感类似于建模软件出来的三维渲染图，不如平面那么平，也不如真实那么真。\n很接近一些游戏和3D动画的想象\nCounterfeit 细节感、精致感、各种复杂室内外场景\nDreamlike Diffusion 漫画插画风\n幻想的超现实魔幻作品\nDeliberate 真实系的,自由度非常高\nRealistic Vision 朴素踏实、有整活空间的写实模型。\n事物、动物图片等\nLOFI-融合模型 人物面部处理精致\nNED模型 造人的方面有一股特殊\nProtogen 国风3\n结合其他lora模型能创作\n4.小类模型 魔幻感场景\n现代建筑 高级感的平面设计\n高清 1.Hi-Res Fix 高清修复/高分辨率修复/\n皮肤分辨率太低人物皮肤模糊、人物面部不真实—— 如果用大分辨率的会有缺点 1.采样次数： 高清修复需要经过一次重绘、因此需要设置采样步数、保持默认0数值、它会和我们设置的采样次数(20)一致\n高清修勾，无法突破显存限制。\n[1]低分抽卡+固定种子+高清修复\n加戏，降低重绘幅度可以消除。\n繁纷复杂的花、多出的戒指等等\n只是高清：0.3-0.5即可\n0.5-0.7——AI重绘空间\n2.放大算法 感觉差不多，没有大到感觉很多区别\n带有GAN的算法，重绘的细节保留更加准确\n同行无脑方法\n无脑R-ESRGAN 4x+\n二次元第二个\n看模型的制作者推荐、或者自己试试。\n小技巧-简便高清方法 图库浏览器中，点击已经号的图片，再点击图生图。\n会自动填写信息\n3.放大算法设置 设置-放大-图生图算法设置\n2.Upscale放大脚本_SD放大 简便方法-\n图块重叠像素64——起到四张图片融合的缓冲带的作用\n高度-宽度分别增加64，\n然后开始。\n画面会混乱\n[1]如果脸在切割的地方 -降低重绘幅度-增大图块重叠度\n3.附加功能放大 人工智能算法修复\n一般成品的算法修复\n也可以不选Upscaler 2\n[2 [坑]下面的三个比较复杂 局部重绘 1.随机种子+咒语修改的问题\n即使随机种子一致，但是咒语还是修改了，出现了画面不可控的样子\n所以会有，不同姿势等问题\n如果是已经经过了高清修复和放大，那么要耗费的时间就更长了\n99%都是满意的，1% 直接点击-局部重绘，其他素材图片也可以 修改咒语+重绘幅度修改\n会出现笔尖，涂抹好重绘区域\n下方参数设置\n重绘过程：整个图片经历了重新加噪然后去噪的过程。\n眼睛部分被强调了，最后的效果是只针对这个区域的重绘了\n局部修复参数 1.蒙版： 可以写填充\n【坑】潜变量噪声、潜变量数值零 简答说：图生图的过程进一步复杂化、加入加噪、去噪的过程。\n理论上对图像的改变会更显著\n2.全图、3.仅蒙版\n2.全图： 基于新的要求（提示词、参数）把图重新画一遍【我觉得受到重绘幅度的影响】，尽管没涂的部分修改很小，但是还是有点点点点\n最后只保留你涂的部分拼回去\n3.仅蒙版: 就是只画框选出来的区域附近，速度快，但是没有基于图像全貌画。然后再拼回去。把这一小块当做一幅画来画。\n[坑]针对性强的修改、反而需要修改图片的尺幅：降低重绘幅度避免变形，并对提示词净化处理。 1.仅蒙版模式的边缘预留像素 4.蒙版模糊——类似羽化 消除硬接触的边缘\n10以下比较好\n太大会影响区域的读取或影响周边其他区域\n区域大可以增大，区域小可以缩小。\n局部重绘进阶 [1]inPaintSketch（手涂蒙版） 调色盘按钮\n修复的坏的手等 加蓝色爱心口罩 调色盘按钮—选黑色—画口罩——\n重绘幅度可以稍大\n蓝色\n咒语中权重降低了，因为咒语的东西复杂了，让它更稳定的产出\n玩法无限可能性大 吸管吸取背景，覆盖手的颜色，然后用肉色把手勾勒出来。\n正向提示词用上，击掌等\n负面提示词中用Negative Embeddings\n1.蒙版透明度 颜色映在图片上的透明度\n降低重绘幅度——因为太大了会让手部线条模糊+蒙版模糊也不宜过大\n如果不满意，那么随机种子多试试。\n单独使用Sketch（绘图） 直接使用Sketch\n然后重新对整个图进做一个完整的图生图，肯定会对原图有影响。\n——灵魂画手功能的实现可以用这个 不想影响就用局部修复即可 [2]上传蒙版功能应用 上传蒙版区域\nPS主体的对象选择工具，框选工具，会自动框选出来，然后套索工具-alt-ctrl-可以增加减少\n然后再\n先定义为白色\n然后选中填充的图层复制一个\n然后双击该图层前面的小白方块、填充颜色改为黑\n单机长方形\n这个长方形就是PS的蒙版了\n选中ctrl+I交换蒙版区域，就黑白换过来了。\n就导出来PNG、jpg就可了。\n人为代替了蒙版选择的了\n[坑]其他软件进行关联，无穷的潜力挖掘 更为精确的手部修复。\n总结 1.SD（Stable Diffusion）基本操作：\n使用菜单选择不同的模型（Checkpoint）。 包括 Lora 模型，提供更精确的人物或画风控制。 2.图生成图：\n上传图片并描述，使用 DeepBooru 算法反推标注。\n调整重绘幅度和分辨率，生成无缝贴图。\n包括聚焦剪裁、中央剪裁等操作，通过观察损失值调整训练过程。\n3.Prompt模板和提示词：\n设计提示词模板，权重分配和增强减弱方法。 4.VAE（Variational Auto Encoder）：\n使用加噪和去噪处理转换潜空间数据为正常图像。 5.Hypernetwork超网络模型：\n改进画面整体风格，与Lora类似但更适合创造新元素。 .6Embeddings嵌入式向量：\n优化画风，通过小文件链接到特定形象。 7.LoRa低秩适应模型：\n固定特定人物角色特征，更清晰地表达形象。 8.模型下载渠道：\nHugging Face、C站等平台获取和共享模型和数据集。 ","date":"2024-06-09T11:54:39Z","image":"http://localhost:1313/post/before/image-20240607184336146.png","permalink":"http://localhost:1313/post/sd/","title":"Stable Diffusion笔记"},{"content":"Typlog 的相册语法 介绍了图像处理中的形态学操作，以及如何使用OpenCV库来执行这些操作。括腐蚀、膨胀、开运算、闭运算、梯度运算、顶帽运算和黑帽运算。每种操作都有不同的效果和应用。\n一、噪声处理的基本操作 1.腐蚀 让图像沿着自己边界向内收缩，OpenCV通过核（kernel）来实现收缩计算。\n在形态学中，可以理解为由N个像素组成的像素块，（每一个像素块，包含一个核（kernel））在图像的边缘移动，移动的过程中，核将会在图像的边缘抹除图像和核（kernel）重合但又没有越过核心（kernel）的像素点抹除。\r例子一、消除仙人掌的刺 import cv2 import numpy as np img =cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((3,3),np.uint8)#3*3矩阵定义核的大小 cv2.imshow( \u0026#34;img\u0026#34;,img) dst=cv2.erode(img,k)#腐蚀 cv2.imshow(\u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllwindows( ) dst=cv2.erode(src,kernel,anchor,iterations,borderType,borderValue) 参数说明: src原始图像 kernel腐蚀使用的核 anchor可选参数 核的锚点位置 iterations可选参数 腐蚀操作的迭代次数，默认值为1，后面两个参数建议采用默认\n2.膨胀 膨胀操作与腐蚀操作相反，膨胀操作可以让图像沿着自己的边界向内扩张。\r同样是通过核来计，当核在图像的边缘移动时，核会将图像边缘填补新的像素\rimport cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((9,9),np.uint8) cv2.imshow( \u0026#34;img\u0026#34;,img) dst=cv2.dilate(img, k) cv2.imshow( \u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllwindows() ​```Python dst=cv2.dilate(src,kernel,anchor,iterations,borderType,borderValue)\\ 参数说明如下\nsrc原始图像 kernel膨胀使用的核 anchor可选参数核的锚点位置 iterations可选参数膨胀操作的迭代次数 后面两个为可选参数建议取默认值\n膨胀可以产生一种“近视眼”的效果。\n3.开运算 开运算是将图像先进行腐蚀操作，再进行膨胀操作。\r开运算可以用来抹除图像外部的细节。\n#开运算 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\tzzy.png\u0026#34;) k=np.ones((6,6),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img \u0026#34; ,img) dst=cv2.erode(img,k)#腐蚀操作 dst=cv2.dilate(dst,k)#膨胀操作 cv2.imshow( \u0026#34;dst\u0026#34;,dst) cv2.waitKey() cv2.destroyAllWindows() 4.闭运算 闭运算是将图像先进行膨胀操作，再进行腐蚀操作。\r闭运算可以抹除图像内部的细节。\n#闭运算 import cv2 import numpy as np img = cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img, (900, 900)) k = np.ones((9,9),np.uint8) cv2.imshow(\u0026#34;img\u0026#34;,img) dst = cv2.dilate(img,k) dst = cv2.erode(dst,k) cv2.imshow(\u0026#34;dst2\u0026#34;,dst) cv2.waitKey() cv2.destroyAllWindows() 二、形态学其他方法： 腐蚀和膨胀都是形态学的基础操作，开运算和闭运算是两种方法的运用。除了这两种方法外，形态学还有集中比较有特点的运算，OpenCV提供了一个morphologyEx方法\r英 [mɔːˈfɒlədʒi] 美 [mɔːrˈfɑːlədʒi]\nmorphologyEx(src,op,kernel,anchor) src 原始图像\nop 操作类型\nkernel 操作过程中使用的核\nanchor 核锚点的位置\n操作类型如下：\n参数值 含义 cv2.MORPH_ERODE 腐蚀操作 cv2.MORPH_DILATE 膨胀操作 cv2.MORPH_OPEN 开运算，先腐蚀后膨胀 cv2.MORPH_CLOSE 闭运算，先膨胀后腐蚀 cv2.MORPH_GRADIENT 梯度运算，膨胀图减腐蚀图 cv2.MORPH_TOPHAT 顶帽运算，原始图减开运算图 cv2.MORPH_BLACKHAT 黑帽运算，闭运算图减原始图 1.梯度运算 梯度是指图像梯度，可以简单理解为像素的变化程度。几个连续的像素，像素的跨度值越大，梯度值就越大。\r梯度运算就是，膨胀图减去腐蚀图，就是将扩张的膨胀图挖去收缩过的腐蚀图。\r梯度运算可以得到原图的轮廓。\n#梯度运算，得到简笔画的轮廓 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img,(600,600)) k=np.ones((5,5),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img\u0026#34; ,img) #进行梯度运算 dst=cv2.morphologyEx(img,cv2.MORPH_GRADIENT,k) cv2.imshow( \u0026#34;dst\u0026#34; ,dst)#显示梯度运算结果 cv2.waitKey() cv2.destroyAllwindows( ) 兔子为实心线条，膨胀-腐蚀后，所以会在兔子周围形成两条线。\n2.顶帽运算 原图减去原图的开运算图，就是用有细节的原图挖去去除外部细节的开运算图。也就是只剩下外部细节的图。\r顶帽运算=原图-开运算图形=外部细节图\n#顶帽运算，原图减开运算图 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\xtz.png\u0026#34;) k=np.ones((10,10),np.uint8) cv2.imshow( \u0026#34;img\u0026#34; ,img) dst=cv2.morphologyEx(img,cv2.MORPH_TOPHAT,k) cv2.imshow( \u0026#34;dst\u0026#34; ,dst) cv2.waitKey() cv2.destroyAllwindows() 3.黑帽运算 原图的闭运算减去原图，也就是去除内部细节的图挖去有内部细节的原图，只剩内部细节。\r黑帽运算=原图像-闭运算图像=内部细节图\n#黑帽运算 import cv2 import numpy as np img=cv2.imread(r\u0026#34;D:\\Program Files (x86)\\PyCharmProject\\pythonProject\\video-face\\rabbit.jpg\u0026#34;) img = cv2.resize(img,(600,600)) k=np.ones((3,3),np.uint8)#创建5*5的核 cv2.imshow( \u0026#34;img\u0026#34; ,img) #进行黑帽运算 dst=cv2.morphologyEx(img, cv2.MORPH_BLACKHAT,k) cv2.imshow( \u0026#34;dst\u0026#34;,dst)#显示黑帽运算结果 cv2.waitKey() cv2.destroyAllwindows() 三、总结 腐蚀操作：通过核来缩小图像中的对象，用于去除小细节或分离连接的对象。\n膨胀操作：通过核来扩大图像中的对象，用于填充空洞或连接对象。\n开运算：先腐蚀后膨胀，用于去除小物体，平滑边界，分离物体。\n闭运算：先膨胀后腐蚀，用于填充小孔，连接物体。\n梯度运算：膨胀图减腐蚀图，用于提取物体的边界。\n顶帽运算：原图减开运算图，用于提取图像中的细节。\n黑帽运算：闭运算图减原图，用于提取图像中的内部细节。\n这些形态学操作可以用于图像增强、去噪、分割和特征提取等应用。通过适当选择和组合这些操作，可以实现多种图像处理效果。\r","date":"2023-11-06T21:14:39Z","image":"http://localhost:1313/post/cover/tag-opencv.jpg","permalink":"http://localhost:1313/post/opencv/","title":"OpenCV中对图像噪声处理的常用形态学操作"},{"content":"流操作 是Java 8中引入的一种数据处理模式，通常涉及数据的读取、写入、转换、过滤等，这些操作可以在数据流上连续进行，形成一条处理链。\n例如：stream() 方法是 Java 8 引入的 Stream API 的一部分，它用于将集合（如数组、列表等）转换为流（Stream）。\n例如：能用max()和min()对流操作找到流中的最大元素。\n[参数:可用Comparator接口自定义比较的逻辑]\nimport java.util.Arrays; import java.util.Optional; import java.util.Comparator; public class StreamExample { public static void main(String[] args) { Integer[] numbers = {3, 1, 4, 1, 5, 9, 2, 6, 5}; // 使用默认比较器找到最大元素 Optional\u0026lt;Integer\u0026gt; max = Arrays.stream(numbers).max(); max.ifPresent(System.out::println); // 输出：9 // 使用默认比较器找到最小元素 Optional\u0026lt;Integer\u0026gt; min = Arrays.stream(numbers).min(); min.ifPresent(System.out::println); // 输出：1 // 使用自定义比较器找到最大元素（基于绝对值） Optional\u0026lt;Integer\u0026gt; maxAbs = Arrays.stream(numbers).max(Comparator.comparingInt(Math::abs)); maxAbs.ifPresent(System.out::println); // 输出：9 或 -5取决于绝对值的比较 } } 其中Optional\nOptional是Java8中引入的容器类，可以包含Integer对象或不含任何对象(空)。\n程序员可以避免在代码中出现大量的空值判断，从而减少了if-else控制判断的使用，提高了代码的健壮性和可读性。\n避免NullPointerException\n流操作的主要目的是简化数据处理和提高代码的可读性。通过使用流，程序员可以链式地应用一系列的操作，\n如过滤、映射、归约等，以实现对数据的转换和聚合。流操作还支持并行处理，可以充分利用多核处理器的优势，提高数据处理的速度。\n函数式编程 import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class FunctionalOperationExample { public static void main(String[] args) { // 创建一个整数列表 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 使用Stream API进行函数式操作 List\u0026lt;Integer\u0026gt; squaredEvenNumbers = numbers.stream() // 将列表转换为流 .filter(n -\u0026gt; n % 2 == 0) // 过滤出偶数 .map(n -\u0026gt; n * n) // 将每个偶数平方 .collect(Collectors.toList()); // 收集结果到新的列表 // 输出结果 squaredEvenNumbers.forEach(System.out::println); } } 整个操作链以声明性的方式描述了我们的意图：找到所有偶数并将它们平方。\n我们不需要显式地编写循环或条件语句，函数式操作提供了一种更加简洁、高效和可维护的编程方式。\n流式编程的声明性主要体现在其通过一系列的操作来定义数据的转换和聚合过程，而无需显式地编写复杂的控制流代码。这使得代码更加简洁、易于理解，并且关注点更集中于数据的处理逻辑，而非流程控制。\n下面是一个使用Java 8 Stream API进行流式编程的示例，该示例体现了流式编程的声明性：\n假设我们有一个包含员工信息的列表，每个员工都有姓名（String）和薪水（double）两个属性。我们想要找出薪水最高的员工。\n首先，我们定义一个简单的Employee类：\npublic class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public String getName() { return name; } public double getSalary() { return salary; } @Override public String toString() { return \u0026#34;Employee{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, salary=\u0026#34; + salary + \u0026#39;}\u0026#39;; } } 接下来，我们创建一个包含多个Employee对象的列表，并使用流式编程找出薪水最高的员工：\nimport java.util.Arrays; import java.util.List; import java.util.Optional; public class DeclarativeStreamingExample { public static void main(String[] args) { // 创建一个员工列表 List\u0026lt;Employee\u0026gt; employees = Arrays.asList( new Employee(\u0026#34;Alice\u0026#34;, 50000), new Employee(\u0026#34;Bob\u0026#34;, 60000), new Employee(\u0026#34;Charlie\u0026#34;, 45000), new Employee(\u0026#34;David\u0026#34;, 70000) ); // 使用流式编程找出薪水最高的员工 Optional\u0026lt;Employee\u0026gt; highestPaidEmployee = employees.stream() // 转换为流 .max((e1, e2) -\u0026gt; Double.compare(e1.getSalary(), e2.getSalary())); // 根据薪水比较员工 // 处理结果 highestPaidEmployee.ifPresent(emp -\u0026gt; { System.out.println(\u0026#34;Highest paid employee is: \u0026#34; + emp); }); } } 在这个例子中，我们使用了stream()方法将员工列表转换为一个流。然后，我们调用了max()方法，并传入了一个lambda表达式作为比较器，用于比较两个员工的薪水。max()方法会返回一个Optional对象，它可能包含薪水最高的员工（如果存在的话）。最后，我们使用ifPresent()方法来处理找到的员工（如果存在）。\n这个例子体现了流式编程的声明性，因为我们没有编写显式的循环或条件语句来遍历列表和比较元素。相反，我们通过调用一系列的方法（stream(), max(), ifPresent()）并传入必要的函数式接口实例（lambda表达式）来声明我们的意图。这种方式使得代码更加简洁和易于理解，同时也更容易进行扩展和修改。\n","date":"2023-03-28T11:08:00Z","image":"http://localhost:1313/post/cover/archives-java.png","permalink":"http://localhost:1313/post/java/","title":"流操作和函数式编程"},{"content":"JavaWeb\n1.基本概念 web开发\nweb，网页的意思\n静态Web html/cs 提供给所有人看的数据始终不会发生变化 动态web\n提供给所有人看的数据始终不会发生变化 技术栈：Servlet/JSP，ASP，PHP 在Java中，动态web资源开发的技术统称为JavaWeb\n1.2、web应用程序 web应用程序：可以通过浏览器访问的程序\na.html、 url：统一资源定位符，访问到的任何一个页面或资源都存在与这个世界的某一个角落的计算机上 这些统一的web资源会被放在同一个文件夹下，就是web应用程序了，需要以来tomcat服务器 一个web应用由多部分组成（静态、动态web） html，css，js jsp，servlet java程序 jar包 配置文件properties web应用程序编写完毕后，提供外界访问，需要一个服务器来统一管理 1.3静态web *.html，服务器存在，那么就能读取 Request和Response 请求到webService（网页服务器）\u0026ndash;\u0026gt;index\u0026gt;html\n这里重点\n缺点 web页面无法动态更新 轮播提。点击特效：为动态 JS实际开发中用的最多 VBscript 无法和数据库交互（数据无法持久化，用户无法交互） 1.4、动态web 页面会动态展示，\n页面服务器，页面服务器插件处理病毒什么的\n缺点 假如服务器动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布 停机维护 优点：动态更新，所有用户看到的不是同一个界面 访问数据库（数据持久化：注册、用户信息、商品信息） 新手村\u0026ndash;\u0026gt;魔鬼训练-（分析原理，看源码）\u0026ndash;\u0026gt;pk场\n1.5、web服务器 ASP\n微软：国内最早流行的是ASP\n在HTML中嵌入了VB脚本，ASP+COM\n在ASP开发中，基本的一个页面都会有几千行的页面代码，页面极其混乱\nC# lls，启动或关闭windows功能，里面能进行lls开发 php\nPHP开发速度很快，功能抢答，跨平台，代码简单（开源的模板引擎WordPress） 无法承载大量访问量的情况（局限性） jsp/servlet\nB/S：浏览和服务器 C/S：客户端和服务器 sun公司主推B/S架构,所有大公司,或者开源组件为java写的 基于Java语言 可以承载三高的问题带来的影响 语法像ASP 2.2web服务器 服务器是被动的操作,处理用户的请求和给用户一些相应信息。\ntomcat百度百科\n最新的Servlet和jsp规范总是在tomcat中得到体现，是一个Web应用服务器\n世界上运行jsp页面和Servlet\n1.安装\n2.配置文件和目录结构\n3.\njdk讲解17:03\njavaweb-02：web服务器讲解_哔哩哔哩_bilibili\n手写tomcat ","date":"0001-01-01T00:00:00Z","image":"http://localhost:1313/post/cover/archives-java.png","permalink":"http://localhost:1313/post/java/","title":""},{"content":"JDBC\n数据库驱动：电脑上能用，但是JAVA程序上需要驱动的。\n应用程序和数据库无法直接链接，所以需要数据库驱动。\n我们的程序会通过数据库驱动和数据库打交道。\n十种数据库是否需要十种数据库驱动？\n那么JDBC就出现了\nSUN公司为了简化开发人员的操作，（对数据库统一）的操作，提供了一个规范（java操作数据库）的规范，俗称JDBC。\n这些规范的实现由具体的厂商去做！\n对于开发人员来说只需要掌握，JDBC的接口即可。\n没有什么是加一层解决不了的。\n用户只需要连接JDBC，数据库厂商实现具体的驱动，开发人员只用掌握JDBC的接口操作即可。\n两个包\njava.sql（默认）\njavax.sql（默认）\nmysql-connector-java.\nMySQL :: Download MySQL Connector/J (Archived Versions)\n5.1.47\n写一个JDBC程序\n10.3第一个JDBC程序 38、第一个JDBC程序_哔哩哔哩_bilibili\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/jdbc/","title":""},{"content":"RAG 1.2一个完整的RAG链路\n从上图可以看到，线上接收到用户query后，RAG会先进行检索。\n检索(Retrieval)：检索 Chunks 和 query 一并输入到大模型，进而回答用户的问题。\nChunks：query和离线文档经过parser和splitter（orc）向量化（或称索引）——\u0026gt;到Datebase然后进行Retrieval——\u0026gt;检索到相关的Chunks\n第二次Retrieval——\u0026gt;输入query和相关的Chunks然后得到reanked的Chunks输入到LLM后得到Answer\nquery：在第一次Retrieval和第二次Retrieval的时候输入\n为了完成检索，需要离线将文档（ppt、word、pdf等）经过解析、切割甚至OCR转写，然后进行向量化存入数据库中。 接下来，我们将分别介绍离线计算和在线计算流程。\n1.2.1离线计算 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/rag/","title":""},{"content":"用户名root\nvnc登陆，密码是_1的那个\n创建git_1用户，用于git\n用户：git_1\n密码：6.29-gitone\n到这一步了：[git_1@VM-12-5-centos ~]$ git init \u0026ndash;bare hugo.git Initialized empty Git repository in /home/git_1/hugo.git/ [git_1@VM-12-5-centos ~]$\n基础操作 切换到rooot用户\nsu - root\n输入腾讯云的密码（root账号的密码_1的）\nNginx详解（一文带你搞懂Nginx）-CSDN博客\n全面解析｜搞懂Nginx这一篇就够了-阿里云开发者社区 (aliyun.com)\nNginx快速入门-KuangStudy-文章\nNginx | 程序开发与运维 (stonecoding.net)\n加权重\n架构上解决不了的问题，没有是加一层是解决不了的问题。JDBC也是如此\nnginx 高性能：响应更快和并发更高。占用内存少、并发能力强。\n反向代理： 1正向代理： 代理客户端的，本机上装的。 例如：\nVPN、访问不了外网的，为什么用了vpn就能用了，代理服务器帮助请求外部资源。\n请求内地-香港-美国-返回-香港-美国\n客户端的\n服务端的 反向代理： 代理服务器端的， 无感知去浏览一个服务器资源的，让服务器更好部署上线\n访问百度、背后不止一个服务器的，请求就是一个IP或者网址. 因为服务端有一个代理服务器。 2负载均衡： 64G、32G、16G服务器；\n权重、轮询和加权轮询。 请求就是依次轮询；\n加权轮询就是加了权重的轮询，很小内存的服务器也能正常上线。\nIPhash: Session保存在tomcat中，每个服务器中都有一个tomcat，而每个tomcat中的session不共享的。\nn个服务器n个tomcat\n一、加redis解决\n建议用redis做session共享。\n二、negix默认算法\nnegix的默认算法：\n小明的请求固定的IP固定永远请求到固定的服务器上。\nsession就不会丢失,但是该服务器挂了session就挂了。性能不是很好。\n所以不推荐用negix\n3动静分离 例如：bootstrap的jquery的js\n静态资源每次从jar包中加载很麻烦；\nnginx能做到静态资源的存储，提示访问速度。\nNginx安装 windows解压安装即可。\nconf的配置文件；\nnginx的config文件。\n里面的80端口，那么就会通过80端口。\n访问localhost:80端口是被监听的。\nhttp的默认端口就是80端口。\n05、Nginx安装-Linux_哔哩哔哩_bilibili whereis nginx 更换nginx默认端口 检查\ntar -zxvf 文件名称。\nconf配置文件\n输入 ./configure\n然后输入\nmake\n然后输入\nmake install\n也可以用yum安装。\n在这里看配置文件\ncd conf/\n检查linux防火墙和80端口安全组。\n启动： 配置中location中可以负载均衡配置，走不同的服务器。\n代中的代理：proxy_pass中访问在这个服务器中。\n端口重写 一个人真正的可怕是从他开始专注和聚焦开始，任何行业都是一年入门，三年得其要领，五年小有所成，十年才能成为高手。很多年轻人急于求成，先给自己定个三年小目标，在一个自己热爱的行业深耕，十年磨一剑。\n关于成长的几个阶段 第一见天地，也叫行万里路，从成年后可以离开家乡起，一定要花时间去祖国大江南北转转，不要嫌苦和累，有条件的，就去世界各地看看，了解最基础的地理知识。明白地域对于人的重要性。了解不同地域下塑造的不同文化语言，乡俗约定，思维习惯。 第二见众生，广交天下友，接触不同的人，总结不同的人性，层级，明白人的局限性，和各种人思维碰撞，了解每个人的生活方式，知道自己的层级，知道自己在哪，要去哪。 第三见自己，读万卷书，古往今来中外的各种书，寻找各种有价值的信息，不断的参悟，不断的对这个世界，在脑子中建模，什么不懂就去请教，哪里有疑惑就可以去查资料，不断的了解世界。\n好学校，去大厂做算法，普通学校，有机会去做算法（前提是你得手握顶会，且技能过硬）。不过最终大概率是技术流选择Java开发，躺平流选择考公，考编制，或者去国企\n宝塔的nginx 就是nginx.conf\n文件\nnginx的目录如下，nginx.conf是修改的主要内容。\nroot@stone ~]# rpm -ql nginx /etc/logrotate.d/nginx /etc/nginx /etc/nginx/conf.d /etc/nginx/conf.d/default.conf /etc/nginx/fastcgi_params /etc/nginx/mime.types /etc/nginx/modules /etc/nginx/nginx.conf /etc/nginx/scgi_params /etc/nginx/uwsgi_params /usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /usr/lib64/nginx /usr/lib64/nginx/modules /usr/libexec/initscripts/legacy-actions/nginx /usr/libexec/initscripts/legacy-actions/nginx/check-reload /usr/libexec/initscripts/legacy-actions/nginx/upgrade /usr/sbin/nginx /usr/sbin/nginx-debug /usr/share/doc/nginx-1.24.0 /usr/share/doc/nginx-1.24.0/COPYRIGHT /usr/share/man/man8/nginx.8.gz /usr/share/nginx /usr/share/nginx/html /usr/share/nginx/html/50x.html /usr/share/nginx/html/index.html /var/cache/nginx /var/log/nginx 一篇教你博客如何部署到自己的服务器 · Issue #243 · mqyqingfeng/Blog (github.com)\n重点参考 设置了git_1的这个用户\nwegt下载 问题 [git_1@VM-12-5-centos hugo]$ hugo version hugo: /lib64/libstdc++.so.6: version GLIBCXX_3.4.20' not found (required by hugo)\rhugo: /lib64/libstdc++.so.6: version CXXABI_1.3.8\u0026rsquo; not found (required by hugo) hugo: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21\u0026rsquo; not found (required by hugo)\n查看\nstrings /usr/lib64/libstdc++.so.6 | grep GLIBC\n解决报错‘version `GLIBCXX_3.4.20‘ not found’_version glibcxx not found-CSDN博客\n确实有用！！\n最新的Nginx+Hugo搭建博客并部署到服务器 | Ryn (devwl.com)\n基于docker搭建Hugo_hugo docker-CSDN博客\ndocker # 创建一个新的 hugo 站点 docker run \u0026ndash;rm -it \\ -v $(pwd)/src:/src \\ klakegg/hugo:latest-ext \\ \u0026ldquo;new site . \u0026ndash;force\u0026rdquo; 这是在做什么?\nChatGPT\n这个命令在用 Docker 创建一个新的 Hugo 站点。具体来说：\ndocker run --rm -it：运行一个 Docker 容器，并在容器退出后自动删除容器。-it 选项使容器以交互模式运行，这样你可以看到输出并进行交互。 -v $(pwd)/src:/src：将当前目录的 src 子目录挂载到 Docker 容器内的 /src 目录。$(pwd) 是一个命令替换，它会被替换成当前的工作目录路径。这个挂载让你可以在主机和容器之间共享文件。 klakegg/hugo:latest-ext：指定要使用的 Docker 镜像，这里使用的是 klakegg/hugo 镜像的最新扩展版。这个镜像包含了 Hugo 的最新版本以及一些额外的功能。 \u0026quot;new site . --force\u0026quot;：这是传递给 Hugo 的命令。new site . 会在当前目录（挂载的 /src 目录）中创建一个新的 Hugo 站点。--force 选项表示如果目标目录已经存在，则覆盖它。 总体而言，这个命令创建了一个新的 Hugo 站点，并将其存储在当前目录的 src 子目录中。\n4o mini\n我已经安装了hugo的docker如何使用呢？\nChatGPT\n如果你已经安装了 Hugo 的 Docker 镜像，你可以使用它来创建、构建和管理 Hugo 站点。以下是一些常见的操作及其对应的 Docker 命令：\n1. 创建一个新的 Hugo 站点 首先，进入你想要存放 Hugo 站点的目录，然后运行：\nsh\r复制代码\rdocker run --rm -it -v $(pwd):/src klakegg/hugo:latest-ext new site mysite 这里的 mysite 是你想要创建的站点目录名。这个命令会在当前目录下创建一个新的 Hugo 站点。\n2. 添加主题 在 Hugo 站点中添加主题：\nsh\r复制代码\rdocker run --rm -it -v $(pwd)/poolbee:/src klakegg/hugo:latest-ext new theme hugo-themestack-3.26.0 3. 生成站点 生成静态站点文件（通常是用于发布的内容）：\ndocker run \u0026ndash;rm -it -v $(pwd)/poolbee:/src klakegg/hugo:latest-ext\n4. 运行开发服务器 启动 Hugo 的开发服务器，以便在本地预览站点：\nsh 复制代码 docker run --rm -it -v $(pwd)/poolbee:/src -p 1313:1313 klakegg/hugo:latest-ext server 5. 查看 Hugo 版本 如果你需要查看安装的 Hugo 版本，可以运行：\nsh\r复制代码\rdocker run --rm -it klakegg/hugo:latest-ext version 6. 构建静态文件 如果你只是想构建静态文件而不启动开发服务器：\nsh\r复制代码\rdocker run --rm -it -v $(pwd)/mysite:/src klakegg/hugo:latest-ext -d public 这会将生成的静态文件放在 public 目录中。\n7. 指定配置文件 如果你有多个配置文件，或者配置文件不在默认位置，可以指定配置文件：\nsh\r复制代码\rdocker run --rm -it -v $(pwd)/mysite:/src klakegg/hugo:latest-ext --config myconfig.toml myconfig.toml 是你自定义的配置文件。\ndocker run \u0026ndash;rm -it -v $(pwd)/poolbee:/src klakegg/hugo:latest-ext new theme hugo-theme-stack-3.26.0\n基于docker搭建Hugo_hugo docker-CSDN博客\n使用Docker搭建Hugo博客 (lass.cc)\nDockerfile 是用来定义 Docker 镜像的构建过程的文件。它通常位于项目的根目录下，也可以根据需要放置在子目录中。以下是一些常见的做法：\n1. 在项目的根目录下创建 Dockerfile 这是最常见的做法。在你的项目的根目录下创建一个名为 Dockerfile 的文件，这样 Docker 就能轻松找到它。\nbash复制代码project-root/\r├── Dockerfile\r├── docker-compose.yml\r├── src/\r│ └── ... # Hugo 网站源代码\r├── themes/\r│ └── ... # Hugo 主题\r└── ... # 其他项目文件 2. 创建 Dockerfile 在根目录下创建一个名为 Dockerfile 的文件，然后将之前提供的 Dockerfile 内容写入到该文件中：\nDockerfile复制代码# Dockerfile\rFROM node:14-alpine as node_modules\rENV LANG en_US.UTF-8\rENV LANGUAGE en_US.UTF-8\rENV LC_ALL=en_US.UTF-8\rRUN echo \u0026#34;Asia/Shanghai\u0026#34; \u0026gt; /etc/timezone\rWORKDIR /app\rFROM klakegg/hugo:0.107.0-ext-alpine as hugo\rWORKDIR /src\rCOPY ./src/ /src/\r# 生成静态文件\rRUN hugo\r# nginx web 服务器\rFROM nginx:1.19.7-alpine\rRUN rm -rf /usr/share/nginx/html/*\rCOPY --from=hugo /src/public /usr/share/nginx/html 3. 使用 Dockerfile 构建镜像 在包含 Dockerfile 的目录下运行以下命令来构建 Docker 镜像：\nbash\r复制代码\rdocker build -t your-image-name . 4. 使用 Docker Compose 如果你有一个 docker-compose.yml 文件，可以在同一个目录下运行以下命令来构建和启动容器：\nbash\r复制代码\rdocker-compose up --build -d 5. 选择子目录 如果你想把 Dockerfile 放在一个子目录中，例如 docker 目录中，你需要在 docker-compose.yml 文件中指定 Dockerfile 的位置：\nDockerfile\nDockerfile复制代码# 这个文件放在 docker/ 目录下\rFROM node:14-alpine as node_modules\r... docker-compose.yml\nyaml复制代码version: \u0026#34;3\u0026#34;\rservices:\rserver:\rbuild:\rcontext: .\rdockerfile: docker/Dockerfile\rcontainer_name: hugo-server\rrestart: always\rports:\r- \u0026#34;20040:80\u0026#34; 确保 docker-compose.yml 文件的 build 部分的 context 指向项目的根目录，而 dockerfile 指向 Dockerfile 的实际路径。\n总结 通常情况下，将 Dockerfile 放在项目的根目录下是最简单的做法，这样你可以很方便地管理和构建 Docker 镜像。如果需要，可以根据项目的需求将 Dockerfile 放置在其他位置，并在 docker-compose.yml 中指定它的位置。\n真正的博客 Archives (lass.cc)\n使用Docker进行搭建WebStack-Hugo导航网站_hugo docker-CSDN博客\nDocker 什么是docker\n懂linux和springboot 什么是docker？\njava开发工作，必备的技能。\nspring——docker\n镜像、容器、操作命令\n即使再小的帆也能远航。\n容器数据卷 docker镜像 DockerFile(创作镜像) Docker网络原理 IDEA整合Docker 企业中集群\ndocker Compose Docker Swarm K8s和Docker Swarm\nCI\\CD 是如何做的 jenkins\n弱小无知不是生存的障碍，傲慢才是\n授人以渔\nDocker概述 为什么出现? 一款产品:开发\u0026ndash;上线 两套环境！\n应用环境,应用配置。\n开发即运维。\n环境配置十分麻烦的。\n（集群Redis、ES、Hadoop\u0026hellip;.）\n发布jar包或者war包 带上环境发布。 项目能不能带上环境安装打包？\n2、聊聊Docker为什么会出现_哔哩哔哩_bilibili\n配置麻烦，不能够跨平台。\n传统观念：开发jar，运维来做！\n现在：开发打包部署上线，一套流程做完。\nDocker给以上问题,提出解决方案。\n类比：\nJava-apk-发布应用商店-使用apk即可\njava-jar-打包代环境\nDocker思想——集装箱——隔离机制。\nDocker的历史 api小子和谈论历史\n2010年-美国成立的公司dotCloud做一些pass的云计算服务！\nlxc有关的容器技术！\n他们将自己的技术（容器化技术）命名为Docker！但是没有引起行业注意！docCloud，就活不下去了。那么\n开源代码 2013年开源！Docker越来越多人发现了docker的优点！火了，Docker每个月都会更新一个版本！\n2014年4月9日，Docker1.0发布！\n为什么这么火！轻巧！\n容器技术出来之前，我们都是使用的虚拟机技术！19G\n虚拟机：Vmware虚拟机多台一台电脑，但笨重！\nVM：linux centos原生镜像（一个电脑！）\r而docker：隔离，镜像用最核心的环境4m+jdk+mysql 十分的小巧，运行镜像就好了！小巧！几个M几个kb 秒级启动！ 聊聊Docker Docker是基于Go语言开发的！开源项目！\n基于官方文档学习 docker的文档是超级详细的\nDocker百度百科\nDocker能干嘛? 之前的虚拟机技术： 内核-库-APP 虚拟机技术：\n1.资源占用十分多\n2.冗余步骤多\n3.启动很慢\n容器化技术：\n不是模拟一个完整的操作系统。\n直接用在操作系统上，充分利用操作系统的资源。\n不同：\n传统虚拟机，虚拟一个硬件，运行一个完整的操作系统他，在系统上安装和运行软件。 容器内的引用hi直接运行在宿主机的上的，容器是没有自己的内容的，也没有虚拟硬件。 容器相互隔离，容器都有一个数以自己的文件系统，不糊影响。 DevOps（开发、运维） 更快速的交付和部署\n传统：一堆帮助文档，安装程序\nDocker：打包镜像发布测试，一键运行\n更便捷的升级和扩缩容\n使用了Docker之后，我们部署引用就和搭积木一样！\n项目打包为一个镜像，扩展——服务器A！服务器B！\n更简单的系统运维\n容器化之后，我们开发，测试环境都是高度一致的。\n更高效的计算资源利用\nDocker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例！服务器的性能能被压榨到极致。\n只要学不死，就往死里学！\nDocker安装 Docker的基本组成 Docker的架构图\nClient——服务器——仓库\nredis-server\nredis-client\n镜像：image\n相当于模板，用这个模板来创建容器服务，tomcat镜像==》run==》tomcat01容器（提供服务器），通过这个镜像可以创建多个荣去\n容器：container\nDocker的容器技术，独立运行一个或一组应用，通过镜像来创建的。\n启动，停止，删除，基本命令！\n目前就可以吧这个容器理解为一个建议的linux系统\n仓库：repository\n仓库就是存放镜像的地方。公有、私有仓库。\nDocker Hub（默认国外的）\n阿里云，华为都有容器服务器（配置镜像加速）\n安装Docker 1.需要linux基础\n2.CentOS 7\n3.Xshell连接远程服务器进行操作\ncd /\npwd\nclear\nuname -r\n最新版的docker3.10以上的\n[root@VM-12-5-centos ~]# cat /etc/os-release\rNAME=\u0026#34;CentOS Linux\u0026#34;\rVERSION=\u0026#34;7 (Core)\u0026#34;\rID=\u0026#34;centos\u0026#34;\rID_LIKE=\u0026#34;rhel fedora\u0026#34;\rVERSION_ID=\u0026#34;7\u0026#34;\rPRETTY_NAME=\u0026#34;CentOS Linux 7 (Core)\u0026#34;\rANSI_COLOR=\u0026#34;0;31\u0026#34;\rCPE_NAME=\u0026#34;cpe:/o:centos:centos:7\u0026#34;\rHOME_URL=\u0026#34;https://www.centos.org/\u0026#34;\rBUG_REPORT_URL=\u0026#34;https://bugs.centos.org/\u0026#34;\rCENTOS_MANTISBT_PROJECT=\u0026#34;CentOS-7\u0026#34;\rCENTOS_MANTISBT_PROJECT_VERSION=\u0026#34;7\u0026#34;\rREDHAT_SUPPORT_PRODUCT=\u0026#34;centos\u0026#34;\rREDHAT_SUPPORT_PRODUCT_VERSION=\u0026#34;7\u0026#34; 系统版本：\n帮助文档\n卸载旧文档\n#1卸载版本\rsudo yum remove docker \\\rdocker-client \\\rdocker-client-latest \\\rdocker-common \\\rdocker-latest \\\rdocker-latest-logrotate \\\rdocker-logrotate \\\rdocker-engine\r#2、需要的安装包\ryum install -y yum-utils\r#3、设置镜像仓库\ryum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\ryum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\r#更新yum软件包索引\r#4.安装docker\r#docker-ce社区版 ee企业版\ryum install docker-ce docker-ce-cli containerd.io\r#安装指定版本\r#启动docker\rsystemctl start docker\r#查看是否安装成功\rdocker version\r#测试hello-world\rdocker run hello-world [root@VM-12-5-centos ~]# docker run hello-world\r#首先查找镜像-没有，然后pull拉取镜像\rUnable to find image \u0026#39;hello-world:latest\u0026#39; locally\rlatest: Pulling from library/hello-world\rc1ec31eb5944: Pull complete Digest: sha256:1408fec50309afee38f3535383f5b09419e6dc0925bc69891e79d84cc4cdcec6\rStatus: Downloaded newer image for hello-world:latest\r#run运行起来了\r#这句话就是成功了\rHello from Docker!\rThis message shows that your installation appears to be working correctly.\rTo generate this message, Docker took the following steps:\r1. The Docker client contacted the Docker daemon.\r2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub.\r(amd64)\r3. The Docker daemon created a new container from that image which runs the\rexecutable that produces the output you are currently reading.\r4. The Docker daemon streamed that output to the Docker client, which sent it\rto your terminal.\rTo try something more ambitious, you can run an Ubuntu container with:\r$ docker run -it ubuntu bash\rShare images, automate workflows, and more with a free Docker ID:\rhttps://hub.docker.com/\rFor more examples and ideas, visit:\rhttps://docs.docker.com/get-started/\r#8、查看下载的hello-world镜像\rdocker images\r[root@VM-12-5-centos ~]# docker images\rREPOSITORY TAG IMAGE ID CREATED SIZE\rklakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB\rhello-world latest d2c94e258dcb 15 months ago 13.3kB #卸载docker\n#1.卸载docker依赖Docker Engine, CLI, containerd, and Docker Compose packages\rsudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras\r#2.删除资源\rrm -rf /var/lib/docker 阿里云镜像加速 容器加速服务 加速服务\n回顾hello-world docker run了之后发生了什么？\nDocker在本机上寻找镜像——判断本机是否有这个镜像——yes——使用运行这个镜像\n——no——Docker上取下载——DockerHub是否可以找到——yes——下载到这个镜像到本地\nno——找不到返回错误\n底层原理 Docker是怎么工作的？\nDocker 是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket客户端访问。\nDockerServer接收到Docker-Client的指令，就会执行这个命令。\n客户端命令-守护进程-产生Dokcer\nDocker为什么比虚拟机快？ 1.Docker有着比虚拟机更少的抽象层\n虚拟机变为了容器，直接在Docker Engine上跑\n2.docker利用的是宿主机的内核，vm需要是Guest OS\n所以新建容器的时候，docker不需要像虚拟机一样重新加载一个操作系统的内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个过程，秒级。\nNS隔离（容器隔离）\n现在都支持了。\n之后学习完毕后回过头看非常清晰。\nDocker常用命令 帮助命令: docker version docker info #显示系信息，包括镜像，容器数量 docker --help #万能所有命令 帮助文档下载地址：\nReference documentation | Docker Docs\n镜像命令 docker images docker images --help [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB #解释 REPOSITORY 镜像仓库源 TAG 镜像的标签 IMAGE ID 镜像的ID CREATED 镜像的创建时间 SIZE 镜像的大小 #可选项 -a,--all\t#列出所有镜像 -q\t--quite\t#只显示ID 官网可以搜索镜像，\ndocker search mysql\r#可选项，通过收藏过滤\r--filter=stars=3000\t#搜索出来的stars大于3000\r#下载镜像\rdocker pull\rdocker pull --help\rdocker pull mysql\rdocker pull mysql[:tag]\r#默认latest\r#下载的时候：分层下载，docker image的核心 联合文件系统 docker pull mysql:5.7 #下载5.7版本 共用了！！只需要更新了，不需要冲突的删除即可。\n这就是linux的联合文件系统。\n#删除某镜像 docker rmi -f 镜像images的id #递归id批量删除-删除全部的 docker rmi -f $(docker images -aq) #docker images查看所有镜像 docker images\n容器命令 说明：有了镜像才能创建容器。\n#下载一个centos基本镜像系统 docker pull centos #run命令的帮助 docker run --help 新建容器并启动\n#参数 --name=\u0026#34;Name\u0026#34;\t#容器名字 tomcat01 tomcat02 用来区分容器 -d\t#后台 -it #交互运行 进入容器查看内容 -p\t#指定容器端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口 -p 容器端口 容器端口 -p 随机指定端口 docker images\t#显示所有镜像 #测试，启动并进入容器 docker run -it centos /bin/bash linux的控制台一般在/bin下 #exit退出，从容器退回主机 exit #列出所有正在运行的容器 docker ps -a\t#列出正在运行、历史运行过的容器 -n=?\t#显示最近的?个容器 -q\t#只显示容器的编号 #删除镜像 docker rm mysql 7ce93a845a8a 退出容器 #退出 exit ctrl+p+q #退出容器不停止 此时就是没有停止，可以看到ps后查看所有正在运行的镜像，centos还在运行而没有停止。\n删除容器 docker rm 容器 容器的id docker rm -f $(docker ps -aq)#删除所有容器 docker ps -a -qixargs docker rm #删除所有容器 启动和停止容器的操作 docker start 容器id docker restart 容器id\t#重启 docker stop\t容器id\t#停止 docker kill 容器id\t#强制停止当前命令 停止\n常用的其他命令 后台运行 #docker run -d 镜像名 docker run -d centos #后台运行必须要有前台服务，没有服务就会自杀——易错 docker ps #查看后发现centos停止了 没有前台服务，exit后centos自动停止\n需要后台运行\n查看日志 docker logs --help\rdocker losgs -f -t --tail 容器id\t#查看所有日志和时间戳\rdocker ps docker run -it centos /bin/bash\rctrl+p+q\t#退出容器不停止 docker logs -f -t tail 10 容器id #最近10条日志 发现什么日志也没有，那么\n写个shell脚本。记录日志\ndocker run -d - centos /bin/sh -c \u0026ldquo;while trule;do echo kuangshen;sleep l;done\u0026rdquo;\n不停启动，然后循环\n#显示日志\ndocker ps\ndocker logs -f -t \u0026ndash;tail 10 容器id #10条日志\n#显示日志\n-tf 显示时间戳和log\n\u0026ndash;tail number #显示日志的条数\n查看容器top #top命令 docker ps docker top 容器id\t# UID用户id PID是进程id #!!!!!查看镜像源数据——显示容器的所有信息 发现 docker inspect --help 查看具体的操作 docker inspect 容器id #查看容器的源数据 !!!!进入当前正在运行的容器 #通常容器都是后台运行的，需要进行容器，修改一些配置 #-it：交互模式运行 docker exec -it 容器id bin/bash #2方式 docker attach -it 容器id #是进入正在运行的命令行 docker rm -f $(docker ps -aq)\t#删除所有 docker exec\t#进入容器后开启一个新的终端，可以在里面操作（常用）\ndocker attach\t#进入当前容器正在运行的终端，不会启动新的进程！\ndocker ps\ndocker images\ndocker run -it centos /bin/bash\n如何将容器内拷主机 cd /home touch kaugnsheng.java\rls\rdocker ps\rdocker attach 容器id\rcd /home\t#此时在容器内\rls\rtouch test.java\rexit\t#虽然容器停止了，但是数据还在\rdocker ps\rdocker ps -a\rdocer cp 容器id:/home/test.java /home\t#从容器拷贝到主机\rls 我的好像exit后容器好像还是在运行的必须要stop， 容器如果停止了，也可以拷贝出来。\n#拷贝是一个手动过程，后续可以使用-v 卷的技术，可以实现拷贝的自动的过程——把/home目录打通~ 小节 -p 和 -q\ndocker的命令是十分多的，学习的都是最常用的容器和镜像的命令。\n登陆上阿里云和dockfile直接生成镜像！\n接下来练习 用docker安装nginx\ndockerhub上搜索\nDocker Hub Container Image Library | App Containerization\n#1搜索镜像 #2下载镜像 [root@VM-12-5-centos home]# docker pull nginx 开放3344端口开放，公网的3344可以访问nginx01的80端口 docker run -d --name nginx01 -p 3344:80 nginx #-d 后台 #--name 给容器命名 #-p 宿主机:容器内端口 [root@VM-12-5-centos home]# docker run -d --name nginx01 -p 3344:80 nginx 15d98bf175044e55e9e5743165cf1fb1256c67c015ea6b0326dd27320b1b018a [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 26 seconds ago Up 25 seconds 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 18 minutes ago Up 18 minutes intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 24 hours ago Up 24 hours 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick #本机自测通过了——在宿主机上开启3344端口，相当于映射到了docker上的nginx的80端口 [root@VM-12-5-centos home]# curl localhost:3344 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [root@VM-12-5-centos home]# 端口暴露的概念\n现在在阿里云里就能localhost:3344访问到docker的nginx的80端口了\n进入容器操作\ndocker exec -it nginx01 /bin/bash\n如果阿里云防火墙安全组开了3344端口，那么外网是可以从：外网ip:3344可以访问到界面的。\n应该是可以的，我的nginx的配置应该有问题。\n思考：思考问题：我们每次改动gx配置文件，都需要进入容器内部？十分的麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？-v 数据卷！\n作业2 使用docker装tomcat\n作业3部署es(elastic)+kibana #eS暴露的端口多\r#es十分耗内存 可视化面板 portainer（先用这个） rancher（ci/cd）再用 图形化界面管理工具,提供一个后台面板供我们操作。\n外网8088端口\n开放外网端口 docker run -d -p 8088:9000\\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 安装后外网的8088端口、设置阿里云安全组，然后即可访问ui界面，看得到多少个镜像、容器在运行和端口映射关系。\n或者在curl localhost:8088然后在服务器中访问也可以。\n可视化面板。\n所有的应用，直接打包部署。\n如何得到镜像：\n远程仓库下载 朋友拷贝给你 自己制作镜像 理解分层管理 联合文件系统UnionFS 支持对文件系统的修改作为一次提交来一层层叠加。\ntomcat和mysql都要用到某个linux内核，那么就只会新增。\n层的概念，image+images\ndocker的镜像实际上是由一层层的文件系统组成的，这种层级的文件系统UnionFS\n黑屏\u0026mdash;开机的过程中没有了，那么这段时间都是公用的。 bootfs(boot file system)。没了\n精简的内核OS例如centos很小.\n分层 docker pull redis\n这一层已经存在了\ndocker image inspect redis:laest\n查看信息\n里面layers\n在layer记录\n打包的时候会有6个文件\n文件能实现替换，也能文件复用。\nredis的联合文件系统的表示\n在layer中也是6个\n所以docker是分层下载的。\n特点 run起来的东西可以修改，而镜像是无法修改的。\n如何提交自己的镜像\n如何commit镜像 docker commit 提交容器成为一个新的副本 #命令和git原理类似 docker commit -m \u0026#34;提交描述的消息\u0026#34; -a\u0026#34;作者\u0026#34; 举例：将tomcat的docker的webapps的内文件拷贝打牌webapps中，制作一个webapps中有文件的镜像\ndocker images\ndocker run -it -p 8080:8080 tomcat\t#启动docker-tomcat\n#1.启动了tomcat的前台 docker ps docker exec -it 容器id /bin/bash\t#进入了tomcat控制台 cd webapps ls cd.. ls cp -r webapps.dist/* webapps 发布\nroot@7803ab322d1d:/usr/local/tomcat/webapps# ls docs examples host-manager manager ROOT root@7803ab322d1d:/usr/local/tomcat/webapps# exit exit [root@VM-12-5-centos ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7803ab322d1d tomcat \u0026#34;catalina.sh run\u0026#34; 10 minutes ago Up 10 minutes 8080/tcp, 0.0.0.0:8081-\u0026gt;8081/tcp, :::8081-\u0026gt;8081/tcp cranky_payne 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 39 hours ago Up 39 hours intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick #4.将我们操作过的容器通过commit提交为一个新的镜像 [root@VM-12-5-centos ~]# docker commit -a=\u0026#34;kuangsheng\u0026#34; -m=\u0026#34;add webapps applalala\u0026#34; 7803ab322d1d tomcat02:1.0 sha256:73725f496f3b9c35005b2089ec45f577ed62958d9bf00ca0c3b91455bc683e34 [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 11 seconds ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos ~]# 类比学习VM的快照。\n弱小和无知不是生存的障碍，傲慢才是。 容器数据卷 什么是容器数据卷？ docker的理念回顾，应用和环境打包为一个镜像！\n数据？如果数据在容器中，那么将容器删除，数据就会丢失！需求：数据可以持久化\nMySQL，容器删了，删除跑路！需求：MySQL数据可以存储在本地\n卷技术就是这样！\n目录的挂在，将容器内的目录挂载到Linux上面！\n总结：容器的持久化和同步操作容器间也是可以数据共享的！ 使用数据卷 方法一、直接使用命令来挂载 -v docker run -it -v 主机目录:容器目录 #测试 [root@VM-12-5-centos home]# docker run -it -v /home/ceshi:/home centos /bin/bash #可以看到宿主机有了/ceshi目录 [root@VM-12-5-centos ~]# cd home -bash: cd: home: No such file or directory [root@VM-12-5-centos ~]# cd /home [root@VM-12-5-centos home]# ls ceshi git git_1 kaungsheng.java lighthouse PoolBee www [root@VM-12-5-centos home]# #centos的容器的/home目录 [root@VM-12-5-centos ~]# cd /homge -bash: cd: /homge: No such file or directory [root@VM-12-5-centos ~]# cd /home [root@VM-12-5-centos home]# ls git git_1 kaungsheng.java lighthouse PoolBee www [root@VM-12-5-centos home]# docker run -it -v /home/ceshi:/home centos /bin/bash [root@783df7f8b77c /]# cd /home [root@783df7f8b77c home]# ls [root@783df7f8b77c home]# #以后外部放的文件以后就会和docker的cenos的/home目录同步 #查看centos的容器的信息 [root@VM-12-5-centos home]# docker inspect 783df7f8b77c #Mount中 \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/home/ceshi\u0026#34;,#主机内地址 \u0026#34;Destination\u0026#34;: \u0026#34;/home\u0026#34;,#docker容器内地址 \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;rprivate\u0026#34; } ], #测试 #可以看到主机中是空的 [root@VM-12-5-centos home]# cd ceshi [root@VM-12-5-centos ceshi]# ls [root@VM-12-5-centos ceshi]# #在容器中创建test.java [root@783df7f8b77c home]# touch test.java [root@783df7f8b77c home]# #后续在主机中查看到传过来了！ [root@VM-12-5-centos ceshi]# ls [root@VM-12-5-centos ceshi]# ls test.java [root@VM-12-5-centos ceshi]# 同步的过程 如果容器停止，但是在Linux的文件夹更改，还是会同步到容器内绑定的文件夹！ #如果容器停止，但是在Linux的文件夹更改，还是会同步到容器内绑定的文件夹！ #1.让容器停止 [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Up 40 hours intelligent_lovelace 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick [root@VM-12-5-centos home]# stop 39fd379b5760 bash: stop: command not found... Similar command is: \u0026#39;top\u0026#39; [root@VM-12-5-centos home]# docker stop 39fd379b5760 39fd379b5760 [root@VM-12-5-centos home]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 39 hours ago Up 39 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick [root@VM-12-5-centos home]# #修改宿主机中的文件 #启动容器进行查看 [root@VM-12-5-centos home]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 09b5fac024a8 5d0da3dc9764 \u0026#34;/bin/bash\u0026#34; 2 minutes ago Exited (0) 2 minutes ago objective_noyce 783df7f8b77c centos \u0026#34;/bin/bash\u0026#34; 19 minutes ago Exited (0) 10 minutes ago affectionate_shaw 7803ab322d1d tomcat \u0026#34;catalina.sh run\u0026#34; 46 minutes ago Exited (130) 22 minutes ago cranky_payne 15d98bf17504 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 40 hours ago Up 40 hours 0.0.0.0:3344-\u0026gt;80/tcp, :::3344-\u0026gt;80/tcp nginx01 a17f2df4b0c2 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago eloquent_northcutt 223a694af194 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago magical_volhard 39fd379b5760 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 4 minutes ago intelligent_lovelace 28e3e9b4ecdf centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago unruffled_sinoussi f75f0b03f939 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago vigilant_euclid aa158bb7f0e1 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago elated_robinson d6dfa990d314 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago nervous_montalcini 9101ac141b0f centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (127) 40 hours ago competent_mcnulty 02cd07c4283d centos \u0026#34;/bin/basj\u0026#34; 40 hours ago Created upbeat_driscoll 9b872200a3b3 centos \u0026#34;/bin/bash\u0026#34; 40 hours ago Exited (0) 40 hours ago stoic_kepler 8512fca58a26 centos \u0026#34;/bin/basj\u0026#34; 40 hours ago Created hungry_sutherland 7fd5a54afd95 hello-world \u0026#34;/hello\u0026#34; 2 days ago Exited (0) 2 days ago cool_turing 726ca2e767ff klakegg/hugo:latest-ext \u0026#34;hugo server\u0026#34; 2 days ago Up 2 days 0.0.0.0:1313-\u0026gt;1313/tcp, :::1313-\u0026gt;1313/tcp affectionate_golick 59e514225874 klakegg/hugo:latest-ext \u0026#34;hugo\u0026#34; 2 days ago Exited (255) 2 days ago confident_bassi [root@VM-12-5-centos home]# docker start 783df7f8b77c 783df7f8b77c [root@VM-12-5-centos home]# docker attach 783df7f8b77c [root@783df7f8b77c /]# cd /home [root@783df7f8b77c home]# ls test.java [root@783df7f8b77c home]# cat test/java cat: test/java: No such file or directory [root@783df7f8b77c home]# cat test.java hello linux update [root@783df7f8b77c home]# #可以看到成功了！ 好处：以后在本地修改，容器中会自动同步。\n实战：安装MySQL 思考：MySQL的数据持久化问题！\n#下载mysql #docker search mysql #进官网看版本 #docker pull mysql:5.7 [root@VM-12-5-centos home]# docker pull mysql:5.7 5.7: Pulling from library/mysql 20e4dcae4c69: Downloading [=============\u0026gt; ] 13.71MB/50.5MB 1c56c3d4ce74: Download complete e9f03a1c24ce: Download complete 68c3898c2015: Download complete 6b95a940e7b6: Download complete 90986bb8de6e: Download complete ae71319cb779: Waiting ffc89e9dfd88: Download complete 43d05e938198: Waiting 064b2d298fba: Waiting df9a4d85569b: Waiting [root@VM-12-5-centos home]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 49 minutes ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos home]# #运行容器进行数据挂载 #安装启动mysql，要配置【用户密码】 #去docker hub找mysql [root@VM-12-5-centos home]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 49 minutes ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 4d55165721b1195ccfb240b39dcf2f5cb9d8edd50095305d4197ae55391fbf5b [root@VM-12-5-centos home]# #启动我们的mysql -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 --name 容器名字 mysql - Official Image | Docker Hub\n官网中\n$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag -e MYSQL_ROOT_PASSWORD=123456 \u0026ndash;name mysql01 mysql:5.7\n-e 就是配置环境，那么这里就是设置密码\n新建Mysql连接 阿里云安全组，本地防火墙都看了吗，这是最基本的 且要保证这个是有程序占用的！\n#云服务器LinuxCentos上打开3306,命令行打开或图形化界面打开 #腾讯云安全组设置，本机windows设置防火墙设置出站规则 [root@VM-12-5-centos home]# firewall-cmd --permanent --add-port=3306/tcp success [root@VM-12-5-centos home]# firewall-cmd --reload success [root@VM-12-5-centos home]# 宝塔面板中可以看到状态，而腾讯云的看不到\n重启服务器然后在宝塔中查看状态不行。\n已经下载了mysql5.7镜像，然后又删除了原本的mysql01容器，然后重新根据景象创建，成功了！ [root@VM-12-5-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 2 hours ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 docker: Error response from daemon: Conflict. The container name \u0026#34;/mysql01\u0026#34; is already in use by container \u0026#34;4d55165721b1195ccfb240b39dcf2f5cb9d8edd50095305d4197ae55391fbf5b\u0026#34;. You have to remove (or rename) that container to be able to reuse that name. See \u0026#39;docker run --help\u0026#39;. [root@VM-12-5-centos ~]# stop mysql01 bash: stop: command not found... Similar command is: \u0026#39;top\u0026#39; [root@VM-12-5-centos ~]# docker stop mysql01 mysql01 [root@VM-12-5-centos ~]# [root@VM-12-5-centos ~]# docker rm mysql01 mysql01 #两个容器数据卷进行挂载 # -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql #1.宿主机/home/mysql/conf---\u0026gt;docker的/etc/mysql/conf.d mysql的配置文件 #2.宿主机/home/mysql/data---\u0026gt;docker的/var/lib/mysql mysql的数据文件 [root@VM-12-5-centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 f669f7ef2710692ff207cd5b8889e77289d3631e5419e494ad056fd0e405f504 [root@VM-12-5-centos ~]# #启动成功后本地是有sqlyog来测试 #sqlyog--连接到服务器的3310--3310和容器中的3306映射，这个时候可以连接上了 本地创建了数据库看映射是否正确！ 以后mysql改配置在conf中修改 假设删除容器后，宿主机挂载的数据还是在的。实现了容器数据持久化功能。 docker yog中创建了一个数据库test，在这里可以看到test\n出现了\n#容器中 [root@VM-12-5-centos ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f669f7ef2710 mysql:5.7 \u0026#34;docker-entrypoint.s…\u0026#34; 14 minutes ago Up 14 minutes 33060/tcp, 0.0.0.0:3310-\u0026gt;3306/tcp, :::3310-\u0026gt;3306/tcp mysql01 [root@VM-12-5-centos ~]# docker run -it mysql /bin/bash Unable to find image \u0026#39;mysql:latest\u0026#39; locally ^C [root@VM-12-5-centos ~]# docker run -it mysql01 /bin/bash Unable to find image \u0026#39;mysql01:latest\u0026#39; locally ^C [root@VM-12-5-centos ~]# docekr exec -it f669f7ef2710 bin/bash bash: docekr: command not found... Similar command is: \u0026#39;docker\u0026#39; [root@VM-12-5-centos ~]# docker exec -it f669f7ef2710 bin/bash bash-4.2# cd /var/lib/mysql bash-4.2# ls auto.cnf ca.pem client-key.pem ib_logfile0 ibdata1 mysql performance_schema public_key.pem server-key.pem test ca-key.pem client-cert.pem ib_buffer_pool ib_logfile1 ibtmp1 mysql.sock private_key.pem server-cert.pem sys bash-4.2# #宿主机中 [root@VM-12-5-centos /]# cd data [root@VM-12-5-centos data]# ls [root@VM-12-5-centos data]# cd .. [root@VM-12-5-centos /]# cd /home/mysql/data [root@VM-12-5-centos data]# ls auto.cnf ca.pem client-key.pem ibdata1 ib_logfile1 mysql performance_schema public_key.pem server-key.pem test ca-key.pem client-cert.pem ib_buffer_pool ib_logfile0 ibtmp1 mysql.sock private_key.pem server-cert.pem sys [root@VM-12-5-centos data]# 删除容器后，宿主机挂载的数据还是在的。实现了容器数据持久化功能。\n官方名词：具名和匿名挂载 #匿名挂载 -v 容器内路径 docker run -d -p --name nginx01 -v /etc/nginx nginx docker volume --help docker volum ls\t#查看所有volum的镜像 docker volume ls\n这些都是匿名卷，每一个VOLUME NAME\n只写了容器内的路径，没有写容器外的路径。\n具名挂载 #具名挂载 #通过 -v 卷名:容器内路径 ls docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx nginx #juming-nginx这个代表是-v的名字VOLUMN NAME而不是路径。 #看一下这个卷 #是在/var/lib/docker/volumes/juming-nginx/_data #\t里面就是默认的具名挂载的位置 #/var/lib/docker/volumes\t所有卷存储的位置 #/var/lib/docker\tdocker的所有的文件 总结 #如何确定是具名挂载还是匿名挂载，还是指定路径挂载！ -V容器内路径 #匿名挂载 -V卷名：容器内路径 #具名挂载 -V/宿主机路径：：容器内路径#指定路径挂载！ 拓展： #通过 -v 容器内路径:ro rw 改变读写权限 ro readonly\t#只读 rw\treadwrite\t#可读可写 docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx:ro nginx docker run -d -P(随机映射端口) --name nginx02 -v juming-nginx:/etc/nginx:rw nginx #ro 只要看到ro说明路径只能通过宿主机来操作，容器内部是无法操作的。 初识DockerFile 是用来构建docker镜像的构建文件！命令脚本！\n体验一下：通过 这个脚本生成镜像\n镜像是一层层的，脚本是一层层的，每个命令都是一层\nFROM centos VOLUME [\u0026#34;volume01\u0026#34;,\u0026#34;volume02\u0026#34;] CMD echo \u0026#34;---end---\u0026#34; CMD /bin/bash #这里的每个命令就是镜像的一层。 创建了自己的镜像\n#创建dokcerfile文件 #文件中的内容，指令（大写） 参数 [root@VM-12-5-centos docker-test-volume]# pwd /home/docker-test-volume [root@VM-12-5-centos docker-test-volume]# vim dockerfile1 [root@VM-12-5-centos docker-test-volume]# cat dockerfile1 FROM centos VOLUME [\u0026#34;volume01\u0026#34;,\u0026#34;volume02\u0026#34;] CMD echo \u0026#34;---end---\u0026#34; CMD /bin/bash [root@VM-12-5-centos docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t kuangsheng/centos . [+] Building 0.2s (5/5) FINISHED docker:default =\u0026gt; [internal] load build definition from dockerfile1 0.0s =\u0026gt; =\u0026gt; transferring dockerfile: 118B 0.0s =\u0026gt; [internal] load metadata for docker.io/library/centos:latest 0.0s =\u0026gt; [internal] load .dockerignore 0.0s =\u0026gt; =\u0026gt; transferring context: 2B 0.0s =\u0026gt; [1/1] FROM docker.io/library/centos:latest 0.0s =\u0026gt; exporting to image 0.0s =\u0026gt; =\u0026gt; exporting layers 0.0s =\u0026gt; =\u0026gt; writing image sha256:2771b5374df0a3d1fec5d343805c3291ee35f76cf68d2b731a421cb308eae93f 0.0s =\u0026gt; =\u0026gt; naming to docker.io/kuangsheng/centos 0.0s [root@VM-12-5-centos docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t kuangsheng/centos1.0 . [+] Building 0.1s (5/5) FINISHED docker:default =\u0026gt; [internal] load build definition from dockerfile1 0.0s =\u0026gt; =\u0026gt; transferring dockerfile: 118B 0.0s =\u0026gt; [internal] load metadata for docker.io/library/centos:latest 0.0s =\u0026gt; [internal] load .dockerignore 0.0s =\u0026gt; =\u0026gt; transferring context: 2B 0.0s =\u0026gt; CACHED [1/1] FROM docker.io/library/centos:latest 0.0s =\u0026gt; exporting to image 0.0s =\u0026gt; =\u0026gt; exporting layers 0.0s =\u0026gt; =\u0026gt; writing image sha256:2771b5374df0a3d1fec5d343805c3291ee35f76cf68d2b731a421cb308eae93f 0.0s =\u0026gt; =\u0026gt; naming to docker.io/kuangsheng/centos1.0 0.0s [root@VM-12-5-centos docker-test-volume]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 3 hours ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB kuangsheng/centos1.0 latest 2771b5374df0 2 years ago 231MB kuangsheng/centos latest 2771b5374df0 2 years ago 231MB centos latest 5d0da3dc9764 2 years ago 231MB [root@VM-12-5-centos docker-test-volume]# #启动自己的容器 docker images docke run -it 容器id /bin/bash [root@86108f3c0937 /]# ls -l total 56 lrwxrwxrwx 1 root root 7 Nov 3 2020 bin -\u0026gt; usr/bin drwxr-xr-x 5 root root 360 Aug 5 10:35 dev drwxr-xr-x 1 root root 4096 Aug 5 10:35 etc drwxr-xr-x 2 root root 4096 Nov 3 2020 home lrwxrwxrwx 1 root root 7 Nov 3 2020 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 Nov 3 2020 lib64 -\u0026gt; usr/lib64 drwx------ 2 root root 4096 Sep 15 2021 lost+found drwxr-xr-x 2 root root 4096 Nov 3 2020 media drwxr-xr-x 2 root root 4096 Nov 3 2020 mnt drwxr-xr-x 2 root root 4096 Nov 3 2020 opt dr-xr-xr-x 190 root root 0 Aug 5 10:35 proc dr-xr-x--- 2 root root 4096 Sep 15 2021 root drwxr-xr-x 11 root root 4096 Sep 15 2021 run lrwxrwxrwx 1 root root 8 Nov 3 2020 sbin -\u0026gt; usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 2020 srv dr-xr-xr-x 13 root root 0 Aug 5 10:35 sys drwxrwxrwt 7 root root 4096 Sep 15 2021 tmp drwxr-xr-x 12 root root 4096 Sep 15 2021 usr drwxr-xr-x 20 root root 4096 Sep 15 2021 var drwxr-xr-x 2 root root 4096 Aug 5 10:35 volume01 drwxr-xr-x 2 root root 4096 Aug 5 10:35 volume02 [root@86108f3c0937 /]# 自动挂载的两个数据卷目录。\n进入容器的volume01目录，创建文件，测试容器内的volume01是否和宿主机的docker的默认volume存储路径下的随机目录下的volume01文件是否同步。\n而且\nVOLUME [\u0026ldquo;volume01\u0026rdquo;,\u0026ldquo;volume02\u0026rdquo;]一定是个匿名挂载。所以查看位置\n从宿主机的docker的默认volume存储路径下（inspect可以查看容器信息，M中有volume01和02的存储在宿主机的docker的默认volume存储路径下的随机目录位置）\n#查看镜像 [root@VM-12-5-centos docker-test-volume]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 3 hours ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB kuangsheng/centos1.0 latest 2771b5374df0 2 years ago 231MB kuangsheng/centos latest 2771b5374df0 2 years ago 231MB centos latest 5d0da3dc9764 2 years ago 231MB #进入容器 [root@VM-12-5-centos docker-test-volume]# docker run -it 2771b5374df0 /bin/bash [root@86108f3c0937 /]# ls -l total 56 lrwxrwxrwx 1 root root 7 Nov 3 2020 bin -\u0026gt; usr/bin drwxr-xr-x 5 root root 360 Aug 5 10:35 dev drwxr-xr-x 1 root root 4096 Aug 5 10:35 etc drwxr-xr-x 2 root root 4096 Nov 3 2020 home lrwxrwxrwx 1 root root 7 Nov 3 2020 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 Nov 3 2020 lib64 -\u0026gt; usr/lib64 drwx------ 2 root root 4096 Sep 15 2021 lost+found drwxr-xr-x 2 root root 4096 Nov 3 2020 media drwxr-xr-x 2 root root 4096 Nov 3 2020 mnt drwxr-xr-x 2 root root 4096 Nov 3 2020 opt dr-xr-xr-x 190 root root 0 Aug 5 10:35 proc dr-xr-x--- 2 root root 4096 Sep 15 2021 root drwxr-xr-x 11 root root 4096 Sep 15 2021 run lrwxrwxrwx 1 root root 8 Nov 3 2020 sbin -\u0026gt; usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 2020 srv dr-xr-xr-x 13 root root 0 Aug 5 10:35 sys drwxrwxrwt 7 root root 4096 Sep 15 2021 tmp drwxr-xr-x 12 root root 4096 Sep 15 2021 usr drwxr-xr-x 20 root root 4096 Sep 15 2021 var drwxr-xr-x 2 root root 4096 Aug 5 10:35 volume01 drwxr-xr-x 2 root root 4096 Aug 5 10:35 volume02 #看得到自己创建的镜像中有volume01和volume02 #1.查看匿名挂载的路径 [root@VM-12-5-centos ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 86108f3c0937 2771b5374df0 \u0026#34;/bin/bash\u0026#34; 16 minutes ago Up 16 minutes inspiring_herschel f669f7ef2710 mysql:5.7 \u0026#34;docker-entrypoint.s…\u0026#34; About an hour ago Up About an hour 33060/tcp, 0.0.0.0:3310-\u0026gt;3306/tcp, :::3310-\u0026gt;3306/tcp mysql01 [root@VM-12-5-centos ~]# docker inspect 86108f3c0937 #可以看到 \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;af212811e19c881aa2e1312de4831e5c1714828543b623ea40d7ff1b43d76806\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/af212811e19c881aa2e1312de4831e5c1714828543b623ea40d7ff1b43d76806/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;volume01\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;19f9e9a6dc7a7606d7b2981ffeaa3d95b94228c61d37607add71622e3187bae5\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/19f9e9a6dc7a7606d7b2981ffeaa3d95b94228c61d37607add71622e3187bae5/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;volume02\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;\u0026#34; } ], #包含有宿主机中的docker的volume存储路径，以及volume01和02的匿名存储路径 #/var/lib/docker/volumes/af212811e19c881aa2e1312de4831e5c1714828543b623ea40d7ff1b43d76806/_data #/var/lib/docker/volumes/19f9e9a6dc7a7606d7b2981ffeaa3d95b94228c61d37607add71622e3187bae5/_data\u0026#34; #2.测试文件是否同步 #在自己创建的docker中进入volume01创建continer.txt [root@86108f3c0937 /]# cd /volume01 [root@86108f3c0937 volume01]# mkdir continer.txt [root@86108f3c0937 volume01]# ls #通过进入容器，然后从容器信息中获得匿名挂载的volume01的宿主机的docker默认volume(容器数据卷)存储路径。 #进入后查看 #/var/lib/docker/volumes/af212811e19c881aa2e1312de4831e5c1714828543b623ea40d7ff1b43d76806/_data [root@VM-12-5-centos ~]# cd /var/lib/docker/volumes/af212811e19c881aa2e1312de4831e5c1714828543b623ea40d7ff1b43d76806/_data [root@VM-12-5-centos _data]# ls continer.txt [root@VM-12-5-centos _data]# #成功！ 自己构建镜像的时候，要手动镜像挂在 -v 卷名:容器内路径。\n数据卷容器（多个容器之间同步） 两个Mysql同步数据、多个Mysql同步数据！\n被挂载的容器叫做数据卷容器\n或者多个容器之间实现数据共享\n#启动3个容器，通过我们自己写的镜像启动 [root@VM-12-5-centos _data]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 73725f496f3b 3 hours ago 466MB tomcat latest 2a60d35653ea 10 days ago 461MB nginx latest a72860cb95fd 6 weeks ago 188MB mysql 5.7 5107333e08a8 7 months ago 501MB klakegg/hugo latest-ext b34dd4f95ea2 14 months ago 1.02GB hello-world latest d2c94e258dcb 15 months ago 13.3kB centos latest 5d0da3dc9764 2 years ago 231MB kuangsheng/centos1.0 latest 2771b5374df0 2 years ago 231MB kuangsheng/centos latest 2771b5374df0 2 years ago 231MB [root@VM-12-5-centos _data]# docker run -it --name docker01 kuangsheng/centos1.0 [root@a9cdbd4560f7 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var volume01 volume02 [root@a9cdbd4560f7 /]# ls -l total 56 lrwxrwxrwx 1 root root 7 Nov 3 2020 bin -\u0026gt; usr/bin drwxr-xr-x 5 root root 360 Aug 5 11:07 dev drwxr-xr-x 1 root root 4096 Aug 5 11:07 etc drwxr-xr-x 2 root root 4096 Nov 3 2020 home lrwxrwxrwx 1 root root 7 Nov 3 2020 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 9 Nov 3 2020 lib64 -\u0026gt; usr/lib64 drwx------ 2 root root 4096 Sep 15 2021 lost+found drwxr-xr-x 2 root root 4096 Nov 3 2020 media drwxr-xr-x 2 root root 4096 Nov 3 2020 mnt drwxr-xr-x 2 root root 4096 Nov 3 2020 opt dr-xr-xr-x 191 root root 0 Aug 5 11:07 proc dr-xr-x--- 2 root root 4096 Sep 15 2021 root drwxr-xr-x 11 root root 4096 Sep 15 2021 run lrwxrwxrwx 1 root root 8 Nov 3 2020 sbin -\u0026gt; usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 2020 srv dr-xr-xr-x 13 root root 0 Aug 5 10:36 sys drwxrwxrwt 7 root root 4096 Sep 15 2021 tmp drwxr-xr-x 12 root root 4096 Sep 15 2021 usr drwxr-xr-x 20 root root 4096 Sep 15 2021 var drwxr-xr-x 2 root root 4096 Aug 5 11:07 volume01 drwxr-xr-x 2 root root 4096 Aug 5 11:07 volume02 [root@a9cdbd4560f7 /]# #那么现在来创建第二个容器，ctrl+p+q退出当前容器但是不退出运行。 #03和02绑定 [root@VM-12-5-centos _data]# docker run -it --name docker03 --volumes-from docker02 kuangsheng/centos1.0 25、数据卷容器_哔哩哔哩_bilibili05:05\n这样创建的docker03会同步到docker02，而父容器02叫数据卷容器。\n如果docker run -it --name docker04 --volumes-from docker02 kuangsheng/centos1.0 中04父容器为02，也是可以同步的。\n04父容器为02也是可以同步的。\n而docker02的父容器为docker01。\n删除了dokcer01其他数据还是依然在的。\n所以是一种备份机制。\n应用：多个mysql实现数据共享，启动两个mysql共用一个数据库行不行? [root@kuangshen home]#docker run -d -p 3310:3306 -v /etc/mysq1/conf.d -v /var/1ib/mysq1 -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7 MYSQL_ROOT_PASSWORD=123456 --name mysq101 mysq1 5.7 [root@kuangshen home]#docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysq102 -- volumes -from mysql01 mysql:5.7 #这个时候，可以实现两个容器数据同步！ 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦你持久化到了本地，这个时候，本地的数据是不会制除的！\n’总结：数据和容器，容器删除了，容器能持久化保存\n一、-v 直接挂载：具名和匿名挂载\n二、dockerfile 构建镜像的时候直接进行挂载\n三、容器数据卷之间的挂载，\u0026ndash;volume from，实现。\n01 02 03 中02删除了，01 03还是能同步。\nDockerFile 核心：用来构建docker镜像的文件。是一个命参数脚本。\n构建步骤：\n1、编写一个dockerfile文件\n2、docker build构建成为一个镜像\n3、docker run运行镜像\n4、docker push 发布镜像（DockerHub、阿里云镜像仓库）\n在dockerhub中点击链接后跳转的就是dockerfile。\n搜索dockerfile命令 centos+tomcat+jdk+mysql\n/bin/bash控制台\n基础知识 1、每个保留关键字（指令）都是必须是大写字母\n2、执行从上到下顺序执行\n3、#表示注释\n4、每一个指令都会创建提交一个新的镜像层，并提交！\ndockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfike文件，这个文件十分简单！\ndocker镜像逐渐成为企业交付的标准，必须要掌握！\n步骤：开发，部署，运维。。。\nDockerFile:构建文件,定义了一切步骤，源代码。\nDockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品！\nDocker容器：容器就是镜像运行起来提供服务的。\n后两个我们已经会了，而第一个需要再学。\nDockerFile的指令 FROM\t#基础镜像，一切从这里开始构建 MAINATINER\t#镜像是谁写的，一般姓名+邮箱 RUN\t#镜像构建的时候需要运行的命令 ADD\t#步骤，tomcat镜像，这个tomcat压缩包！添加内容 WORKDIR\t#镜像的工作目录 VOLUME\t#设置挂载的目录 EXPOSE\t#暴露端口配置 RUN\t# CMD\t#指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代 ENTRYPOINT\t#指定这个容器启动的时候要运行的命令，可以追加命令 容器里面：ls -a 容器外运行 docker run -l\t#那么CMD是替换-l为-a docker run -l\t#追加的命令 ONBUILD\t#当构建一个被继承的Dockerfile 这个时候就会运行ONEBUILD 的指令。是一个触发指令 COPY\t#类似ADD，将我们的文件拷贝到镜像中 ENV\t#构建的时候设置环境变量，myslq用户名密码，内存大小。。。 实战测试 Docker Hub中99%镜像都是从这个基础镜像过来的FROM scratch，配置我们的软件进行配置\n创建一个自己的centos 看看官方的cenos的vim没有config没有\n[root@VM-12-5-centos dockerfile]# vim mydockfile-centos [root@VM-12-5-centos dockerfile]# docker run -it centos [root@98252f5f8b60 /]# pwd / [root@98252f5f8b60 /]# vim bash: vim: command not found [root@98252f5f8b60 /]# ifconfig bash: ifconfig: command not found [root@98252f5f8b60 /]# #编写文件 [root@VM-12-5-centos dockerfile]# vim mydockfile-centos [root@VM-12-5-centos dockerfile]# cat mydockfile-centos [root@VM-12-5-centos dockerfile]# cat mydockfile-centos FROM centos:7 MAINTAINER poolbee\u0026lt;Cr8462643@163.com\u0026gt; ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \u0026#34;------end------\u0026#34; CMD /bin/bash #创建 28、实战：构建自己的centos_哔哩哔哩_bilibili08:03\nDocker网络 企业实战 Docker Compose Docker Swarm CI/CD jenkins 流水线 推荐一本书，docker [deep dive](https://search.bilibili.com/all?from_source=webcommentline_search\u0026keyword=deep dive\u0026amp;seid=10239879385810437677),作者Nigel Poulton，结合这个视频，效果更好\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","title":""}]